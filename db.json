{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"themes/clean-blog/source/css/article.styl","path":"css/article.styl","modified":0,"renderable":1},{"_id":"themes/clean-blog/source/css/base.styl","path":"css/base.styl","modified":0,"renderable":1},{"_id":"themes/clean-blog/source/css/mixins.styl","path":"css/mixins.styl","modified":0,"renderable":1},{"_id":"themes/clean-blog/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/clean-blog/source/css/variables.styl","path":"css/variables.styl","modified":0,"renderable":1},{"_id":"themes/clean-blog/source/img/about-bg.jpg","path":"img/about-bg.jpg","modified":0,"renderable":1},{"_id":"source/images/pasted-0.png","path":"images/pasted-0.png","modified":0,"renderable":0},{"_id":"themes/clean-blog/source/img/home-bg.jpg","path":"img/home-bg.jpg","modified":0,"renderable":1},{"_id":"themes/clean-blog/source/img/contact-bg.jpg","path":"img/contact-bg.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"9610b60e5723ac4b83fb211e9a338232aeab00ab","modified":1562663212079},{"_id":"source/CNAME","hash":"04271e73b293a955602e93a3dcfed4cc9d7473de","modified":1562660014914},{"_id":"themes/clean-blog/README.md","hash":"861dd2f959ab75d121226f4f3e2f61f4bc95fddb","modified":1562660014985},{"_id":"themes/clean-blog/_config.yml","hash":"e7f98be5568b1353a876f20c351cfbd363146ba3","modified":1562660014985},{"_id":"themes/clean-blog/LICENSE","hash":"8726b416df4f067cff579e859f05c4b594b8be09","modified":1562660014985},{"_id":"source/_discarded/AVFoundation学习笔记六-AVAsset.md","hash":"6c4633a886299ec4cda46a7a696a9f035ff25f80","modified":1562660014915},{"_id":"source/_discarded/.DS_Store","hash":"0974454bdb8d7ed50a84680b58083f80e6ebafc3","modified":1562660014914},{"_id":"source/_drafts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1562660014915},{"_id":"source/categories/index.md","hash":"0c0636022f89c33332c469d3fa26810cbf17436a","modified":1562660014979},{"_id":"source/_posts/.DS_Store","hash":"dced5f9a7a911c9989961cd336e8f14258546b54","modified":1562660014915},{"_id":"source/_posts/AVFoundation学习笔记一-AVSpeechSynthesizer.md","hash":"85bf289511e2df4f757a194babf45a15b2b7e6fb","modified":1562660014915},{"_id":"source/_posts/AVFoundation学习笔记一-iOS多媒体环境.md","hash":"64061b6b623e84ce73dd2f814e60145e62d85e6d","modified":1562660014916},{"_id":"source/_posts/AVFoundation学习笔记七-读取相册内容ALAsset和PHAsset.md","hash":"c537013b712339b391b09572002098fad461856c","modified":1562660014918},{"_id":"source/_posts/AVFoundation学习笔记七.md","hash":"a2f3c2db4e60959f996f3cdcb3adde6134fbcbcf","modified":1562660014919},{"_id":"source/_posts/AVFoundation学习笔记九.md","hash":"14a0712465ccb8ee77125cbda90eaedf3df0c3cd","modified":1562660014919},{"_id":"source/_posts/AVFoundation学习笔记二-AVAudioPlayer.md","hash":"9b3ff28627551797ac63074e99d08b218295eb49","modified":1562660014921},{"_id":"source/_posts/AVFoundation学习笔记二-AVAudioSession.md","hash":"7790218bb792db7113e9e1f96d277c40eb5b2e62","modified":1562660014922},{"_id":"source/_posts/AVFoundation学习笔记五-AVAudioRecorder.md","hash":"07b32e70deeb982217384f186dd3826cd7963c08","modified":1562660014923},{"_id":"source/_posts/AVFoundation学习笔记八-AVPlayer及缩略图等相关功能.md","hash":"444df50499a64a39954bbd35472bc059389005de","modified":1562660014925},{"_id":"source/_posts/AVFoundation学习笔记十.md","hash":"a8bf8527a97838f39d340685b3722afd3d5d956a","modified":1562660014928},{"_id":"source/_posts/AVFoundation学习笔记十一.md","hash":"3eafd5c7ada1d55c1e28dcf2ece244c5770da72d","modified":1562660014928},{"_id":"source/_posts/AVFoundation学习笔记十二-AVAssetReader-AVAssetWriter.md","hash":"d83c8e9cbe04034ac3328a6c5399d48d707d7f08","modified":1562660014929},{"_id":"source/_posts/H264-nalu类型及解析.md","hash":"7786254ecfdfaf513ff7afd43fa6507d7343f2ba","modified":1562660014930},{"_id":"source/_posts/QT基础1.md","hash":"2b3a02885f8be1e41cadcf3ff0552a9200b8ba15","modified":1562660014936},{"_id":"source/_posts/H264-profile类型及特点.md","hash":"0bc30bced0981e1fc84c8dc78ce7c534abb5f4df","modified":1562660014933},{"_id":"source/_posts/QT基础10——UDP.md","hash":"1fb1f06d51cfeeb8196a5b12ecf8a74cfc935406","modified":1562660014938},{"_id":"source/_posts/QT基础2——信号和槽.md","hash":"8c24607555d12860b6839e589b95dabccf1682b3","modified":1562660014938},{"_id":"source/_posts/QT基础3——QMainWindow及相关控件.md","hash":"0a3007a1caaac837e33d3d99d68859c2ebc0c1b7","modified":1562660014939},{"_id":"source/_posts/QT基础4——可视化编程.md","hash":"922eaff95a2d453548886fbeaf5b75205a5951d8","modified":1562660014939},{"_id":"source/_posts/QT基础5——事件处理.md","hash":"b562f6b086c64529823a3bf763becc0fdae1f698","modified":1562660014942},{"_id":"source/_posts/QT基础6——基础绘图.md","hash":"0434e2e51d7b06f51ba8e3a2145c0508a3cfc53c","modified":1562660014942},{"_id":"source/_posts/QT基础7——图片加载及保存.md","hash":"2392c8f92e73b509be995e8fd042ae290c8998ab","modified":1562660014943},{"_id":"source/_posts/QT基础8——文件读写.md","hash":"2da420f6a5d15fbac9712d9e7289b1b981daadb9","modified":1562660014943},{"_id":"source/_posts/QT基础9——TCP.md","hash":"117e8f8e49bc9dbf6f54a0a94a70aef53b6b82c5","modified":1562660014943},{"_id":"source/_posts/SRS服务器-二-保存及拉取数据.md","hash":"c67451a31c5dc2fc18000bbbfe91ede208863e79","modified":1562660014944},{"_id":"source/_posts/SRS服务器搭建.md","hash":"d3bf4b593acaa2895daf12547284467758486957","modified":1562660014955},{"_id":"source/_posts/TCP-IP学习笔记一.md","hash":"c9affc3f55fb53d2c8b1cbe2165bdf1eaa75e026","modified":1562660014966},{"_id":"source/_posts/Xcode编译错误-This-application-does-not-support-this-device-s-CPU-type.md","hash":"d605edd1f90101becef1a113dfb90d886da4c698","modified":1562660014968},{"_id":"source/_posts/mac-编译FFmpeg-iOS库.md","hash":"78c8d4a76604d5d84b9c2af0d2a4dcf062e67cb3","modified":1562660014969},{"_id":"source/_posts/V4L视频采集.md","hash":"9b3022415f5af8c02e4d4011fc0580bda860ce63","modified":1562660014967},{"_id":"source/_posts/ssh反向代理操作内网设备.md","hash":"4bf9cec62323d95ad1afcde0b76a3718ad519100","modified":1562660014969},{"_id":"source/_posts/主机-三系统.md","hash":"5cacd9a02c3184102a5eb7c8ae0fb7991e776c65","modified":1562660014973},{"_id":"source/_posts/冒泡排序.md","hash":"e17035a1de5a3544453fc96b11f19717fa18cb81","modified":1562660014976},{"_id":"source/tags/index.md","hash":"4f84d3fbccfa475e49b349fb1fff4bd3b8508969","modified":1562660014981},{"_id":"themes/clean-blog/languages/de.yml","hash":"424a9c1e6ab69334d7873f6574da02ca960aa572","modified":1562660014986},{"_id":"themes/clean-blog/languages/default.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1562660014986},{"_id":"themes/clean-blog/languages/en.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1562660014986},{"_id":"themes/clean-blog/languages/es.yml","hash":"cb4eeca0ed3768a77e0cd216300f2b2549628b1b","modified":1562660014986},{"_id":"themes/clean-blog/languages/fr.yml","hash":"e9e6f7cb362ebb7997f11027498a2748fe3bac95","modified":1562660014986},{"_id":"themes/clean-blog/languages/no.yml","hash":"8ca475a3b4f8efe6603030f0013aae39668230e1","modified":1562660014987},{"_id":"themes/clean-blog/languages/pl.yml","hash":"de7eb5850ae65ba7638e907c805fea90617a988c","modified":1562660014987},{"_id":"themes/clean-blog/languages/pt.yml","hash":"1d0c3689eb32fe13f37f8f6f303af7624ebfbaf0","modified":1562660014987},{"_id":"themes/clean-blog/languages/ru.yml","hash":"42df7afeb7a35dc46d272b7f4fb880a9d9ebcaa5","modified":1562660014987},{"_id":"themes/clean-blog/languages/zh-CN.yml","hash":"7bfcb0b8e97d7e5edcfca8ab26d55d9da2573c1c","modified":1562660014987},{"_id":"themes/clean-blog/languages/zh-TW.yml","hash":"9acac6cc4f8002c3fa53ff69fb8cf66c915bd016","modified":1562660014988},{"_id":"themes/clean-blog/layout/archive.ejs","hash":"f2ef73afc3d275333329bb30b9369b82e119da76","modified":1562660014991},{"_id":"themes/clean-blog/layout/index.ejs","hash":"87995288ca6f95a04add641727aedd3f6afa55eb","modified":1562660014991},{"_id":"themes/clean-blog/layout/layout.ejs","hash":"da2f9018047924ddaf376aee5996c7ddc06cebc1","modified":1562660014991},{"_id":"themes/clean-blog/layout/page.ejs","hash":"591af587e1aae962950de7e79bd25c1f060c69ac","modified":1562660014992},{"_id":"themes/clean-blog/layout/post.ejs","hash":"38382e9bbeb6b8d2eafbd53fff2984111f524c1a","modified":1562660014992},{"_id":"source/_posts/AVFoundation学习笔记一-AVSpeechSynthesizer/SpeechSynthesizer.png","hash":"76d09a8ddc59eac06aa868827ff7f1e6879acac1","modified":1562660014916},{"_id":"source/_posts/AVFoundation学习笔记七-读取相册内容ALAsset和PHAsset/ALAsset.png","hash":"ca9151a361109acf1450c5dff578ee5c0594de85","modified":1562660014918},{"_id":"source/_posts/AVFoundation学习笔记二-AVAudioPlayer/audioplayer.png","hash":"d3531a4e9e4fb870567cfbd1ac89bb69605fa603","modified":1562660014921},{"_id":"source/_posts/AVFoundation学习笔记五-AVAudioRecorder/recorder.png","hash":"5a61a1b266d543f66c32d5f1ca870a2707ecf88d","modified":1562660014924},{"_id":"source/_posts/AVFoundation学习笔记八-AVPlayer及缩略图等相关功能/option_result.png","hash":"643d9c20b9db183ffbb54e675b2590f6a2279c53","modified":1562660014926},{"_id":"source/_posts/AVFoundation学习笔记十二-AVAssetReader-AVAssetWriter/read_write.png","hash":"c192695a9a7a207098a1b492d62629c8a34f4b1b","modified":1562660014929},{"_id":"source/_posts/H264-nalu类型及解析/nalu_zc.jpg","hash":"267c8ef24e3c2d740c80041ca9f667ae83c9c071","modified":1562660014932},{"_id":"source/_posts/QT基础1/qt_files.png","hash":"5594b7ee18a476507c3d41974cf6dc8690a12809","modified":1562660014937},{"_id":"source/_posts/QT基础4——可视化编程/design_add.png","hash":"cf4388e9015328b0f856814594c108d46647a92e","modified":1562660014940},{"_id":"source/_posts/QT基础4——可视化编程/design_result.png","hash":"f029e393b50c671d75a9e139f8afc478f418be03","modified":1562660014941},{"_id":"source/_posts/QT基础4——可视化编程/design_slot.png","hash":"f84de11ad85a1f9368613e7187b8c35981c306a8","modified":1562660014942},{"_id":"source/_posts/SRS服务器-二-保存及拉取数据/obs_set.png","hash":"975b007a3f48adf383b5726125a5d1f77e3e9cc8","modified":1562660014944},{"_id":"source/_posts/SRS服务器-二-保存及拉取数据/pushing.png","hash":"8ad7988477db59b0056448b278e7d6bab234fbf3","modified":1562660014948},{"_id":"source/_posts/SRS服务器-二-保存及拉取数据/pushed.png","hash":"f118bf8bd75f6d39f149c2f127346e21f8d96e1a","modified":1562660014948},{"_id":"source/_posts/SRS服务器搭建/obs.png","hash":"8eab194324c4fa5958d9c2acfea85eccf0ae058b","modified":1562660014956},{"_id":"source/_posts/SRS服务器搭建/rtmp映射.png","hash":"c8b050e5845450169a81d8bec9e1277d5c67b85f","modified":1562660014965},{"_id":"source/_posts/SRS服务器搭建/vlc.png","hash":"26c40bfcb2f848ca5e6c83f342546aef0a519157","modified":1562660014966},{"_id":"source/_posts/Xcode编译错误-This-application-does-not-support-this-device-s-CPU-type/buildSetting.png","hash":"1398869635d16ce1c16904589e33a4811381c50d","modified":1562660014968},{"_id":"source/_posts/ssh反向代理操作内网设备/connect.png","hash":"b1d4cd4a3ed7cf8a0b556f9e63d395de41cc95fd","modified":1562660014970},{"_id":"source/_posts/ssh反向代理操作内网设备/ssh_l.png","hash":"7c8efec7a59edd54067049cc72373965364adbb1","modified":1562660014972},{"_id":"source/_posts/ssh反向代理操作内网设备/ssh_r.png","hash":"3768133545991781ceba9f3350451ecdb7c76900","modified":1562660014972},{"_id":"source/_posts/ssh反向代理操作内网设备/免密.png","hash":"a84a425c18f48c2ca6a34da3e2d064c275674b90","modified":1562660014973},{"_id":"source/_posts/ssh反向代理操作内网设备/检验免密.png","hash":"17a6e723362c1bd43058e757fff45ae7a22a7bff","modified":1562660014973},{"_id":"source/_posts/主机-三系统/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1562660014974},{"_id":"themes/clean-blog/layout/_partial/after-footer.ejs","hash":"80970a6cfbf9b1abe0c472636b321a9be08fdc43","modified":1562660014988},{"_id":"themes/clean-blog/layout/_partial/article-archive.ejs","hash":"3d8d98c6545b8332a6d6ed4f8b00327df03ea945","modified":1562660014988},{"_id":"themes/clean-blog/layout/_partial/article-categories.ejs","hash":"5a0bf5a20f670621d8013c9b9d7976b45c8aa80f","modified":1562660014988},{"_id":"themes/clean-blog/layout/_partial/article-full.ejs","hash":"0e7aa9da47f29b2312d9d3165c067576ebca77cf","modified":1562660014989},{"_id":"themes/clean-blog/layout/_partial/article-index.ejs","hash":"e433df4e245e2d4c628052c6e59966563542d94d","modified":1562660014989},{"_id":"themes/clean-blog/layout/_partial/article-tags.ejs","hash":"6136434be09056c1466149cecb3cc2e80d107999","modified":1562660014989},{"_id":"themes/clean-blog/layout/_partial/footer.ejs","hash":"d252fb1a41890e6481bb054f9cc4ceec3c0b0ed9","modified":1562660014990},{"_id":"themes/clean-blog/layout/_partial/comments.ejs","hash":"3fedb75436439d1d6979b7e4d20d48a593e12be4","modified":1562660014989},{"_id":"themes/clean-blog/layout/_partial/gallery.ejs","hash":"21e4f28909f4a79ff7d9f10bdfef6a8cb11632bf","modified":1562660014990},{"_id":"themes/clean-blog/layout/_partial/google-analytics.ejs","hash":"4e6e8de9becea5a1636a4dcadcf7a10c06e2426e","modified":1562660014990},{"_id":"themes/clean-blog/layout/_partial/head.ejs","hash":"3ccfc84e3ed67415fe71a1767d5e77a6b1f84a7a","modified":1562660014990},{"_id":"themes/clean-blog/layout/_partial/menu.ejs","hash":"ba299316400499e9ede154e9627cafb7ce411888","modified":1562660014990},{"_id":"themes/clean-blog/layout/_partial/pagination.ejs","hash":"557d6bb069a1d48af49ae912994653f44b32a570","modified":1562660014991},{"_id":"themes/clean-blog/layout/_partial/tag-category-index.ejs","hash":"10cdc1b7866999c714a666557c150d2c79c1fba9","modified":1562660014991},{"_id":"themes/clean-blog/source/css/article.styl","hash":"f5294d7a3d6127fcb287de3ff0c12aebb1766c7b","modified":1562660014992},{"_id":"themes/clean-blog/source/css/base.styl","hash":"0b54825903d08b5f7f7fe95ef4261c90e980abdb","modified":1562660014992},{"_id":"themes/clean-blog/source/css/mixins.styl","hash":"892f55e8a71f2e23a52e48e217dad3303bbad913","modified":1562660014992},{"_id":"themes/clean-blog/source/css/style.styl","hash":"c40dc495a41007d21c59f342ee42b2d31d7b5ff4","modified":1562660014993},{"_id":"themes/clean-blog/source/css/variables.styl","hash":"cd82df5ca8dfbcfec12d833f01adfac00878e835","modified":1562660014993},{"_id":"themes/clean-blog/source/img/about-bg.jpg","hash":"d39126a6456f2bac0169d1779304725f179c9900","modified":1562660014993},{"_id":"source/images/pasted-0.png","hash":"ae0edd367ca9d7aeacc30ea9d4382330ff0f39ca","modified":1562660014981},{"_id":"source/_posts/AVFoundation学习笔记七-读取相册内容ALAsset和PHAsset/PHAsset.png","hash":"fc461026f4100148ec42855de6fd90dcda3547c0","modified":1562660014919},{"_id":"source/_posts/AVFoundation学习笔记五-AVAudioRecorder/audio_format.png","hash":"8bcd0f338cce16fa6bcad82cccb809ae5d9720d4","modified":1562660014924},{"_id":"source/_posts/H264-nalu类型及解析/nalu_type_define.png","hash":"c76cd6a21ce42b78b6739c3d56f2e8b4850ccc80","modified":1562660014932},{"_id":"source/_posts/H264-profile类型及特点/profile_feather.png","hash":"ac31e4941b8e04f5fe30b49fba0225a1e2b136d1","modified":1562660014935},{"_id":"source/_posts/ssh反向代理操作内网设备/gotohttp.png","hash":"0d45a756d7fe6edc52a3747c76a44b55f6eaa810","modified":1562660014972},{"_id":"source/_posts/AVFoundation学习笔记九/capture_session1.png","hash":"cfecf68dfeb28b4b2df8df63faa63f9f8866d0dc","modified":1562660014920},{"_id":"source/_posts/H264-nalu类型及解析/h264_data.png","hash":"ffbe539dc424f662678b948985a3b9a25670250e","modified":1562660014931},{"_id":"source/_posts/AVFoundation学习笔记一-iOS多媒体环境/ios_media.png","hash":"cb7dcb8b3457f737fb3b2ac4a0646e16302a901c","modified":1562660014918},{"_id":"themes/clean-blog/source/img/home-bg.jpg","hash":"990f6f9dd0ecb5348bfcc47305553d58c0d8f326","modified":1562660014995},{"_id":"source/_posts/AVFoundation学习笔记二-AVAudioSession/session_category.png","hash":"ae0edd367ca9d7aeacc30ea9d4382330ff0f39ca","modified":1562660014923},{"_id":"source/_posts/H264-profile类型及特点/profile_decode.png","hash":"cc925739a24a21d2be7e761b47d37b7f234590df","modified":1562660014934},{"_id":"source/_posts/QT基础1/help_add_frame.png","hash":"9345649edbff114947ea3d409d078b23a09de400","modified":1562660014937},{"_id":"source/_posts/QT基础4——可视化编程/design_all.png","hash":"e4c3a6a4084f2201444facddc55c938c8aca9631","modified":1562660014941},{"_id":"source/_posts/AVFoundation学习笔记八-AVPlayer及缩略图等相关功能/player_classes.png","hash":"c58ac99eba8668d452a1c81ca01fc1644a764ff7","modified":1562660014927},{"_id":"source/_posts/冒泡排序/冒泡.png","hash":"a1a2d1d4b2ede47f70170d9d34b81e2c74d69e49","modified":1562660014978},{"_id":"themes/clean-blog/source/img/contact-bg.jpg","hash":"6af63305c923899017e727b5ca968a2703bc08cf","modified":1562660014994},{"_id":"source/_posts/主机-三系统/主机.png","hash":"548cc0a259d98f62bfee7d73eb8c3d448295a800","modified":1562660014975},{"_id":"source/_posts/SRS服务器-二-保存及拉取数据/play_file.png","hash":"74ac117a6b4a32317a8f18a3ff185ea74c90b33a","modified":1562660014947},{"_id":"source/_posts/SRS服务器搭建/result_rtmp.png","hash":"e11ba3864e98fffdde706d009c03711e181cd261","modified":1562660014963},{"_id":"source/_posts/SRS服务器-二-保存及拉取数据/vlc_play.png","hash":"0f378ec9990a6c4e831b3bcc272a5a99d35799fc","modified":1562660014953},{"_id":"public/categories/index.html","hash":"bd201788e96e9df73c7f218d2820dec752189c97","modified":1565081884402},{"_id":"public/tags/index.html","hash":"646e040e9ffdd14ed3ad28ae27b35d87d3c12f9c","modified":1565081884402},{"_id":"public/2019/01/27/H264-nalu类型及解析/index.html","hash":"23967302a41e7998a5cc4533e330c5c10a5fcd76","modified":1565081884403},{"_id":"public/2019/01/01/QT基础10——UDP/index.html","hash":"0f04f4d2dd6059553d00c37e3677ce8b5d206ad1","modified":1565081884403},{"_id":"public/2019/01/24/H264-profile类型及特点/index.html","hash":"a495eef19b9217a5a5290be1aac65490a825aa9c","modified":1565081884403},{"_id":"public/2018/12/29/QT基础6——基础绘图/index.html","hash":"5b212a836496bd9117476fe48bffcb84597948ff","modified":1565081884403},{"_id":"public/2018/12/16/QT基础4——可视化编程/index.html","hash":"ecd319c3509cc277a6301f541cf4709cffd8afdb","modified":1565081884403},{"_id":"public/2018/11/12/mac-编译FFmpeg-iOS库/index.html","hash":"32b7e80c881a03c0e8716c092f56de672ed5ee34","modified":1565081884403},{"_id":"public/2018/11/08/AVFoundation学习笔记七/index.html","hash":"e7225577eed99f0acae8834d9a3f38deb9cc75bf","modified":1565081884403},{"_id":"public/2018/11/05/AVFoundation学习笔记七-读取相册内容ALAsset和PHAsset/index.html","hash":"2d1efa4544a3e7676e3f7987e4b846aa005cc35f","modified":1565081884403},{"_id":"public/2018/11/08/主机-三系统/index.html","hash":"247f66cbc0f3de34976f1cd264f8c0ab786f5646","modified":1565081884403},{"_id":"public/2018/11/02/AVFoundation学习笔记五-AVAudioRecorder/index.html","hash":"767d156177a07b367ecb613006967b804313bc1d","modified":1565081884403},{"_id":"public/2018/10/31/SRS服务器-二-保存及拉取数据/index.html","hash":"200d585f6c0bc0d061073f66492a22b6558f13ce","modified":1565081884403},{"_id":"public/2018/11/01/AVFoundation学习笔记二-AVAudioPlayer/index.html","hash":"3e48a852605b061129798cd5578d1256821f5b67","modified":1565081884403},{"_id":"public/2018/10/31/Xcode编译错误-This-application-does-not-support-this-device-s-CPU-type/index.html","hash":"47fed9068bcb01557736ea36ba77469cbb742105","modified":1565081884404},{"_id":"public/2018/10/24/AVFoundation学习笔记一-AVSpeechSynthesizer/index.html","hash":"37066ee199d1772c1e9a393ddee3781d12feff87","modified":1565081884404},{"_id":"public/2018/10/24/AVFoundation学习笔记一-iOS多媒体环境/index.html","hash":"318cc2eee328b40770175a1f549c4ae0c57c0aea","modified":1565081884404},{"_id":"public/2018/10/23/SRS服务器搭建/index.html","hash":"6971bcc65ab3545c8b04006bccfe74a0f5d48d3d","modified":1565081884404},{"_id":"public/2018/10/23/冒泡排序/index.html","hash":"b0d9d5c7028fca034cb70856d8a163c7790133d5","modified":1565081884404},{"_id":"public/2018/10/23/TCP-IP学习笔记一/index.html","hash":"7cc85f2d479a33fce4cde7a0567c96e94535f388","modified":1565081884404},{"_id":"public/archives/index.html","hash":"b5d493fb0ad3be6443ea308dc9464aae5d2fa7d6","modified":1565081884404},{"_id":"public/archives/page/2/index.html","hash":"25ac402cfaf06ae7da8a74dc25db1e24ab8bfb9f","modified":1565081884404},{"_id":"public/archives/page/3/index.html","hash":"ee2b19714e4e2d13c2caace6bae3655e5b5578c3","modified":1565081884404},{"_id":"public/archives/page/4/index.html","hash":"f2807f967dcee81f4c03ccc36bfba0940bd0a7dc","modified":1565081884404},{"_id":"public/archives/2018/index.html","hash":"818f98dcf9dc599f16f429bb49c1117c22e78bb1","modified":1565081884404},{"_id":"public/archives/2018/page/2/index.html","hash":"f245e950439ad14ffedf92a62115d23c2ece73fa","modified":1565081884404},{"_id":"public/archives/2018/page/3/index.html","hash":"d98cc66681319a57f2fe6e0ee113e33c01b683c4","modified":1565081884404},{"_id":"public/archives/2018/10/index.html","hash":"8e21628cfa2e39f2714995f1cd8875c278e1705f","modified":1565081884404},{"_id":"public/archives/2018/11/index.html","hash":"1f85bd51c5f16be696d8dd7cd653b5ad13637b2e","modified":1565081884404},{"_id":"public/archives/2018/11/page/2/index.html","hash":"06d5aaa1bdd9a965b2ab211c7f5887aadc6bf750","modified":1565081884405},{"_id":"public/archives/2018/12/index.html","hash":"933d1a5ce679e8a5a14cf3ca3f884e1b5046f519","modified":1565081884405},{"_id":"public/archives/2019/index.html","hash":"d1e6c668b9fc8233b1ee66c8e0594ca94b1bda2e","modified":1565081884405},{"_id":"public/archives/2019/01/index.html","hash":"fdc0dfd937acb372222f8e820495ba0668f0c51b","modified":1565081884405},{"_id":"public/archives/2019/04/index.html","hash":"2e2876b750b5d576ed693921cd334e971c0ee141","modified":1565081884405},{"_id":"public/categories/AVFoundation/index.html","hash":"e780ecf80da6e546d50e12b605000cd1f855fbca","modified":1565081884405},{"_id":"public/categories/AVFoundation/page/2/index.html","hash":"987bac02d31bca3a430d64159dc0d5c6c33a41f7","modified":1565081884405},{"_id":"public/categories/音视频/index.html","hash":"f313b327837c7a4298e99485b815edf07262d3a8","modified":1565081884405},{"_id":"public/categories/QT/index.html","hash":"0f1b04847e4c2866a606d64eec84cd3836d2b2e6","modified":1565081884405},{"_id":"public/categories/rtmp/index.html","hash":"3b3e91a4fe4be35c3452fc9c6869fdbcbd66f885","modified":1565081884405},{"_id":"public/categories/网络协议/index.html","hash":"ecc09d4c25b06e765e8422bbcd1b8f5127dfa8b1","modified":1565081884406},{"_id":"public/categories/iOS/index.html","hash":"501a692ff708e3a13e7fd4ff25a9647b456b08af","modified":1565081884406},{"_id":"public/categories/杂记/index.html","hash":"4af66c563d6f209f5f2a499e741a5775c8c9f435","modified":1565081884406},{"_id":"public/categories/算法/index.html","hash":"d90db3cd7058e3339b01b41111f86d80002503a7","modified":1565081884406},{"_id":"public/index.html","hash":"07e4922d1fda28dedffc93a2a9ae85dea9c24588","modified":1565081884406},{"_id":"public/page/2/index.html","hash":"7a8372010baff025b20606ef7b4f7f2e8c5af97a","modified":1565081884406},{"_id":"public/page/3/index.html","hash":"dc33af9f71805df98c8307f1c1021fa27c9dd219","modified":1565081884406},{"_id":"public/page/4/index.html","hash":"8648d22db870ff18c917a003497086ac20ef4fb3","modified":1565081884407},{"_id":"public/tags/文本语音播报/index.html","hash":"26a6b674480ec2e7daa0942ba7dd7e041c9487c9","modified":1565081884407},{"_id":"public/tags/SRS/index.html","hash":"57cc62f73ce7bdd2ebfcee11de420ed4aa78894c","modified":1565081884407},{"_id":"public/tags/TCP-IP/index.html","hash":"61d30d9d85ea4c1c7462ed1472e7024bd9419ec3","modified":1565081884407},{"_id":"public/tags/Xcode问题/index.html","hash":"d7aa26d3b813be3fc7594a414a229accba4073a6","modified":1565081884407},{"_id":"public/tags/八大排序/index.html","hash":"5dbe031809655f0bda9193990afd11fb8f9ad08e","modified":1565081884407},{"_id":"public/2019/04/09/ssh反向代理操作内网设备/index.html","hash":"86bd35252932ee5c338f927367ee0ee394e1fc0f","modified":1565081884407},{"_id":"public/2019/01/31/V4L视频采集/index.html","hash":"8a159f82ab0b1033654ff9c46b937a772d870405","modified":1565081884407},{"_id":"public/2019/01/01/QT基础8——文件读写/index.html","hash":"9381bb882af9efa065afbaf5f0b9b678806a387c","modified":1565081884407},{"_id":"public/2019/01/01/QT基础9——TCP/index.html","hash":"97cc99bbf839c8e84858d8d7cbab9bb493bf0547","modified":1565081884407},{"_id":"public/2018/12/31/QT基础7——图片加载及保存/index.html","hash":"8690443a1db1cb969b64fc59633da43b0238668f","modified":1565081884407},{"_id":"public/2018/12/20/QT基础5——事件处理/index.html","hash":"d18ebd9323b6358f39cbfb98b4d6f0cf6663f165","modified":1565081884407},{"_id":"public/2018/12/15/QT基础3——QMainWindow及相关控件/index.html","hash":"daf751aa3a697897c5422534fa741f6d4c0ae5e3","modified":1565081884407},{"_id":"public/2018/12/13/QT基础2——信号和槽/index.html","hash":"f8693fd28311af414316f4d718717604b827a34b","modified":1565081884408},{"_id":"public/2018/12/12/QT基础1/index.html","hash":"9324a41b88fc8dfa4ac84305b82cfead34fdb3ba","modified":1565081884408},{"_id":"public/2018/11/12/AVFoundation学习笔记十二-AVAssetReader-AVAssetWriter/index.html","hash":"1e6df3fb1c669ed7ae9c351f4d2127e8137d1da5","modified":1565081884408},{"_id":"public/2018/11/12/AVFoundation学习笔记十一/index.html","hash":"44882a503d6224e717d49007f9b673e6f6bae028","modified":1565081884408},{"_id":"public/2018/11/12/AVFoundation学习笔记十/index.html","hash":"cbd3b8436c8475a756cbaf4852a68002ac978fe9","modified":1565081884408},{"_id":"public/2018/11/12/AVFoundation学习笔记九/index.html","hash":"dfe8299dec6184464cb536b9d211e6c515b22b2a","modified":1565081884408},{"_id":"public/2018/11/08/AVFoundation学习笔记八-AVPlayer及缩略图等相关功能/index.html","hash":"82e886a5a2eb6ded154cdf3b432cf4fb46997d0b","modified":1565081884408},{"_id":"public/2018/10/25/AVFoundation学习笔记二-AVAudioSession/index.html","hash":"87a4b27cf7c1f68824ac565b9008c28036d898ac","modified":1565081884408}],"Category":[{"name":"AVFoundation","_id":"cjyzlbt7k00040j66f1k7zu8t"},{"name":"音视频","_id":"cjyzlbt8c000n0j66i075ukim"},{"name":"QT","_id":"cjyzlbt8f000t0j66lxt60rd5"},{"name":"rtmp","_id":"cjyzlbt8w001f0j661qpsotv8"},{"name":"网络协议","_id":"cjyzlbt93001t0j66mxktuhri"},{"name":"iOS","_id":"cjyzlbt9500200j66ivo7791s"},{"name":"杂记","_id":"cjyzlbt9600250j66g1rb4rgu"},{"name":"算法","_id":"cjyzlbt9600290j662755w1g4"}],"Data":[],"Page":[{"title":"categories","date":"2018-10-23T06:44:06.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"title: categories\ndate: 2018-10-23 14:44:06\ntype: \"categories\"\n---\n","updated":"2019-07-09T08:13:34.979Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cjyzlbt7700000j66mdwsc17g","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2015-10-19T22:49:50.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"title: tags\ndate: 2015-10-20 06:49:50\ntype: \"tags\"\ncomments: false\n---\n","updated":"2019-07-09T08:13:34.981Z","path":"tags/index.html","layout":"page","_id":"cjyzlbt7g00020j66gg9p6flt","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"AVFoundation学习笔记二  Speech Synthesis","author":"Cyrus","date":"2018-10-24T15:07:00.000Z","_content":"AVFoundation的文本朗诵主要由以下三个类组成：AVSpeechSynthesizer（语音合成器）、AVSpeechUtterance（语音内容）和AVSpeechSynthesisVoice（语音口音）。这三个类的关系如下图：\n![](SpeechSynthesizer.png)\n简单来说就是一个语音合成器（AVSpeechSynthesizer）可以播放一个或多个可以设置口音（AVSpeechSynthesisVoice）、语调、语速的语音内容（AVSpeechUtterance）。\n\n具体代码步骤：\n1、初始化一个AVSpeechSynthesizer对象\n```\n_synthesizer = [[AVSpeechSynthesizer alloc] init];\n```\n\n2、创建要朗诵的内容\n```\n_speechStrings = @[@\"Hello AV Foundation. How are you?\",\n                           @\"I'm well! Thanks for asking.\",\n                           @\"Are you excited about the book?\",\n                           @\"Very! I have always felt so misunderstood.\",\n                           @\"What's your favorite feature?\",\n                           @\"Oh, they're all my babies.  I couldn't possibly choose.\",\n                           @\"It was great to speak with you!\",\n                           @\"The pleasure was all mine!  Have fun!\"\n                           ];\n```\n\n3、为每个字符串创建一个AVSpeechUtterance对象,并传递给self.synthesizer进行播放\n```\nfor (NSUInteger i = 0; i < self.speechStrings.count; i++) {\n        AVSpeechUtterance *utterance = [[AVSpeechUtterance alloc] initWithString:self.speechStrings[i]];\n        utterance.voice = [AVSpeechSynthesisVoice voiceWithLanguage:@\"en-US\"];\n        utterance.rate = 0.4;\n        utterance.pitchMultiplier = 0.8f;       //声调，0.5（低音调）-2.0（高音调）\n        utterance.postUtteranceDelay = 0.1f;    //播放下一句之前有短时间的暂停\n        [self.synthesizer speakUtterance:utterance];\n    }\n```\n\n相关属性：\n\nAVSpeechSynthesisVoice相关属性\n\n（1）language:voice的主要属性，可以根据language创建voice。可以使用\n```\n+ (NSArray<AVSpeechSynthesisVoice *> *)speechVoices;\n```\n获取所有支持的language,具体如下：\n* Arabic (ar-SA)\n* Chinese (zh-CN, zh-HK, zh-TW)\n* Czech (cs-CZ)\n* Danish (da-DK)\n* Dutch (nl-BE, nl-NL)\n* English (en-AU, en-GB, en-IE, en-US, en-ZA)\n* Finnish (fi-FI)\n* French (fr-CA, fr-FR)\n* German (de-DE)\n* Greek (el-GR)\n* Hebrew (he-IL)\n* Hindi (hi-IN)\n* Hungarian (hu-HU)\n* Indonesian (id-ID)\n* Italian (it-IT)\n* Japanese (ja-JP)\n* Korean (ko-KR)\n* Norwegian (no-NO)\n* Polish (pl-PL)\n* Portuguese (pt-BR, pt-PT)\n* Romanian (ro-RO)\n* Russian (ru-RU)\n* Slovak (sk-SK)\n* Spanish (es-ES, es-MX)\n* Swedish (sv-SE)\n* Thai (th-TH)\n* Turkish (tr-TR)\n\n（2）***quality***：声音质量，枚举值\n```\ntypedef NS_ENUM(NSInteger, AVSpeechSynthesisVoiceQuality) {\n    AVSpeechSynthesisVoiceQualityDefault = 1,\t//默认\n    AVSpeechSynthesisVoiceQualityEnhanced\t\t//增强\n} NS_ENUM_AVAILABLE(10_14, 9_0);\n```\n\nAVSpeechUtterance相关属性\n\n（1）***rate***:指定播放语音时的速率(0.0-1.0),即AVSpeechUtteranceMinimumSpeechRate和AVSpeechUtteranceMaximumSpeechRate之间\n\n（2）***pitchMultiplier***：设置声调,属性值介于0.5(低音调)~2.0(高音调)之间\n\n（3）***volume***:设置音量(0.0-1.0)\n\n（4）***preUtteranceDelay***：postUtteranceDelay告诉synthesizer本句朗读结束后要延迟多少秒再接着朗读下一秒,对应的属性还有***preUtteranceDelay***\n\n此外,<font color=0xff000000>***AVSpeechSynthesizerDelegate***</font>中还提供了一些监听朗读状态的方法.","source":"_posts/AVFoundation学习笔记一-AVSpeechSynthesizer.md","raw":"title: AVFoundation学习笔记二  Speech Synthesis\nauthor: Cyrus\ntags:\n  - 文本语音播报\ncategories:\n  - AVFoundation\ndate: 2018-10-24 23:07:00\n---\nAVFoundation的文本朗诵主要由以下三个类组成：AVSpeechSynthesizer（语音合成器）、AVSpeechUtterance（语音内容）和AVSpeechSynthesisVoice（语音口音）。这三个类的关系如下图：\n![](SpeechSynthesizer.png)\n简单来说就是一个语音合成器（AVSpeechSynthesizer）可以播放一个或多个可以设置口音（AVSpeechSynthesisVoice）、语调、语速的语音内容（AVSpeechUtterance）。\n\n具体代码步骤：\n1、初始化一个AVSpeechSynthesizer对象\n```\n_synthesizer = [[AVSpeechSynthesizer alloc] init];\n```\n\n2、创建要朗诵的内容\n```\n_speechStrings = @[@\"Hello AV Foundation. How are you?\",\n                           @\"I'm well! Thanks for asking.\",\n                           @\"Are you excited about the book?\",\n                           @\"Very! I have always felt so misunderstood.\",\n                           @\"What's your favorite feature?\",\n                           @\"Oh, they're all my babies.  I couldn't possibly choose.\",\n                           @\"It was great to speak with you!\",\n                           @\"The pleasure was all mine!  Have fun!\"\n                           ];\n```\n\n3、为每个字符串创建一个AVSpeechUtterance对象,并传递给self.synthesizer进行播放\n```\nfor (NSUInteger i = 0; i < self.speechStrings.count; i++) {\n        AVSpeechUtterance *utterance = [[AVSpeechUtterance alloc] initWithString:self.speechStrings[i]];\n        utterance.voice = [AVSpeechSynthesisVoice voiceWithLanguage:@\"en-US\"];\n        utterance.rate = 0.4;\n        utterance.pitchMultiplier = 0.8f;       //声调，0.5（低音调）-2.0（高音调）\n        utterance.postUtteranceDelay = 0.1f;    //播放下一句之前有短时间的暂停\n        [self.synthesizer speakUtterance:utterance];\n    }\n```\n\n相关属性：\n\nAVSpeechSynthesisVoice相关属性\n\n（1）language:voice的主要属性，可以根据language创建voice。可以使用\n```\n+ (NSArray<AVSpeechSynthesisVoice *> *)speechVoices;\n```\n获取所有支持的language,具体如下：\n* Arabic (ar-SA)\n* Chinese (zh-CN, zh-HK, zh-TW)\n* Czech (cs-CZ)\n* Danish (da-DK)\n* Dutch (nl-BE, nl-NL)\n* English (en-AU, en-GB, en-IE, en-US, en-ZA)\n* Finnish (fi-FI)\n* French (fr-CA, fr-FR)\n* German (de-DE)\n* Greek (el-GR)\n* Hebrew (he-IL)\n* Hindi (hi-IN)\n* Hungarian (hu-HU)\n* Indonesian (id-ID)\n* Italian (it-IT)\n* Japanese (ja-JP)\n* Korean (ko-KR)\n* Norwegian (no-NO)\n* Polish (pl-PL)\n* Portuguese (pt-BR, pt-PT)\n* Romanian (ro-RO)\n* Russian (ru-RU)\n* Slovak (sk-SK)\n* Spanish (es-ES, es-MX)\n* Swedish (sv-SE)\n* Thai (th-TH)\n* Turkish (tr-TR)\n\n（2）***quality***：声音质量，枚举值\n```\ntypedef NS_ENUM(NSInteger, AVSpeechSynthesisVoiceQuality) {\n    AVSpeechSynthesisVoiceQualityDefault = 1,\t//默认\n    AVSpeechSynthesisVoiceQualityEnhanced\t\t//增强\n} NS_ENUM_AVAILABLE(10_14, 9_0);\n```\n\nAVSpeechUtterance相关属性\n\n（1）***rate***:指定播放语音时的速率(0.0-1.0),即AVSpeechUtteranceMinimumSpeechRate和AVSpeechUtteranceMaximumSpeechRate之间\n\n（2）***pitchMultiplier***：设置声调,属性值介于0.5(低音调)~2.0(高音调)之间\n\n（3）***volume***:设置音量(0.0-1.0)\n\n（4）***preUtteranceDelay***：postUtteranceDelay告诉synthesizer本句朗读结束后要延迟多少秒再接着朗读下一秒,对应的属性还有***preUtteranceDelay***\n\n此外,<font color=0xff000000>***AVSpeechSynthesizerDelegate***</font>中还提供了一些监听朗读状态的方法.","slug":"AVFoundation学习笔记一-AVSpeechSynthesizer","published":1,"updated":"2019-07-09T08:13:34.915Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyzlbt7900010j66uz1rigmb","content":"<p>AVFoundation的文本朗诵主要由以下三个类组成：AVSpeechSynthesizer（语音合成器）、AVSpeechUtterance（语音内容）和AVSpeechSynthesisVoice（语音口音）。这三个类的关系如下图：<br><img src=\"//www.cyrus.fun/2018/10/24/AVFoundation学习笔记一-AVSpeechSynthesizer/SpeechSynthesizer.png\" alt=\"\"><br>简单来说就是一个语音合成器（AVSpeechSynthesizer）可以播放一个或多个可以设置口音（AVSpeechSynthesisVoice）、语调、语速的语音内容（AVSpeechUtterance）。</p>\n<p>具体代码步骤：<br>1、初始化一个AVSpeechSynthesizer对象<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_synthesizer = [[AVSpeechSynthesizer alloc] init];</span><br></pre></td></tr></table></figure></p>\n<p>2、创建要朗诵的内容<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_speechStrings = @[@&quot;Hello AV Foundation. How are you?&quot;,</span><br><span class=\"line\">                           @&quot;I&apos;m well! Thanks for asking.&quot;,</span><br><span class=\"line\">                           @&quot;Are you excited about the book?&quot;,</span><br><span class=\"line\">                           @&quot;Very! I have always felt so misunderstood.&quot;,</span><br><span class=\"line\">                           @&quot;What&apos;s your favorite feature?&quot;,</span><br><span class=\"line\">                           @&quot;Oh, they&apos;re all my babies.  I couldn&apos;t possibly choose.&quot;,</span><br><span class=\"line\">                           @&quot;It was great to speak with you!&quot;,</span><br><span class=\"line\">                           @&quot;The pleasure was all mine!  Have fun!&quot;</span><br><span class=\"line\">                           ];</span><br></pre></td></tr></table></figure></p>\n<p>3、为每个字符串创建一个AVSpeechUtterance对象,并传递给self.synthesizer进行播放<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for (NSUInteger i = 0; i &lt; self.speechStrings.count; i++) &#123;</span><br><span class=\"line\">        AVSpeechUtterance *utterance = [[AVSpeechUtterance alloc] initWithString:self.speechStrings[i]];</span><br><span class=\"line\">        utterance.voice = [AVSpeechSynthesisVoice voiceWithLanguage:@&quot;en-US&quot;];</span><br><span class=\"line\">        utterance.rate = 0.4;</span><br><span class=\"line\">        utterance.pitchMultiplier = 0.8f;       //声调，0.5（低音调）-2.0（高音调）</span><br><span class=\"line\">        utterance.postUtteranceDelay = 0.1f;    //播放下一句之前有短时间的暂停</span><br><span class=\"line\">        [self.synthesizer speakUtterance:utterance];</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>相关属性：</p>\n<p>AVSpeechSynthesisVoice相关属性</p>\n<p>（1）language:voice的主要属性，可以根据language创建voice。可以使用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (NSArray&lt;AVSpeechSynthesisVoice *&gt; *)speechVoices;</span><br></pre></td></tr></table></figure></p>\n<p>获取所有支持的language,具体如下：</p>\n<ul>\n<li>Arabic (ar-SA)</li>\n<li>Chinese (zh-CN, zh-HK, zh-TW)</li>\n<li>Czech (cs-CZ)</li>\n<li>Danish (da-DK)</li>\n<li>Dutch (nl-BE, nl-NL)</li>\n<li>English (en-AU, en-GB, en-IE, en-US, en-ZA)</li>\n<li>Finnish (fi-FI)</li>\n<li>French (fr-CA, fr-FR)</li>\n<li>German (de-DE)</li>\n<li>Greek (el-GR)</li>\n<li>Hebrew (he-IL)</li>\n<li>Hindi (hi-IN)</li>\n<li>Hungarian (hu-HU)</li>\n<li>Indonesian (id-ID)</li>\n<li>Italian (it-IT)</li>\n<li>Japanese (ja-JP)</li>\n<li>Korean (ko-KR)</li>\n<li>Norwegian (no-NO)</li>\n<li>Polish (pl-PL)</li>\n<li>Portuguese (pt-BR, pt-PT)</li>\n<li>Romanian (ro-RO)</li>\n<li>Russian (ru-RU)</li>\n<li>Slovak (sk-SK)</li>\n<li>Spanish (es-ES, es-MX)</li>\n<li>Swedish (sv-SE)</li>\n<li>Thai (th-TH)</li>\n<li>Turkish (tr-TR)</li>\n</ul>\n<p>（2）<strong><em>quality</em></strong>：声音质量，枚举值<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef NS_ENUM(NSInteger, AVSpeechSynthesisVoiceQuality) &#123;</span><br><span class=\"line\">    AVSpeechSynthesisVoiceQualityDefault = 1,\t//默认</span><br><span class=\"line\">    AVSpeechSynthesisVoiceQualityEnhanced\t\t//增强</span><br><span class=\"line\">&#125; NS_ENUM_AVAILABLE(10_14, 9_0);</span><br></pre></td></tr></table></figure></p>\n<p>AVSpeechUtterance相关属性</p>\n<p>（1）<strong><em>rate</em></strong>:指定播放语音时的速率(0.0-1.0),即AVSpeechUtteranceMinimumSpeechRate和AVSpeechUtteranceMaximumSpeechRate之间</p>\n<p>（2）<strong><em>pitchMultiplier</em></strong>：设置声调,属性值介于0.5(低音调)~2.0(高音调)之间</p>\n<p>（3）<strong><em>volume</em></strong>:设置音量(0.0-1.0)</p>\n<p>（4）<strong><em>preUtteranceDelay</em></strong>：postUtteranceDelay告诉synthesizer本句朗读结束后要延迟多少秒再接着朗读下一秒,对应的属性还有<strong><em>preUtteranceDelay</em></strong></p>\n<p>此外,<font color=\"0xff000000\"><strong><em>AVSpeechSynthesizerDelegate</em></strong></font>中还提供了一些监听朗读状态的方法.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>AVFoundation的文本朗诵主要由以下三个类组成：AVSpeechSynthesizer（语音合成器）、AVSpeechUtterance（语音内容）和AVSpeechSynthesisVoice（语音口音）。这三个类的关系如下图：<br><img src=\"//www.cyrus.fun/2018/10/24/AVFoundation学习笔记一-AVSpeechSynthesizer/SpeechSynthesizer.png\" alt=\"\"><br>简单来说就是一个语音合成器（AVSpeechSynthesizer）可以播放一个或多个可以设置口音（AVSpeechSynthesisVoice）、语调、语速的语音内容（AVSpeechUtterance）。</p>\n<p>具体代码步骤：<br>1、初始化一个AVSpeechSynthesizer对象<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_synthesizer = [[AVSpeechSynthesizer alloc] init];</span><br></pre></td></tr></table></figure></p>\n<p>2、创建要朗诵的内容<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_speechStrings = @[@&quot;Hello AV Foundation. How are you?&quot;,</span><br><span class=\"line\">                           @&quot;I&apos;m well! Thanks for asking.&quot;,</span><br><span class=\"line\">                           @&quot;Are you excited about the book?&quot;,</span><br><span class=\"line\">                           @&quot;Very! I have always felt so misunderstood.&quot;,</span><br><span class=\"line\">                           @&quot;What&apos;s your favorite feature?&quot;,</span><br><span class=\"line\">                           @&quot;Oh, they&apos;re all my babies.  I couldn&apos;t possibly choose.&quot;,</span><br><span class=\"line\">                           @&quot;It was great to speak with you!&quot;,</span><br><span class=\"line\">                           @&quot;The pleasure was all mine!  Have fun!&quot;</span><br><span class=\"line\">                           ];</span><br></pre></td></tr></table></figure></p>\n<p>3、为每个字符串创建一个AVSpeechUtterance对象,并传递给self.synthesizer进行播放<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for (NSUInteger i = 0; i &lt; self.speechStrings.count; i++) &#123;</span><br><span class=\"line\">        AVSpeechUtterance *utterance = [[AVSpeechUtterance alloc] initWithString:self.speechStrings[i]];</span><br><span class=\"line\">        utterance.voice = [AVSpeechSynthesisVoice voiceWithLanguage:@&quot;en-US&quot;];</span><br><span class=\"line\">        utterance.rate = 0.4;</span><br><span class=\"line\">        utterance.pitchMultiplier = 0.8f;       //声调，0.5（低音调）-2.0（高音调）</span><br><span class=\"line\">        utterance.postUtteranceDelay = 0.1f;    //播放下一句之前有短时间的暂停</span><br><span class=\"line\">        [self.synthesizer speakUtterance:utterance];</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>相关属性：</p>\n<p>AVSpeechSynthesisVoice相关属性</p>\n<p>（1）language:voice的主要属性，可以根据language创建voice。可以使用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (NSArray&lt;AVSpeechSynthesisVoice *&gt; *)speechVoices;</span><br></pre></td></tr></table></figure></p>\n<p>获取所有支持的language,具体如下：</p>\n<ul>\n<li>Arabic (ar-SA)</li>\n<li>Chinese (zh-CN, zh-HK, zh-TW)</li>\n<li>Czech (cs-CZ)</li>\n<li>Danish (da-DK)</li>\n<li>Dutch (nl-BE, nl-NL)</li>\n<li>English (en-AU, en-GB, en-IE, en-US, en-ZA)</li>\n<li>Finnish (fi-FI)</li>\n<li>French (fr-CA, fr-FR)</li>\n<li>German (de-DE)</li>\n<li>Greek (el-GR)</li>\n<li>Hebrew (he-IL)</li>\n<li>Hindi (hi-IN)</li>\n<li>Hungarian (hu-HU)</li>\n<li>Indonesian (id-ID)</li>\n<li>Italian (it-IT)</li>\n<li>Japanese (ja-JP)</li>\n<li>Korean (ko-KR)</li>\n<li>Norwegian (no-NO)</li>\n<li>Polish (pl-PL)</li>\n<li>Portuguese (pt-BR, pt-PT)</li>\n<li>Romanian (ro-RO)</li>\n<li>Russian (ru-RU)</li>\n<li>Slovak (sk-SK)</li>\n<li>Spanish (es-ES, es-MX)</li>\n<li>Swedish (sv-SE)</li>\n<li>Thai (th-TH)</li>\n<li>Turkish (tr-TR)</li>\n</ul>\n<p>（2）<strong><em>quality</em></strong>：声音质量，枚举值<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef NS_ENUM(NSInteger, AVSpeechSynthesisVoiceQuality) &#123;</span><br><span class=\"line\">    AVSpeechSynthesisVoiceQualityDefault = 1,\t//默认</span><br><span class=\"line\">    AVSpeechSynthesisVoiceQualityEnhanced\t\t//增强</span><br><span class=\"line\">&#125; NS_ENUM_AVAILABLE(10_14, 9_0);</span><br></pre></td></tr></table></figure></p>\n<p>AVSpeechUtterance相关属性</p>\n<p>（1）<strong><em>rate</em></strong>:指定播放语音时的速率(0.0-1.0),即AVSpeechUtteranceMinimumSpeechRate和AVSpeechUtteranceMaximumSpeechRate之间</p>\n<p>（2）<strong><em>pitchMultiplier</em></strong>：设置声调,属性值介于0.5(低音调)~2.0(高音调)之间</p>\n<p>（3）<strong><em>volume</em></strong>:设置音量(0.0-1.0)</p>\n<p>（4）<strong><em>preUtteranceDelay</em></strong>：postUtteranceDelay告诉synthesizer本句朗读结束后要延迟多少秒再接着朗读下一秒,对应的属性还有<strong><em>preUtteranceDelay</em></strong></p>\n<p>此外,<font color=\"0xff000000\"><strong><em>AVSpeechSynthesizerDelegate</em></strong></font>中还提供了一些监听朗读状态的方法.</p>\n"},{"title":"AVFoundation学习笔记一 iOS多媒体环境","author":"Cyrus","date":"2018-10-24T12:14:00.000Z","_content":"![](ios_media.png)\n\n### Core Audio\nCore Audio是OS X和iOS系统上处理所有音频事件的框架。\n* 1、为音频和HIDI内容的录制、播放和处理提供相应接口；\n* 2、高层级AudioQueueServers框架提供的处理基本音频播放和录音相关的功能；\n* 3、低层级Audio Units针对音频信号进行完全控制的功能。\n\n### Core Video\nCore Video是OS X和iOS系统上针对数字视频所提供的管道模式。Core Video为其相对的Core Media<font color=ff0000>提供图片缓存和缓存池支持，提供了一个能够对数字视频逐帧访问的接口</font>。\n\n### Core Media\nCore Media是AVFoundation所用到的低层级媒体管道的一部分。提供针对音频样本和视频帧处理所需的低层级数据类型和接口。Core Media还提供了CMTime数据类型的时基模型。\n\n### Core Animation\nCore Animation是OS X和iOS提供的合成及动画相关框架，封装了OpenGL和OpenGL ES功能的基本Objective-C的各种类。（似乎已经改为<font color=ff0000>Metal</font>作为Core Animation的低层渲染）\n\n### AVFoundation (本系列主要内容)\n处于高层级框架和低层级框架之间，以Objective-C接口方式提供了很多低层级框架才能实现的功能和性能,可以和高层级的框架无缝衔接。\n* 1、文本朗诵 （AVSpeechSynthesizer）\n* 2、音频播放和录制（AVAudioPlayer和AVAudioRecorder）\n* 3、媒体文件元数据（AVMetadataItem）\n* 4、视频播放 （AVPlayer 和 AVPlayerItem）\n* 5、媒体捕捉 （AVCaptureSession）\n* 6、媒体读写 （AVAssetReader和AVAssetWriter）\n* 7、媒体编辑","source":"_posts/AVFoundation学习笔记一-iOS多媒体环境.md","raw":"title: AVFoundation学习笔记一 iOS多媒体环境\nauthor: Cyrus\ntags: []\ncategories:\n  - AVFoundation\ndate: 2018-10-24 20:14:00\n---\n![](ios_media.png)\n\n### Core Audio\nCore Audio是OS X和iOS系统上处理所有音频事件的框架。\n* 1、为音频和HIDI内容的录制、播放和处理提供相应接口；\n* 2、高层级AudioQueueServers框架提供的处理基本音频播放和录音相关的功能；\n* 3、低层级Audio Units针对音频信号进行完全控制的功能。\n\n### Core Video\nCore Video是OS X和iOS系统上针对数字视频所提供的管道模式。Core Video为其相对的Core Media<font color=ff0000>提供图片缓存和缓存池支持，提供了一个能够对数字视频逐帧访问的接口</font>。\n\n### Core Media\nCore Media是AVFoundation所用到的低层级媒体管道的一部分。提供针对音频样本和视频帧处理所需的低层级数据类型和接口。Core Media还提供了CMTime数据类型的时基模型。\n\n### Core Animation\nCore Animation是OS X和iOS提供的合成及动画相关框架，封装了OpenGL和OpenGL ES功能的基本Objective-C的各种类。（似乎已经改为<font color=ff0000>Metal</font>作为Core Animation的低层渲染）\n\n### AVFoundation (本系列主要内容)\n处于高层级框架和低层级框架之间，以Objective-C接口方式提供了很多低层级框架才能实现的功能和性能,可以和高层级的框架无缝衔接。\n* 1、文本朗诵 （AVSpeechSynthesizer）\n* 2、音频播放和录制（AVAudioPlayer和AVAudioRecorder）\n* 3、媒体文件元数据（AVMetadataItem）\n* 4、视频播放 （AVPlayer 和 AVPlayerItem）\n* 5、媒体捕捉 （AVCaptureSession）\n* 6、媒体读写 （AVAssetReader和AVAssetWriter）\n* 7、媒体编辑","slug":"AVFoundation学习笔记一-iOS多媒体环境","published":1,"updated":"2019-07-09T08:13:34.916Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyzlbt7h00030j66nd4uagbr","content":"<p><img src=\"//www.cyrus.fun/2018/10/24/AVFoundation学习笔记一-iOS多媒体环境/ios_media.png\" alt=\"\"></p>\n<h3 id=\"Core-Audio\"><a href=\"#Core-Audio\" class=\"headerlink\" title=\"Core Audio\"></a>Core Audio</h3><p>Core Audio是OS X和iOS系统上处理所有音频事件的框架。</p>\n<ul>\n<li>1、为音频和HIDI内容的录制、播放和处理提供相应接口；</li>\n<li>2、高层级AudioQueueServers框架提供的处理基本音频播放和录音相关的功能；</li>\n<li>3、低层级Audio Units针对音频信号进行完全控制的功能。</li>\n</ul>\n<h3 id=\"Core-Video\"><a href=\"#Core-Video\" class=\"headerlink\" title=\"Core Video\"></a>Core Video</h3><p>Core Video是OS X和iOS系统上针对数字视频所提供的管道模式。Core Video为其相对的Core Media<font color=\"ff0000\">提供图片缓存和缓存池支持，提供了一个能够对数字视频逐帧访问的接口</font>。</p>\n<h3 id=\"Core-Media\"><a href=\"#Core-Media\" class=\"headerlink\" title=\"Core Media\"></a>Core Media</h3><p>Core Media是AVFoundation所用到的低层级媒体管道的一部分。提供针对音频样本和视频帧处理所需的低层级数据类型和接口。Core Media还提供了CMTime数据类型的时基模型。</p>\n<h3 id=\"Core-Animation\"><a href=\"#Core-Animation\" class=\"headerlink\" title=\"Core Animation\"></a>Core Animation</h3><p>Core Animation是OS X和iOS提供的合成及动画相关框架，封装了OpenGL和OpenGL ES功能的基本Objective-C的各种类。（似乎已经改为<font color=\"ff0000\">Metal</font>作为Core Animation的低层渲染）</p>\n<h3 id=\"AVFoundation-本系列主要内容\"><a href=\"#AVFoundation-本系列主要内容\" class=\"headerlink\" title=\"AVFoundation (本系列主要内容)\"></a>AVFoundation (本系列主要内容)</h3><p>处于高层级框架和低层级框架之间，以Objective-C接口方式提供了很多低层级框架才能实现的功能和性能,可以和高层级的框架无缝衔接。</p>\n<ul>\n<li>1、文本朗诵 （AVSpeechSynthesizer）</li>\n<li>2、音频播放和录制（AVAudioPlayer和AVAudioRecorder）</li>\n<li>3、媒体文件元数据（AVMetadataItem）</li>\n<li>4、视频播放 （AVPlayer 和 AVPlayerItem）</li>\n<li>5、媒体捕捉 （AVCaptureSession）</li>\n<li>6、媒体读写 （AVAssetReader和AVAssetWriter）</li>\n<li>7、媒体编辑</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"//www.cyrus.fun/2018/10/24/AVFoundation学习笔记一-iOS多媒体环境/ios_media.png\" alt=\"\"></p>\n<h3 id=\"Core-Audio\"><a href=\"#Core-Audio\" class=\"headerlink\" title=\"Core Audio\"></a>Core Audio</h3><p>Core Audio是OS X和iOS系统上处理所有音频事件的框架。</p>\n<ul>\n<li>1、为音频和HIDI内容的录制、播放和处理提供相应接口；</li>\n<li>2、高层级AudioQueueServers框架提供的处理基本音频播放和录音相关的功能；</li>\n<li>3、低层级Audio Units针对音频信号进行完全控制的功能。</li>\n</ul>\n<h3 id=\"Core-Video\"><a href=\"#Core-Video\" class=\"headerlink\" title=\"Core Video\"></a>Core Video</h3><p>Core Video是OS X和iOS系统上针对数字视频所提供的管道模式。Core Video为其相对的Core Media<font color=\"ff0000\">提供图片缓存和缓存池支持，提供了一个能够对数字视频逐帧访问的接口</font>。</p>\n<h3 id=\"Core-Media\"><a href=\"#Core-Media\" class=\"headerlink\" title=\"Core Media\"></a>Core Media</h3><p>Core Media是AVFoundation所用到的低层级媒体管道的一部分。提供针对音频样本和视频帧处理所需的低层级数据类型和接口。Core Media还提供了CMTime数据类型的时基模型。</p>\n<h3 id=\"Core-Animation\"><a href=\"#Core-Animation\" class=\"headerlink\" title=\"Core Animation\"></a>Core Animation</h3><p>Core Animation是OS X和iOS提供的合成及动画相关框架，封装了OpenGL和OpenGL ES功能的基本Objective-C的各种类。（似乎已经改为<font color=\"ff0000\">Metal</font>作为Core Animation的低层渲染）</p>\n<h3 id=\"AVFoundation-本系列主要内容\"><a href=\"#AVFoundation-本系列主要内容\" class=\"headerlink\" title=\"AVFoundation (本系列主要内容)\"></a>AVFoundation (本系列主要内容)</h3><p>处于高层级框架和低层级框架之间，以Objective-C接口方式提供了很多低层级框架才能实现的功能和性能,可以和高层级的框架无缝衔接。</p>\n<ul>\n<li>1、文本朗诵 （AVSpeechSynthesizer）</li>\n<li>2、音频播放和录制（AVAudioPlayer和AVAudioRecorder）</li>\n<li>3、媒体文件元数据（AVMetadataItem）</li>\n<li>4、视频播放 （AVPlayer 和 AVPlayerItem）</li>\n<li>5、媒体捕捉 （AVCaptureSession）</li>\n<li>6、媒体读写 （AVAssetReader和AVAssetWriter）</li>\n<li>7、媒体编辑</li>\n</ul>\n"},{"title":"AVFoundation学习笔记六 读取相册内容ALAsset和PHAsset","author":"Cyrus","date":"2018-11-05T09:04:00.000Z","_content":"\n### ALAsset (iOS9.0已废弃)\n1、导入头文件\n```\n#import <AssetsLibrary/AssetsLibrary.h>\n```\n\n2、具体流程\n![](ALAsset.png)\n\n3、相关代码\n```\n//1、创建ALAssetsLibrary\n    ALAssetsLibrary *library = [[ALAssetsLibrary alloc] init];\n    //2、根据传入的type，在block中获得ALAssetsGroup，即相应的相册\n    [library enumerateGroupsWithTypes:ALAssetsGroupSavedPhotos usingBlock:^(ALAssetsGroup *group, BOOL *stop) {\n        //3、相册设置筛选类型\n        [group setAssetsFilter:[ALAssetsFilter allVideos]];\n        //4、根据o筛选类型，遍历相册，在block回调中得到相应ALAsset\n        [group enumerateAssetsAtIndexes:[NSIndexSet indexSetWithIndex:0] options:0 usingBlock:^(ALAsset *result, NSUInteger index, BOOL *stop) {\n            //5、对ALAsset进行相关操作\n            if (result) {\n                ALAssetRepresentation *representation = [result defaultRepresentation];\n                NSURL *url = representation.url;\n                NSLog(@\"%@\", url);\n            }\n        }];\n\n    } failureBlock:^(NSError *error) {\n        NSLog(@\"error: %@\", error.localizedDescription);\n    }];\n```\n\n### PHAsset (ALAsset的代替）\n1、导入头文件\n```\n#import <Photos/Photos.h>\n```\n\n2、具体流程\n![](PHAsset.png)\n\n3、相关代码\n```\n/**\n     * 1、PHAssetCollection（类似上面ALAssetsGroup相册的概念,有多个类，根据具体情况选择），调用fetch 开头的函数，得到一个PHFetchResult<PHAssetCollection *> *结果对象（相当于符合筛选的PHAssetCollection相册数组）\n     *   PHFetchResult:类似于C++的模板类，提供统一的collection类、PHAsset类筛选结果的遍历、获取方法\n     */\n    PHFetchResult *results = [PHAssetCollection fetchAssetCollectionsWithType:PHAssetCollectionTypeAlbum subtype:PHAssetCollectionSubtypeAlbumRegular options:0];\n    //2、遍历results,对象为上面调用fetch函数的collection类\n    [results enumerateObjectsUsingBlock:^(PHAssetCollection *obj, NSUInteger idx, BOOL * _Nonnull stop) {\n        //3、PHAsset调用fetch方法，获取相应PHAssetCollection相册内符合要求的PHAsset集合PHFetchResult\n        PHFetchResult *assets = [PHAsset fetchAssetsInAssetCollection:obj options:nil];\n        //4、遍历assets\n        [assets enumerateObjectsUsingBlock:^(PHAsset *obj, NSUInteger idx, BOOL * _Nonnull stop) {\n            //根据asset的mediaType类型，调用相应的PHImageManager request方法（注意不同类型传入的options参数不同）\n            if (obj.mediaType == PHAssetMediaTypeImage) {\n                [[PHImageManager defaultManager] requestImageForAsset:obj targetSize:CGSizeMake(obj.pixelWidth, obj.pixelHeight) contentMode:PHImageContentModeDefault options:[[PHImageRequestOptions alloc] init] resultHandler:^(UIImage * _Nullable result, NSDictionary * _Nullable info) {\n                    NSLog(@\"%@\", [NSThread currentThread]);\n                    UIImageView *imageView = [[UIImageView alloc] initWithFrame:self.view.bounds];\n                    imageView.image = result;\n                    [self.view addSubview:imageView];\n                }];\n            } else if (obj.mediaType == PHAssetMediaTypeVideo) {\n                \n            }\n        }];\n    }];\n```\n\n","source":"_posts/AVFoundation学习笔记七-读取相册内容ALAsset和PHAsset.md","raw":"title: AVFoundation学习笔记六 读取相册内容ALAsset和PHAsset\nauthor: Cyrus\ntags: []\ncategories:\n  - AVFoundation\ndate: 2018-11-05 17:04:00\n---\n\n### ALAsset (iOS9.0已废弃)\n1、导入头文件\n```\n#import <AssetsLibrary/AssetsLibrary.h>\n```\n\n2、具体流程\n![](ALAsset.png)\n\n3、相关代码\n```\n//1、创建ALAssetsLibrary\n    ALAssetsLibrary *library = [[ALAssetsLibrary alloc] init];\n    //2、根据传入的type，在block中获得ALAssetsGroup，即相应的相册\n    [library enumerateGroupsWithTypes:ALAssetsGroupSavedPhotos usingBlock:^(ALAssetsGroup *group, BOOL *stop) {\n        //3、相册设置筛选类型\n        [group setAssetsFilter:[ALAssetsFilter allVideos]];\n        //4、根据o筛选类型，遍历相册，在block回调中得到相应ALAsset\n        [group enumerateAssetsAtIndexes:[NSIndexSet indexSetWithIndex:0] options:0 usingBlock:^(ALAsset *result, NSUInteger index, BOOL *stop) {\n            //5、对ALAsset进行相关操作\n            if (result) {\n                ALAssetRepresentation *representation = [result defaultRepresentation];\n                NSURL *url = representation.url;\n                NSLog(@\"%@\", url);\n            }\n        }];\n\n    } failureBlock:^(NSError *error) {\n        NSLog(@\"error: %@\", error.localizedDescription);\n    }];\n```\n\n### PHAsset (ALAsset的代替）\n1、导入头文件\n```\n#import <Photos/Photos.h>\n```\n\n2、具体流程\n![](PHAsset.png)\n\n3、相关代码\n```\n/**\n     * 1、PHAssetCollection（类似上面ALAssetsGroup相册的概念,有多个类，根据具体情况选择），调用fetch 开头的函数，得到一个PHFetchResult<PHAssetCollection *> *结果对象（相当于符合筛选的PHAssetCollection相册数组）\n     *   PHFetchResult:类似于C++的模板类，提供统一的collection类、PHAsset类筛选结果的遍历、获取方法\n     */\n    PHFetchResult *results = [PHAssetCollection fetchAssetCollectionsWithType:PHAssetCollectionTypeAlbum subtype:PHAssetCollectionSubtypeAlbumRegular options:0];\n    //2、遍历results,对象为上面调用fetch函数的collection类\n    [results enumerateObjectsUsingBlock:^(PHAssetCollection *obj, NSUInteger idx, BOOL * _Nonnull stop) {\n        //3、PHAsset调用fetch方法，获取相应PHAssetCollection相册内符合要求的PHAsset集合PHFetchResult\n        PHFetchResult *assets = [PHAsset fetchAssetsInAssetCollection:obj options:nil];\n        //4、遍历assets\n        [assets enumerateObjectsUsingBlock:^(PHAsset *obj, NSUInteger idx, BOOL * _Nonnull stop) {\n            //根据asset的mediaType类型，调用相应的PHImageManager request方法（注意不同类型传入的options参数不同）\n            if (obj.mediaType == PHAssetMediaTypeImage) {\n                [[PHImageManager defaultManager] requestImageForAsset:obj targetSize:CGSizeMake(obj.pixelWidth, obj.pixelHeight) contentMode:PHImageContentModeDefault options:[[PHImageRequestOptions alloc] init] resultHandler:^(UIImage * _Nullable result, NSDictionary * _Nullable info) {\n                    NSLog(@\"%@\", [NSThread currentThread]);\n                    UIImageView *imageView = [[UIImageView alloc] initWithFrame:self.view.bounds];\n                    imageView.image = result;\n                    [self.view addSubview:imageView];\n                }];\n            } else if (obj.mediaType == PHAssetMediaTypeVideo) {\n                \n            }\n        }];\n    }];\n```\n\n","slug":"AVFoundation学习笔记七-读取相册内容ALAsset和PHAsset","published":1,"updated":"2019-07-09T08:13:34.918Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyzlbt7n00060j66l35sc07l","content":"<h3 id=\"ALAsset-iOS9-0已废弃\"><a href=\"#ALAsset-iOS9-0已废弃\" class=\"headerlink\" title=\"ALAsset (iOS9.0已废弃)\"></a>ALAsset (iOS9.0已废弃)</h3><p>1、导入头文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;AssetsLibrary/AssetsLibrary.h&gt;</span><br></pre></td></tr></table></figure></p>\n<p>2、具体流程<br><img src=\"//www.cyrus.fun/2018/11/05/AVFoundation学习笔记七-读取相册内容ALAsset和PHAsset/ALAsset.png\" alt=\"\"></p>\n<p>3、相关代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//1、创建ALAssetsLibrary</span><br><span class=\"line\">    ALAssetsLibrary *library = [[ALAssetsLibrary alloc] init];</span><br><span class=\"line\">    //2、根据传入的type，在block中获得ALAssetsGroup，即相应的相册</span><br><span class=\"line\">    [library enumerateGroupsWithTypes:ALAssetsGroupSavedPhotos usingBlock:^(ALAssetsGroup *group, BOOL *stop) &#123;</span><br><span class=\"line\">        //3、相册设置筛选类型</span><br><span class=\"line\">        [group setAssetsFilter:[ALAssetsFilter allVideos]];</span><br><span class=\"line\">        //4、根据o筛选类型，遍历相册，在block回调中得到相应ALAsset</span><br><span class=\"line\">        [group enumerateAssetsAtIndexes:[NSIndexSet indexSetWithIndex:0] options:0 usingBlock:^(ALAsset *result, NSUInteger index, BOOL *stop) &#123;</span><br><span class=\"line\">            //5、对ALAsset进行相关操作</span><br><span class=\"line\">            if (result) &#123;</span><br><span class=\"line\">                ALAssetRepresentation *representation = [result defaultRepresentation];</span><br><span class=\"line\">                NSURL *url = representation.url;</span><br><span class=\"line\">                NSLog(@&quot;%@&quot;, url);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125; failureBlock:^(NSError *error) &#123;</span><br><span class=\"line\">        NSLog(@&quot;error: %@&quot;, error.localizedDescription);</span><br><span class=\"line\">    &#125;];</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"PHAsset-ALAsset的代替）\"><a href=\"#PHAsset-ALAsset的代替）\" class=\"headerlink\" title=\"PHAsset (ALAsset的代替）\"></a>PHAsset (ALAsset的代替）</h3><p>1、导入头文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;Photos/Photos.h&gt;</span><br></pre></td></tr></table></figure></p>\n<p>2、具体流程<br><img src=\"//www.cyrus.fun/2018/11/05/AVFoundation学习笔记七-读取相册内容ALAsset和PHAsset/PHAsset.png\" alt=\"\"></p>\n<p>3、相关代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">     * 1、PHAssetCollection（类似上面ALAssetsGroup相册的概念,有多个类，根据具体情况选择），调用fetch 开头的函数，得到一个PHFetchResult&lt;PHAssetCollection *&gt; *结果对象（相当于符合筛选的PHAssetCollection相册数组）</span><br><span class=\"line\">     *   PHFetchResult:类似于C++的模板类，提供统一的collection类、PHAsset类筛选结果的遍历、获取方法</span><br><span class=\"line\">     */</span><br><span class=\"line\">    PHFetchResult *results = [PHAssetCollection fetchAssetCollectionsWithType:PHAssetCollectionTypeAlbum subtype:PHAssetCollectionSubtypeAlbumRegular options:0];</span><br><span class=\"line\">    //2、遍历results,对象为上面调用fetch函数的collection类</span><br><span class=\"line\">    [results enumerateObjectsUsingBlock:^(PHAssetCollection *obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;</span><br><span class=\"line\">        //3、PHAsset调用fetch方法，获取相应PHAssetCollection相册内符合要求的PHAsset集合PHFetchResult</span><br><span class=\"line\">        PHFetchResult *assets = [PHAsset fetchAssetsInAssetCollection:obj options:nil];</span><br><span class=\"line\">        //4、遍历assets</span><br><span class=\"line\">        [assets enumerateObjectsUsingBlock:^(PHAsset *obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;</span><br><span class=\"line\">            //根据asset的mediaType类型，调用相应的PHImageManager request方法（注意不同类型传入的options参数不同）</span><br><span class=\"line\">            if (obj.mediaType == PHAssetMediaTypeImage) &#123;</span><br><span class=\"line\">                [[PHImageManager defaultManager] requestImageForAsset:obj targetSize:CGSizeMake(obj.pixelWidth, obj.pixelHeight) contentMode:PHImageContentModeDefault options:[[PHImageRequestOptions alloc] init] resultHandler:^(UIImage * _Nullable result, NSDictionary * _Nullable info) &#123;</span><br><span class=\"line\">                    NSLog(@&quot;%@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">                    UIImageView *imageView = [[UIImageView alloc] initWithFrame:self.view.bounds];</span><br><span class=\"line\">                    imageView.image = result;</span><br><span class=\"line\">                    [self.view addSubview:imageView];</span><br><span class=\"line\">                &#125;];</span><br><span class=\"line\">            &#125; else if (obj.mediaType == PHAssetMediaTypeVideo) &#123;</span><br><span class=\"line\">                </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;];</span><br><span class=\"line\">    &#125;];</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"ALAsset-iOS9-0已废弃\"><a href=\"#ALAsset-iOS9-0已废弃\" class=\"headerlink\" title=\"ALAsset (iOS9.0已废弃)\"></a>ALAsset (iOS9.0已废弃)</h3><p>1、导入头文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;AssetsLibrary/AssetsLibrary.h&gt;</span><br></pre></td></tr></table></figure></p>\n<p>2、具体流程<br><img src=\"//www.cyrus.fun/2018/11/05/AVFoundation学习笔记七-读取相册内容ALAsset和PHAsset/ALAsset.png\" alt=\"\"></p>\n<p>3、相关代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//1、创建ALAssetsLibrary</span><br><span class=\"line\">    ALAssetsLibrary *library = [[ALAssetsLibrary alloc] init];</span><br><span class=\"line\">    //2、根据传入的type，在block中获得ALAssetsGroup，即相应的相册</span><br><span class=\"line\">    [library enumerateGroupsWithTypes:ALAssetsGroupSavedPhotos usingBlock:^(ALAssetsGroup *group, BOOL *stop) &#123;</span><br><span class=\"line\">        //3、相册设置筛选类型</span><br><span class=\"line\">        [group setAssetsFilter:[ALAssetsFilter allVideos]];</span><br><span class=\"line\">        //4、根据o筛选类型，遍历相册，在block回调中得到相应ALAsset</span><br><span class=\"line\">        [group enumerateAssetsAtIndexes:[NSIndexSet indexSetWithIndex:0] options:0 usingBlock:^(ALAsset *result, NSUInteger index, BOOL *stop) &#123;</span><br><span class=\"line\">            //5、对ALAsset进行相关操作</span><br><span class=\"line\">            if (result) &#123;</span><br><span class=\"line\">                ALAssetRepresentation *representation = [result defaultRepresentation];</span><br><span class=\"line\">                NSURL *url = representation.url;</span><br><span class=\"line\">                NSLog(@&quot;%@&quot;, url);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125; failureBlock:^(NSError *error) &#123;</span><br><span class=\"line\">        NSLog(@&quot;error: %@&quot;, error.localizedDescription);</span><br><span class=\"line\">    &#125;];</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"PHAsset-ALAsset的代替）\"><a href=\"#PHAsset-ALAsset的代替）\" class=\"headerlink\" title=\"PHAsset (ALAsset的代替）\"></a>PHAsset (ALAsset的代替）</h3><p>1、导入头文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;Photos/Photos.h&gt;</span><br></pre></td></tr></table></figure></p>\n<p>2、具体流程<br><img src=\"//www.cyrus.fun/2018/11/05/AVFoundation学习笔记七-读取相册内容ALAsset和PHAsset/PHAsset.png\" alt=\"\"></p>\n<p>3、相关代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">     * 1、PHAssetCollection（类似上面ALAssetsGroup相册的概念,有多个类，根据具体情况选择），调用fetch 开头的函数，得到一个PHFetchResult&lt;PHAssetCollection *&gt; *结果对象（相当于符合筛选的PHAssetCollection相册数组）</span><br><span class=\"line\">     *   PHFetchResult:类似于C++的模板类，提供统一的collection类、PHAsset类筛选结果的遍历、获取方法</span><br><span class=\"line\">     */</span><br><span class=\"line\">    PHFetchResult *results = [PHAssetCollection fetchAssetCollectionsWithType:PHAssetCollectionTypeAlbum subtype:PHAssetCollectionSubtypeAlbumRegular options:0];</span><br><span class=\"line\">    //2、遍历results,对象为上面调用fetch函数的collection类</span><br><span class=\"line\">    [results enumerateObjectsUsingBlock:^(PHAssetCollection *obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;</span><br><span class=\"line\">        //3、PHAsset调用fetch方法，获取相应PHAssetCollection相册内符合要求的PHAsset集合PHFetchResult</span><br><span class=\"line\">        PHFetchResult *assets = [PHAsset fetchAssetsInAssetCollection:obj options:nil];</span><br><span class=\"line\">        //4、遍历assets</span><br><span class=\"line\">        [assets enumerateObjectsUsingBlock:^(PHAsset *obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;</span><br><span class=\"line\">            //根据asset的mediaType类型，调用相应的PHImageManager request方法（注意不同类型传入的options参数不同）</span><br><span class=\"line\">            if (obj.mediaType == PHAssetMediaTypeImage) &#123;</span><br><span class=\"line\">                [[PHImageManager defaultManager] requestImageForAsset:obj targetSize:CGSizeMake(obj.pixelWidth, obj.pixelHeight) contentMode:PHImageContentModeDefault options:[[PHImageRequestOptions alloc] init] resultHandler:^(UIImage * _Nullable result, NSDictionary * _Nullable info) &#123;</span><br><span class=\"line\">                    NSLog(@&quot;%@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">                    UIImageView *imageView = [[UIImageView alloc] initWithFrame:self.view.bounds];</span><br><span class=\"line\">                    imageView.image = result;</span><br><span class=\"line\">                    [self.view addSubview:imageView];</span><br><span class=\"line\">                &#125;];</span><br><span class=\"line\">            &#125; else if (obj.mediaType == PHAssetMediaTypeVideo) &#123;</span><br><span class=\"line\">                </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;];</span><br><span class=\"line\">    &#125;];</span><br></pre></td></tr></table></figure></p>\n"},{"title":"AVFoundation学习笔记七 异步加载属性及媒体元数据","author":"Cyrus","date":"2018-11-08T14:21:00.000Z","_content":"\nAVAsset有多种方法和属性，比如时长、创建日期和元数据等，同时还包含一些用于获取和使用曲目集合的方法。AVAsset使用延迟载入资源的属性（懒加载）,直到请求才载入。这样可以更快地创建AVAsset对象（没有载入相关媒体/元数据的时间）。这样会产生一些问题，那就是首次访问某些属性时，如asset的duration(总时长），如MP3文件没有在头文件中设置TLEN标签（用于记录duration值）,则需要解析整个文件来确定时长。如果发生在主线程，就会阻塞主线程。所以，AVAsset/AVAssetTrack/ AVMetadataItem等类都实现了AVAsynchronousKeyValueLoading协议，以实现异步查询属性的功能。\n\n### AVAsynchronousKeyValueLoading 协议\n```\n//查询给定属性是否会导致程序卡顿，AVKeyValueStatusLoaded:不会卡顿，反之卡顿\n- (AVKeyValueStatus)statusOfValueForKey:(NSString *)key error:(NSError * _Nullable * _Nullable)outError;\n\n//异步加载属性\n- (void)loadValuesAsynchronouslyForKeys:(NSArray<NSString *> *)keys completionHandler:(nullable void (^)(void))handler;\n```\n\n代码示例\n```\nNSURL *assetURL = [[NSBundle mainBundle] URLForResource:@\"xxx\" withExtension:@\"xxx\"];\n    AVAsset *asset = [AVAsset assetWithURL:assetURL];\n    \n    //1、设置要查询的属性（数组）\n    NSArray *keys = @[@\"tracks\"];\n    [asset loadValuesAsynchronouslyForKeys:keys completionHandler:^{\n        //判断相关属性的状态并进行对应处理\n        AVKeyValueStatus status = [asset statusOfValueForKey:@\"tracks\" error:nil];\n        switch (status) {\n            case AVKeyValueStatusLoaded:\n                //continue processing\n                break;\n            case AVKeyValueStatusFailed:\n                //handle failure with error\n                break;\n            case AVKeyValueStatusCancelled:\n                //handle explicit cancellation\n                break;\n            default:\n                //handle all other case\n                break;\n        }\n    }];\n```\n\n注意：loadValuesAsynchronouslyForKeys:completionHandler: 可以一次查询多个属性，但completionHandle只会回调一次，且所查询的属性调用statusOfValueForKey：的返回值不一定相同。","source":"_posts/AVFoundation学习笔记七.md","raw":"title: AVFoundation学习笔记七 异步加载属性及媒体元数据\nauthor: Cyrus\ntags: []\ncategories:\n  - AVFoundation\ndate: 2018-11-08 22:21:00\n---\n\nAVAsset有多种方法和属性，比如时长、创建日期和元数据等，同时还包含一些用于获取和使用曲目集合的方法。AVAsset使用延迟载入资源的属性（懒加载）,直到请求才载入。这样可以更快地创建AVAsset对象（没有载入相关媒体/元数据的时间）。这样会产生一些问题，那就是首次访问某些属性时，如asset的duration(总时长），如MP3文件没有在头文件中设置TLEN标签（用于记录duration值）,则需要解析整个文件来确定时长。如果发生在主线程，就会阻塞主线程。所以，AVAsset/AVAssetTrack/ AVMetadataItem等类都实现了AVAsynchronousKeyValueLoading协议，以实现异步查询属性的功能。\n\n### AVAsynchronousKeyValueLoading 协议\n```\n//查询给定属性是否会导致程序卡顿，AVKeyValueStatusLoaded:不会卡顿，反之卡顿\n- (AVKeyValueStatus)statusOfValueForKey:(NSString *)key error:(NSError * _Nullable * _Nullable)outError;\n\n//异步加载属性\n- (void)loadValuesAsynchronouslyForKeys:(NSArray<NSString *> *)keys completionHandler:(nullable void (^)(void))handler;\n```\n\n代码示例\n```\nNSURL *assetURL = [[NSBundle mainBundle] URLForResource:@\"xxx\" withExtension:@\"xxx\"];\n    AVAsset *asset = [AVAsset assetWithURL:assetURL];\n    \n    //1、设置要查询的属性（数组）\n    NSArray *keys = @[@\"tracks\"];\n    [asset loadValuesAsynchronouslyForKeys:keys completionHandler:^{\n        //判断相关属性的状态并进行对应处理\n        AVKeyValueStatus status = [asset statusOfValueForKey:@\"tracks\" error:nil];\n        switch (status) {\n            case AVKeyValueStatusLoaded:\n                //continue processing\n                break;\n            case AVKeyValueStatusFailed:\n                //handle failure with error\n                break;\n            case AVKeyValueStatusCancelled:\n                //handle explicit cancellation\n                break;\n            default:\n                //handle all other case\n                break;\n        }\n    }];\n```\n\n注意：loadValuesAsynchronouslyForKeys:completionHandler: 可以一次查询多个属性，但completionHandle只会回调一次，且所查询的属性调用statusOfValueForKey：的返回值不一定相同。","slug":"AVFoundation学习笔记七","published":1,"updated":"2019-07-09T08:13:34.919Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyzlbt7q00070j665tcrhmfd","content":"<p>AVAsset有多种方法和属性，比如时长、创建日期和元数据等，同时还包含一些用于获取和使用曲目集合的方法。AVAsset使用延迟载入资源的属性（懒加载）,直到请求才载入。这样可以更快地创建AVAsset对象（没有载入相关媒体/元数据的时间）。这样会产生一些问题，那就是首次访问某些属性时，如asset的duration(总时长），如MP3文件没有在头文件中设置TLEN标签（用于记录duration值）,则需要解析整个文件来确定时长。如果发生在主线程，就会阻塞主线程。所以，AVAsset/AVAssetTrack/ AVMetadataItem等类都实现了AVAsynchronousKeyValueLoading协议，以实现异步查询属性的功能。</p>\n<h3 id=\"AVAsynchronousKeyValueLoading-协议\"><a href=\"#AVAsynchronousKeyValueLoading-协议\" class=\"headerlink\" title=\"AVAsynchronousKeyValueLoading 协议\"></a>AVAsynchronousKeyValueLoading 协议</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//查询给定属性是否会导致程序卡顿，AVKeyValueStatusLoaded:不会卡顿，反之卡顿</span><br><span class=\"line\">- (AVKeyValueStatus)statusOfValueForKey:(NSString *)key error:(NSError * _Nullable * _Nullable)outError;</span><br><span class=\"line\"></span><br><span class=\"line\">//异步加载属性</span><br><span class=\"line\">- (void)loadValuesAsynchronouslyForKeys:(NSArray&lt;NSString *&gt; *)keys completionHandler:(nullable void (^)(void))handler;</span><br></pre></td></tr></table></figure>\n<p>代码示例<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSURL *assetURL = [[NSBundle mainBundle] URLForResource:@&quot;xxx&quot; withExtension:@&quot;xxx&quot;];</span><br><span class=\"line\">    AVAsset *asset = [AVAsset assetWithURL:assetURL];</span><br><span class=\"line\">    </span><br><span class=\"line\">    //1、设置要查询的属性（数组）</span><br><span class=\"line\">    NSArray *keys = @[@&quot;tracks&quot;];</span><br><span class=\"line\">    [asset loadValuesAsynchronouslyForKeys:keys completionHandler:^&#123;</span><br><span class=\"line\">        //判断相关属性的状态并进行对应处理</span><br><span class=\"line\">        AVKeyValueStatus status = [asset statusOfValueForKey:@&quot;tracks&quot; error:nil];</span><br><span class=\"line\">        switch (status) &#123;</span><br><span class=\"line\">            case AVKeyValueStatusLoaded:</span><br><span class=\"line\">                //continue processing</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            case AVKeyValueStatusFailed:</span><br><span class=\"line\">                //handle failure with error</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            case AVKeyValueStatusCancelled:</span><br><span class=\"line\">                //handle explicit cancellation</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            default:</span><br><span class=\"line\">                //handle all other case</span><br><span class=\"line\">                break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;];</span><br></pre></td></tr></table></figure></p>\n<p>注意：loadValuesAsynchronouslyForKeys:completionHandler: 可以一次查询多个属性，但completionHandle只会回调一次，且所查询的属性调用statusOfValueForKey：的返回值不一定相同。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>AVAsset有多种方法和属性，比如时长、创建日期和元数据等，同时还包含一些用于获取和使用曲目集合的方法。AVAsset使用延迟载入资源的属性（懒加载）,直到请求才载入。这样可以更快地创建AVAsset对象（没有载入相关媒体/元数据的时间）。这样会产生一些问题，那就是首次访问某些属性时，如asset的duration(总时长），如MP3文件没有在头文件中设置TLEN标签（用于记录duration值）,则需要解析整个文件来确定时长。如果发生在主线程，就会阻塞主线程。所以，AVAsset/AVAssetTrack/ AVMetadataItem等类都实现了AVAsynchronousKeyValueLoading协议，以实现异步查询属性的功能。</p>\n<h3 id=\"AVAsynchronousKeyValueLoading-协议\"><a href=\"#AVAsynchronousKeyValueLoading-协议\" class=\"headerlink\" title=\"AVAsynchronousKeyValueLoading 协议\"></a>AVAsynchronousKeyValueLoading 协议</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//查询给定属性是否会导致程序卡顿，AVKeyValueStatusLoaded:不会卡顿，反之卡顿</span><br><span class=\"line\">- (AVKeyValueStatus)statusOfValueForKey:(NSString *)key error:(NSError * _Nullable * _Nullable)outError;</span><br><span class=\"line\"></span><br><span class=\"line\">//异步加载属性</span><br><span class=\"line\">- (void)loadValuesAsynchronouslyForKeys:(NSArray&lt;NSString *&gt; *)keys completionHandler:(nullable void (^)(void))handler;</span><br></pre></td></tr></table></figure>\n<p>代码示例<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSURL *assetURL = [[NSBundle mainBundle] URLForResource:@&quot;xxx&quot; withExtension:@&quot;xxx&quot;];</span><br><span class=\"line\">    AVAsset *asset = [AVAsset assetWithURL:assetURL];</span><br><span class=\"line\">    </span><br><span class=\"line\">    //1、设置要查询的属性（数组）</span><br><span class=\"line\">    NSArray *keys = @[@&quot;tracks&quot;];</span><br><span class=\"line\">    [asset loadValuesAsynchronouslyForKeys:keys completionHandler:^&#123;</span><br><span class=\"line\">        //判断相关属性的状态并进行对应处理</span><br><span class=\"line\">        AVKeyValueStatus status = [asset statusOfValueForKey:@&quot;tracks&quot; error:nil];</span><br><span class=\"line\">        switch (status) &#123;</span><br><span class=\"line\">            case AVKeyValueStatusLoaded:</span><br><span class=\"line\">                //continue processing</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            case AVKeyValueStatusFailed:</span><br><span class=\"line\">                //handle failure with error</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            case AVKeyValueStatusCancelled:</span><br><span class=\"line\">                //handle explicit cancellation</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            default:</span><br><span class=\"line\">                //handle all other case</span><br><span class=\"line\">                break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;];</span><br></pre></td></tr></table></figure></p>\n<p>注意：loadValuesAsynchronouslyForKeys:completionHandler: 可以一次查询多个属性，但completionHandle只会回调一次，且所查询的属性调用statusOfValueForKey：的返回值不一定相同。</p>\n"},{"title":"AVFoundation学习笔记四  AVAudioPlayer","author":"Cyrus","date":"2018-11-01T15:10:00.000Z","_content":"![](audioplayer.png)\n\nAVAudioPlayer 比较简单，主要说几个有用的方法和属性。\n#### 属性\n* 1、pan:立体声设置，0:立体声  -1：左声道  1：右声道\n* 2、volume:  音量    0.0 - 1.0\n* 3、rate: 播放速率    0.5 - 2.0      0.5：半速  1.0：正常速度   2.0：倍速\n* 4、currentTime: 音频文件的播放时间\n* 5、deviceCurrentTime: 输出设备播放音频的时间，注意如果播放中被暂停此时间也会继续累加\n* 6、numberOfLoop:  循环播放次数，默认为1， -1为无限循环\n* 7、settting: 文件的基本信息\n```\n{\n    AVAudioFileTypeKey = 1667327590;\t\\\\大端序数据，转主机序后为lpcm\n    AVChannelLayoutKey = <02006500 03000000 00000000>;\n    AVEncoderBitRateKey = 0;\n    AVFormatIDKey = 1819304813;\t\t\\\\大端序数据，转主机序后为caff\n    AVLinearPCMBitDepthKey = 16;\t\\\\采样精度\n    AVLinearPCMIsBigEndianKey = 1;\t\\\\数据是否以大端序保存\n    AVLinearPCMIsFloatKey = 0;\t\t\n    AVLinearPCMIsNonInterleaved = 0;\n    AVNumberOfChannelsKey = 2;\t\t\\\\通道数\n    AVSampleRateKey = 44100;\t\t\\\\采样率\n}\n```\n* 8、duration: 文件总时长\n* 9、numberOfChannels： 该音频的声道数\n* 10、meteringEnabled： 是否允许测量声道平均值和峰值\n\n#### 方法\n* 1、- (BOOL)prepareToPlay;  取得需要的音频硬件并预加载AudioQueue缓冲区.\n* 2、- (BOOL)play;\n* 3、- (BOOL)playAtTime:(NSTimeInterval)time； 播放没有调用prepareToPlay的话会隐式调用\n* 4、- (void)pause;\n* 5、- (void)stop;  停止播放。<font color=ff0000>区别：stop会把prepareToPlay所做的准备释放掉，pause不会，即pause后调用play响应较快。</font>\n* 6、-（void）updateMeters;  meteringEnabled为true时，刷新对应声道强度的峰值和平均值\n* 7、- (float)peakPowerForChannel:(NSUInteger)channelNumber; 对应声道强度的峰值\n* 8、- (float)averagePowerForChannel:(NSUInteger)channelNumber; 对应声道强度的平均值\n\n<font color=ff0000>注：7、8有效的前提条件为 meteringEnabled = YES && 调用了updateMeters。此计数是以对数刻度计量的，-160表示完全安静，0表示最大输入值。</font>可用于动态展示音频强度状态。\n\n","source":"_posts/AVFoundation学习笔记二-AVAudioPlayer.md","raw":"title: AVFoundation学习笔记四  AVAudioPlayer\nauthor: Cyrus\ntags: []\ncategories:\n  - AVFoundation\ndate: 2018-11-01 23:10:00\n---\n![](audioplayer.png)\n\nAVAudioPlayer 比较简单，主要说几个有用的方法和属性。\n#### 属性\n* 1、pan:立体声设置，0:立体声  -1：左声道  1：右声道\n* 2、volume:  音量    0.0 - 1.0\n* 3、rate: 播放速率    0.5 - 2.0      0.5：半速  1.0：正常速度   2.0：倍速\n* 4、currentTime: 音频文件的播放时间\n* 5、deviceCurrentTime: 输出设备播放音频的时间，注意如果播放中被暂停此时间也会继续累加\n* 6、numberOfLoop:  循环播放次数，默认为1， -1为无限循环\n* 7、settting: 文件的基本信息\n```\n{\n    AVAudioFileTypeKey = 1667327590;\t\\\\大端序数据，转主机序后为lpcm\n    AVChannelLayoutKey = <02006500 03000000 00000000>;\n    AVEncoderBitRateKey = 0;\n    AVFormatIDKey = 1819304813;\t\t\\\\大端序数据，转主机序后为caff\n    AVLinearPCMBitDepthKey = 16;\t\\\\采样精度\n    AVLinearPCMIsBigEndianKey = 1;\t\\\\数据是否以大端序保存\n    AVLinearPCMIsFloatKey = 0;\t\t\n    AVLinearPCMIsNonInterleaved = 0;\n    AVNumberOfChannelsKey = 2;\t\t\\\\通道数\n    AVSampleRateKey = 44100;\t\t\\\\采样率\n}\n```\n* 8、duration: 文件总时长\n* 9、numberOfChannels： 该音频的声道数\n* 10、meteringEnabled： 是否允许测量声道平均值和峰值\n\n#### 方法\n* 1、- (BOOL)prepareToPlay;  取得需要的音频硬件并预加载AudioQueue缓冲区.\n* 2、- (BOOL)play;\n* 3、- (BOOL)playAtTime:(NSTimeInterval)time； 播放没有调用prepareToPlay的话会隐式调用\n* 4、- (void)pause;\n* 5、- (void)stop;  停止播放。<font color=ff0000>区别：stop会把prepareToPlay所做的准备释放掉，pause不会，即pause后调用play响应较快。</font>\n* 6、-（void）updateMeters;  meteringEnabled为true时，刷新对应声道强度的峰值和平均值\n* 7、- (float)peakPowerForChannel:(NSUInteger)channelNumber; 对应声道强度的峰值\n* 8、- (float)averagePowerForChannel:(NSUInteger)channelNumber; 对应声道强度的平均值\n\n<font color=ff0000>注：7、8有效的前提条件为 meteringEnabled = YES && 调用了updateMeters。此计数是以对数刻度计量的，-160表示完全安静，0表示最大输入值。</font>可用于动态展示音频强度状态。\n\n","slug":"AVFoundation学习笔记二-AVAudioPlayer","published":1,"updated":"2019-07-09T08:13:34.921Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyzlbt7x00080j66q3dd230k","content":"<p><img src=\"//www.cyrus.fun/2018/11/01/AVFoundation学习笔记二-AVAudioPlayer/audioplayer.png\" alt=\"\"></p>\n<p>AVAudioPlayer 比较简单，主要说几个有用的方法和属性。</p>\n<h4 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h4><ul>\n<li>1、pan:立体声设置，0:立体声  -1：左声道  1：右声道</li>\n<li>2、volume:  音量    0.0 - 1.0</li>\n<li>3、rate: 播放速率    0.5 - 2.0      0.5：半速  1.0：正常速度   2.0：倍速</li>\n<li>4、currentTime: 音频文件的播放时间</li>\n<li>5、deviceCurrentTime: 输出设备播放音频的时间，注意如果播放中被暂停此时间也会继续累加</li>\n<li>6、numberOfLoop:  循环播放次数，默认为1， -1为无限循环</li>\n<li><p>7、settting: 文件的基本信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    AVAudioFileTypeKey = 1667327590;\t\\\\大端序数据，转主机序后为lpcm</span><br><span class=\"line\">    AVChannelLayoutKey = &lt;02006500 03000000 00000000&gt;;</span><br><span class=\"line\">    AVEncoderBitRateKey = 0;</span><br><span class=\"line\">    AVFormatIDKey = 1819304813;\t\t\\\\大端序数据，转主机序后为caff</span><br><span class=\"line\">    AVLinearPCMBitDepthKey = 16;\t\\\\采样精度</span><br><span class=\"line\">    AVLinearPCMIsBigEndianKey = 1;\t\\\\数据是否以大端序保存</span><br><span class=\"line\">    AVLinearPCMIsFloatKey = 0;\t\t</span><br><span class=\"line\">    AVLinearPCMIsNonInterleaved = 0;</span><br><span class=\"line\">    AVNumberOfChannelsKey = 2;\t\t\\\\通道数</span><br><span class=\"line\">    AVSampleRateKey = 44100;\t\t\\\\采样率</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>8、duration: 文件总时长</p>\n</li>\n<li>9、numberOfChannels： 该音频的声道数</li>\n<li>10、meteringEnabled： 是否允许测量声道平均值和峰值</li>\n</ul>\n<h4 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h4><ul>\n<li>1、- (BOOL)prepareToPlay;  取得需要的音频硬件并预加载AudioQueue缓冲区.</li>\n<li>2、- (BOOL)play;</li>\n<li>3、- (BOOL)playAtTime:(NSTimeInterval)time； 播放没有调用prepareToPlay的话会隐式调用</li>\n<li>4、- (void)pause;</li>\n<li>5、- (void)stop;  停止播放。<font color=\"ff0000\">区别：stop会把prepareToPlay所做的准备释放掉，pause不会，即pause后调用play响应较快。</font></li>\n<li>6、-（void）updateMeters;  meteringEnabled为true时，刷新对应声道强度的峰值和平均值</li>\n<li>7、- (float)peakPowerForChannel:(NSUInteger)channelNumber; 对应声道强度的峰值</li>\n<li>8、- (float)averagePowerForChannel:(NSUInteger)channelNumber; 对应声道强度的平均值</li>\n</ul>\n<p><font color=\"ff0000\">注：7、8有效的前提条件为 meteringEnabled = YES &amp;&amp; 调用了updateMeters。此计数是以对数刻度计量的，-160表示完全安静，0表示最大输入值。</font>可用于动态展示音频强度状态。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"//www.cyrus.fun/2018/11/01/AVFoundation学习笔记二-AVAudioPlayer/audioplayer.png\" alt=\"\"></p>\n<p>AVAudioPlayer 比较简单，主要说几个有用的方法和属性。</p>\n<h4 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h4><ul>\n<li>1、pan:立体声设置，0:立体声  -1：左声道  1：右声道</li>\n<li>2、volume:  音量    0.0 - 1.0</li>\n<li>3、rate: 播放速率    0.5 - 2.0      0.5：半速  1.0：正常速度   2.0：倍速</li>\n<li>4、currentTime: 音频文件的播放时间</li>\n<li>5、deviceCurrentTime: 输出设备播放音频的时间，注意如果播放中被暂停此时间也会继续累加</li>\n<li>6、numberOfLoop:  循环播放次数，默认为1， -1为无限循环</li>\n<li><p>7、settting: 文件的基本信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    AVAudioFileTypeKey = 1667327590;\t\\\\大端序数据，转主机序后为lpcm</span><br><span class=\"line\">    AVChannelLayoutKey = &lt;02006500 03000000 00000000&gt;;</span><br><span class=\"line\">    AVEncoderBitRateKey = 0;</span><br><span class=\"line\">    AVFormatIDKey = 1819304813;\t\t\\\\大端序数据，转主机序后为caff</span><br><span class=\"line\">    AVLinearPCMBitDepthKey = 16;\t\\\\采样精度</span><br><span class=\"line\">    AVLinearPCMIsBigEndianKey = 1;\t\\\\数据是否以大端序保存</span><br><span class=\"line\">    AVLinearPCMIsFloatKey = 0;\t\t</span><br><span class=\"line\">    AVLinearPCMIsNonInterleaved = 0;</span><br><span class=\"line\">    AVNumberOfChannelsKey = 2;\t\t\\\\通道数</span><br><span class=\"line\">    AVSampleRateKey = 44100;\t\t\\\\采样率</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>8、duration: 文件总时长</p>\n</li>\n<li>9、numberOfChannels： 该音频的声道数</li>\n<li>10、meteringEnabled： 是否允许测量声道平均值和峰值</li>\n</ul>\n<h4 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h4><ul>\n<li>1、- (BOOL)prepareToPlay;  取得需要的音频硬件并预加载AudioQueue缓冲区.</li>\n<li>2、- (BOOL)play;</li>\n<li>3、- (BOOL)playAtTime:(NSTimeInterval)time； 播放没有调用prepareToPlay的话会隐式调用</li>\n<li>4、- (void)pause;</li>\n<li>5、- (void)stop;  停止播放。<font color=\"ff0000\">区别：stop会把prepareToPlay所做的准备释放掉，pause不会，即pause后调用play响应较快。</font></li>\n<li>6、-（void）updateMeters;  meteringEnabled为true时，刷新对应声道强度的峰值和平均值</li>\n<li>7、- (float)peakPowerForChannel:(NSUInteger)channelNumber; 对应声道强度的峰值</li>\n<li>8、- (float)averagePowerForChannel:(NSUInteger)channelNumber; 对应声道强度的平均值</li>\n</ul>\n<p><font color=\"ff0000\">注：7、8有效的前提条件为 meteringEnabled = YES &amp;&amp; 调用了updateMeters。此计数是以对数刻度计量的，-160表示完全安静，0表示最大输入值。</font>可用于动态展示音频强度状态。</p>\n"},{"title":"AVFoundation学习笔记五 AVAudioRecorder","author":"Cyrus","date":"2018-11-02T07:28:00.000Z","_content":"![](recorder.png)\n比较简单的类，主要说一下几个注意的地方：\n### 一、配置AVAudioSession\n```\nAVAudioSession *session = [AVAudioSession sharedInstance];\n    NSError *error;\n    if (![session setCategory:AVAudioSessionCategoryPlayAndRecord error:&error]) {\n        NSLog(@\"Category Error: %@\", [error localizedDescription]);\n    }\n    if (![session setActive:YES error:&error]) {\n        NSLog(@\"Activation Error: %@\", [error localizedDescription]);\n    }\n```\n\n### 二、settings参数\n创建AVAudioRecorder的方法中，settings是最重要的参数，有着众多的配置参数：\n```\n- (nullable instancetype)initWithURL:(NSURL *)url settings:(NSDictionary<NSString *, id> *)settings error:(NSError **)outError;\n```\nsettings中的key可以在***AVFoundation->framework文件夹->AVAudio->AVAudioSettings.h***中找到。\n\nsettings常见的key值：\n* **AVFormatIDKey**：定义了写入内容的音频格式，值类型存在于 AudioFormatID枚举中，由相应四字节字符组成的32位整形，如：\n![](audio_format.png)\n<font color=ff0000>注意</font>：指定的类型必须与URL定义的文件名对应，比如录制一个test.wav，隐含的意思是录制的音频必须满足Waveform Audio File Format(WAVE)的格式要求，即低字节序（AVLinearPCMIsBigEndianKey 值为NO）、LinerPCM。如果AudioFormatID的值不是 kAudioFormatLinearPCM。NSError的错误信息为：\nThe  operation couldn’t be completed.(OSStatus error 118449215).\n118449215 = ‘fmt?’,即不兼容格式\n* **AVSampleRateKey**:采样率，对输入的模拟音频信号每一秒内的采样数，如8kHz,AM广播的录制效果，不件较小。44.1kHz，CD质量的采样率，文件比较大。尽量使用标准采样率，如8000、16000、22050和44100。\n* **AVNumberOfChannelsKey**:通道数，1：单声道  2：立体声\n* **AVLinearPCMBitDepthKey**:采样精度/位深， 8位或16位，用于lpcm\n* **AVLinearPCMIsBigEndianKey**:是否大端保存数据，用于lpcm\n* **AVLinearPCMIsFloatKey**:采样数据是否为浮点型\n* **AVEncoderBitDepthHintKey**:编码位深，8-32，非lpcm使用\n* **AVEncoderAudioQualityKey**:编码质量，非lpcm使用\n```\ntypedef NS_ENUM(NSInteger, AVAudioQuality) {\n \tAVAudioQualityMin    = 0,\n \tAVAudioQualityLow    = 0x20,\n \tAVAudioQualityMedium = 0x40,\n \tAVAudioQualityHigh   = 0x60,\n \tAVAudioQualityMax    = 0x7F\n};\n```","source":"_posts/AVFoundation学习笔记五-AVAudioRecorder.md","raw":"title: AVFoundation学习笔记五 AVAudioRecorder\nauthor: Cyrus\ntags: []\ncategories:\n  - AVFoundation\ndate: 2018-11-02 15:28:00\n---\n![](recorder.png)\n比较简单的类，主要说一下几个注意的地方：\n### 一、配置AVAudioSession\n```\nAVAudioSession *session = [AVAudioSession sharedInstance];\n    NSError *error;\n    if (![session setCategory:AVAudioSessionCategoryPlayAndRecord error:&error]) {\n        NSLog(@\"Category Error: %@\", [error localizedDescription]);\n    }\n    if (![session setActive:YES error:&error]) {\n        NSLog(@\"Activation Error: %@\", [error localizedDescription]);\n    }\n```\n\n### 二、settings参数\n创建AVAudioRecorder的方法中，settings是最重要的参数，有着众多的配置参数：\n```\n- (nullable instancetype)initWithURL:(NSURL *)url settings:(NSDictionary<NSString *, id> *)settings error:(NSError **)outError;\n```\nsettings中的key可以在***AVFoundation->framework文件夹->AVAudio->AVAudioSettings.h***中找到。\n\nsettings常见的key值：\n* **AVFormatIDKey**：定义了写入内容的音频格式，值类型存在于 AudioFormatID枚举中，由相应四字节字符组成的32位整形，如：\n![](audio_format.png)\n<font color=ff0000>注意</font>：指定的类型必须与URL定义的文件名对应，比如录制一个test.wav，隐含的意思是录制的音频必须满足Waveform Audio File Format(WAVE)的格式要求，即低字节序（AVLinearPCMIsBigEndianKey 值为NO）、LinerPCM。如果AudioFormatID的值不是 kAudioFormatLinearPCM。NSError的错误信息为：\nThe  operation couldn’t be completed.(OSStatus error 118449215).\n118449215 = ‘fmt?’,即不兼容格式\n* **AVSampleRateKey**:采样率，对输入的模拟音频信号每一秒内的采样数，如8kHz,AM广播的录制效果，不件较小。44.1kHz，CD质量的采样率，文件比较大。尽量使用标准采样率，如8000、16000、22050和44100。\n* **AVNumberOfChannelsKey**:通道数，1：单声道  2：立体声\n* **AVLinearPCMBitDepthKey**:采样精度/位深， 8位或16位，用于lpcm\n* **AVLinearPCMIsBigEndianKey**:是否大端保存数据，用于lpcm\n* **AVLinearPCMIsFloatKey**:采样数据是否为浮点型\n* **AVEncoderBitDepthHintKey**:编码位深，8-32，非lpcm使用\n* **AVEncoderAudioQualityKey**:编码质量，非lpcm使用\n```\ntypedef NS_ENUM(NSInteger, AVAudioQuality) {\n \tAVAudioQualityMin    = 0,\n \tAVAudioQualityLow    = 0x20,\n \tAVAudioQualityMedium = 0x40,\n \tAVAudioQualityHigh   = 0x60,\n \tAVAudioQualityMax    = 0x7F\n};\n```","slug":"AVFoundation学习笔记五-AVAudioRecorder","published":1,"updated":"2019-07-09T08:13:34.923Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyzlbt83000b0j665s4m0o77","content":"<p><img src=\"//www.cyrus.fun/2018/11/02/AVFoundation学习笔记五-AVAudioRecorder/recorder.png\" alt=\"\"><br>比较简单的类，主要说一下几个注意的地方：</p>\n<h3 id=\"一、配置AVAudioSession\"><a href=\"#一、配置AVAudioSession\" class=\"headerlink\" title=\"一、配置AVAudioSession\"></a>一、配置AVAudioSession</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AVAudioSession *session = [AVAudioSession sharedInstance];</span><br><span class=\"line\">    NSError *error;</span><br><span class=\"line\">    if (![session setCategory:AVAudioSessionCategoryPlayAndRecord error:&amp;error]) &#123;</span><br><span class=\"line\">        NSLog(@&quot;Category Error: %@&quot;, [error localizedDescription]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (![session setActive:YES error:&amp;error]) &#123;</span><br><span class=\"line\">        NSLog(@&quot;Activation Error: %@&quot;, [error localizedDescription]);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"二、settings参数\"><a href=\"#二、settings参数\" class=\"headerlink\" title=\"二、settings参数\"></a>二、settings参数</h3><p>创建AVAudioRecorder的方法中，settings是最重要的参数，有着众多的配置参数：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (nullable instancetype)initWithURL:(NSURL *)url settings:(NSDictionary&lt;NSString *, id&gt; *)settings error:(NSError **)outError;</span><br></pre></td></tr></table></figure></p>\n<p>settings中的key可以在<strong><em>AVFoundation-&gt;framework文件夹-&gt;AVAudio-&gt;AVAudioSettings.h</em></strong>中找到。</p>\n<p>settings常见的key值：</p>\n<ul>\n<li><strong>AVFormatIDKey</strong>：定义了写入内容的音频格式，值类型存在于 AudioFormatID枚举中，由相应四字节字符组成的32位整形，如：<br><img src=\"//www.cyrus.fun/2018/11/02/AVFoundation学习笔记五-AVAudioRecorder/audio_format.png\" alt=\"\"><br><font color=\"ff0000\">注意</font>：指定的类型必须与URL定义的文件名对应，比如录制一个test.wav，隐含的意思是录制的音频必须满足Waveform Audio File Format(WAVE)的格式要求，即低字节序（AVLinearPCMIsBigEndianKey 值为NO）、LinerPCM。如果AudioFormatID的值不是 kAudioFormatLinearPCM。NSError的错误信息为：<br>The  operation couldn’t be completed.(OSStatus error 118449215).<br>118449215 = ‘fmt?’,即不兼容格式</li>\n<li><strong>AVSampleRateKey</strong>:采样率，对输入的模拟音频信号每一秒内的采样数，如8kHz,AM广播的录制效果，不件较小。44.1kHz，CD质量的采样率，文件比较大。尽量使用标准采样率，如8000、16000、22050和44100。</li>\n<li><strong>AVNumberOfChannelsKey</strong>:通道数，1：单声道  2：立体声</li>\n<li><strong>AVLinearPCMBitDepthKey</strong>:采样精度/位深， 8位或16位，用于lpcm</li>\n<li><strong>AVLinearPCMIsBigEndianKey</strong>:是否大端保存数据，用于lpcm</li>\n<li><strong>AVLinearPCMIsFloatKey</strong>:采样数据是否为浮点型</li>\n<li><strong>AVEncoderBitDepthHintKey</strong>:编码位深，8-32，非lpcm使用</li>\n<li><strong>AVEncoderAudioQualityKey</strong>:编码质量，非lpcm使用<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef NS_ENUM(NSInteger, AVAudioQuality) &#123;</span><br><span class=\"line\"> \tAVAudioQualityMin    = 0,</span><br><span class=\"line\"> \tAVAudioQualityLow    = 0x20,</span><br><span class=\"line\"> \tAVAudioQualityMedium = 0x40,</span><br><span class=\"line\"> \tAVAudioQualityHigh   = 0x60,</span><br><span class=\"line\"> \tAVAudioQualityMax    = 0x7F</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"//www.cyrus.fun/2018/11/02/AVFoundation学习笔记五-AVAudioRecorder/recorder.png\" alt=\"\"><br>比较简单的类，主要说一下几个注意的地方：</p>\n<h3 id=\"一、配置AVAudioSession\"><a href=\"#一、配置AVAudioSession\" class=\"headerlink\" title=\"一、配置AVAudioSession\"></a>一、配置AVAudioSession</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AVAudioSession *session = [AVAudioSession sharedInstance];</span><br><span class=\"line\">    NSError *error;</span><br><span class=\"line\">    if (![session setCategory:AVAudioSessionCategoryPlayAndRecord error:&amp;error]) &#123;</span><br><span class=\"line\">        NSLog(@&quot;Category Error: %@&quot;, [error localizedDescription]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (![session setActive:YES error:&amp;error]) &#123;</span><br><span class=\"line\">        NSLog(@&quot;Activation Error: %@&quot;, [error localizedDescription]);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"二、settings参数\"><a href=\"#二、settings参数\" class=\"headerlink\" title=\"二、settings参数\"></a>二、settings参数</h3><p>创建AVAudioRecorder的方法中，settings是最重要的参数，有着众多的配置参数：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (nullable instancetype)initWithURL:(NSURL *)url settings:(NSDictionary&lt;NSString *, id&gt; *)settings error:(NSError **)outError;</span><br></pre></td></tr></table></figure></p>\n<p>settings中的key可以在<strong><em>AVFoundation-&gt;framework文件夹-&gt;AVAudio-&gt;AVAudioSettings.h</em></strong>中找到。</p>\n<p>settings常见的key值：</p>\n<ul>\n<li><strong>AVFormatIDKey</strong>：定义了写入内容的音频格式，值类型存在于 AudioFormatID枚举中，由相应四字节字符组成的32位整形，如：<br><img src=\"//www.cyrus.fun/2018/11/02/AVFoundation学习笔记五-AVAudioRecorder/audio_format.png\" alt=\"\"><br><font color=\"ff0000\">注意</font>：指定的类型必须与URL定义的文件名对应，比如录制一个test.wav，隐含的意思是录制的音频必须满足Waveform Audio File Format(WAVE)的格式要求，即低字节序（AVLinearPCMIsBigEndianKey 值为NO）、LinerPCM。如果AudioFormatID的值不是 kAudioFormatLinearPCM。NSError的错误信息为：<br>The  operation couldn’t be completed.(OSStatus error 118449215).<br>118449215 = ‘fmt?’,即不兼容格式</li>\n<li><strong>AVSampleRateKey</strong>:采样率，对输入的模拟音频信号每一秒内的采样数，如8kHz,AM广播的录制效果，不件较小。44.1kHz，CD质量的采样率，文件比较大。尽量使用标准采样率，如8000、16000、22050和44100。</li>\n<li><strong>AVNumberOfChannelsKey</strong>:通道数，1：单声道  2：立体声</li>\n<li><strong>AVLinearPCMBitDepthKey</strong>:采样精度/位深， 8位或16位，用于lpcm</li>\n<li><strong>AVLinearPCMIsBigEndianKey</strong>:是否大端保存数据，用于lpcm</li>\n<li><strong>AVLinearPCMIsFloatKey</strong>:采样数据是否为浮点型</li>\n<li><strong>AVEncoderBitDepthHintKey</strong>:编码位深，8-32，非lpcm使用</li>\n<li><strong>AVEncoderAudioQualityKey</strong>:编码质量，非lpcm使用<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef NS_ENUM(NSInteger, AVAudioQuality) &#123;</span><br><span class=\"line\"> \tAVAudioQualityMin    = 0,</span><br><span class=\"line\"> \tAVAudioQualityLow    = 0x20,</span><br><span class=\"line\"> \tAVAudioQualityMedium = 0x40,</span><br><span class=\"line\"> \tAVAudioQualityHigh   = 0x60,</span><br><span class=\"line\"> \tAVAudioQualityMax    = 0x7F</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\n</ul>\n"},{"title":"AVFoundation学习笔记十 AVCaptureSession2","author":"Cyrus","date":"2018-11-12T14:22:00.000Z","_content":"\n视频缩放\n```\n- (BOOL)cameraSupportsZoom {\n \treturn self.activeCamera.activeFormat.videoMaxZoomFactor > 1.0f;        // 1\n}\n- (CGFloat)maxZoomFactor {\n \treturn MIN(self.activeCamera.activeFormat.videoMaxZoomFactor, 4.0f);    // 2\n}\n- (void)setZoomValue:(CGFloat)zoomValue {                                   // 3\n \tif (!self.activeCamera.isRampingVideoZoom) {\n        NSError *error;\n        if ([self.activeCamera lockForConfiguration:&error]) {              // 4\n            // Provide linear feel to zoom slider\n \t\t\tCGFloat zoomFactor = pow([self maxZoomFactor], zoomValue);      // 5\n            self.activeCamera.videoZoomFactor = zoomFactor;\n            [self.activeCamera unlockForConfiguration];                     // 6\n \t\t} else {\n            [self.delegate deviceConfigurationFailedWithError:error];\n        }\n \t}\n}\n- (void)rampZoomToValue:(CGFloat)zoomValue {                                // 1\n    CGFloat zoomFactor = pow([self maxZoomFactor], zoomValue);\n \tNSError *error;\n \tif ([self.activeCamera lockForConfiguration:&error]) {\n \t\t[self.activeCamera rampToVideoZoomFactor:zoomFactor                 // 2\n                                        withRate:THZoomRate];\n \t\t[self.activeCamera unlockForConfiguration];\n \t} else {\n \t\t[self.delegate deviceConfigurationFailedWithError:error];\n \t}\n}\n```\n\n人脸检测\n```\n- (BOOL)setupSessionOutputs:(NSError **)error {\n//设置输出数据类型\n    self.metadataOutput = [[AVCaptureMetadataOutput alloc] init];           // 2\n    if ([self.captureSession canAddOutput:self.metadataOutput]) {\n        [self.captureSession addOutput:self.metadataOutput];\n//设置人脸检测\n        NSArray *metadataObjectTypes = @[AVMetadataObjectTypeFace];         // 3\n        self.metadataOutput.metadataObjectTypes = metadataObjectTypes;\n        dispatch_queue_t mainQueue = dispatch_get_main_queue();\n        [self.metadataOutput setMetadataObjectsDelegate:self                // 4\n                                                  queue:mainQueue];\n        return YES;\n    } else {                                                                // 5\n        if (error) {\n            NSDictionary *userInfo = @{NSLocalizedDescriptionKey:\n                                           @\"Failed to still image output.\"};\n            *error = [NSError errorWithDomain:THCameraErrorDomain\n                                         code:THCameraErrorFailedToAddOutput\n                                     userInfo:userInfo];\n        }\n        return NO;\n    }\n}\n//人脸检测回调\n- (void)captureOutput:(AVCaptureOutput *)captureOutput\ndidOutputMetadataObjects:(NSArray *)metadataObjects\n       fromConnection:(AVCaptureConnection *)connection {\n    for (AVMetadataFaceObject *face in metadataObjects) {                   // 2\n        NSLog(@\"Face detected with ID: %li\", (long)face.faceID);\n        NSLog(@\"Face bounds: %@\", NSStringFromCGRect(face.bounds));\n    }\n    [self.faceDetectionDelegate didDetectFaces:metadataObjects];            // 3\n    \n}\n```\n\n条形码检测\n```\n- (BOOL)setupSessionOutputs:(NSError **)error {\n    self.metadataOutput = [[AVCaptureMetadataOutput alloc] init];\n    if ([self.captureSession canAddOutput:self.metadataOutput]) {\n        [self.captureSession addOutput:self.metadataOutput];\n        dispatch_queue_t mainQueue = dispatch_get_main_queue();\n        [self.metadataOutput setMetadataObjectsDelegate:self\n                                                  queue:mainQueue];\n        NSArray *types = @[AVMetadataObjectTypeQRCode,                      // 1\n                           AVMetadataObjectTypeAztecCode,\n                           AVMetadataObjectTypeUPCECode];\n        self.metadataOutput.metadataObjectTypes = types;\n    } else {\n        NSDictionary *userInfo = @{NSLocalizedDescriptionKey:\n                                       @\"Failed to still image output.\"};\n        *error = [NSError errorWithDomain:THCameraErrorDomain\n                                     code:THCameraErrorFailedToAddOutput\n                                 userInfo:userInfo];\n        return NO;\n    }\n    return YES;\n}\n- (void)captureOutput:(AVCaptureOutput *)captureOutput\ndidOutputMetadataObjects:(NSArray *)metadataObjects\n       fromConnection:(AVCaptureConnection *)connection {\n    [self.codeDetectionDelegate didDetectCodes:metadataObjects];            // 2\n}\n```","source":"_posts/AVFoundation学习笔记十.md","raw":"title: AVFoundation学习笔记十 AVCaptureSession2\nauthor: Cyrus\ntags: []\ncategories:\n  - AVFoundation\ndate: 2018-11-12 22:22:00\n---\n\n视频缩放\n```\n- (BOOL)cameraSupportsZoom {\n \treturn self.activeCamera.activeFormat.videoMaxZoomFactor > 1.0f;        // 1\n}\n- (CGFloat)maxZoomFactor {\n \treturn MIN(self.activeCamera.activeFormat.videoMaxZoomFactor, 4.0f);    // 2\n}\n- (void)setZoomValue:(CGFloat)zoomValue {                                   // 3\n \tif (!self.activeCamera.isRampingVideoZoom) {\n        NSError *error;\n        if ([self.activeCamera lockForConfiguration:&error]) {              // 4\n            // Provide linear feel to zoom slider\n \t\t\tCGFloat zoomFactor = pow([self maxZoomFactor], zoomValue);      // 5\n            self.activeCamera.videoZoomFactor = zoomFactor;\n            [self.activeCamera unlockForConfiguration];                     // 6\n \t\t} else {\n            [self.delegate deviceConfigurationFailedWithError:error];\n        }\n \t}\n}\n- (void)rampZoomToValue:(CGFloat)zoomValue {                                // 1\n    CGFloat zoomFactor = pow([self maxZoomFactor], zoomValue);\n \tNSError *error;\n \tif ([self.activeCamera lockForConfiguration:&error]) {\n \t\t[self.activeCamera rampToVideoZoomFactor:zoomFactor                 // 2\n                                        withRate:THZoomRate];\n \t\t[self.activeCamera unlockForConfiguration];\n \t} else {\n \t\t[self.delegate deviceConfigurationFailedWithError:error];\n \t}\n}\n```\n\n人脸检测\n```\n- (BOOL)setupSessionOutputs:(NSError **)error {\n//设置输出数据类型\n    self.metadataOutput = [[AVCaptureMetadataOutput alloc] init];           // 2\n    if ([self.captureSession canAddOutput:self.metadataOutput]) {\n        [self.captureSession addOutput:self.metadataOutput];\n//设置人脸检测\n        NSArray *metadataObjectTypes = @[AVMetadataObjectTypeFace];         // 3\n        self.metadataOutput.metadataObjectTypes = metadataObjectTypes;\n        dispatch_queue_t mainQueue = dispatch_get_main_queue();\n        [self.metadataOutput setMetadataObjectsDelegate:self                // 4\n                                                  queue:mainQueue];\n        return YES;\n    } else {                                                                // 5\n        if (error) {\n            NSDictionary *userInfo = @{NSLocalizedDescriptionKey:\n                                           @\"Failed to still image output.\"};\n            *error = [NSError errorWithDomain:THCameraErrorDomain\n                                         code:THCameraErrorFailedToAddOutput\n                                     userInfo:userInfo];\n        }\n        return NO;\n    }\n}\n//人脸检测回调\n- (void)captureOutput:(AVCaptureOutput *)captureOutput\ndidOutputMetadataObjects:(NSArray *)metadataObjects\n       fromConnection:(AVCaptureConnection *)connection {\n    for (AVMetadataFaceObject *face in metadataObjects) {                   // 2\n        NSLog(@\"Face detected with ID: %li\", (long)face.faceID);\n        NSLog(@\"Face bounds: %@\", NSStringFromCGRect(face.bounds));\n    }\n    [self.faceDetectionDelegate didDetectFaces:metadataObjects];            // 3\n    \n}\n```\n\n条形码检测\n```\n- (BOOL)setupSessionOutputs:(NSError **)error {\n    self.metadataOutput = [[AVCaptureMetadataOutput alloc] init];\n    if ([self.captureSession canAddOutput:self.metadataOutput]) {\n        [self.captureSession addOutput:self.metadataOutput];\n        dispatch_queue_t mainQueue = dispatch_get_main_queue();\n        [self.metadataOutput setMetadataObjectsDelegate:self\n                                                  queue:mainQueue];\n        NSArray *types = @[AVMetadataObjectTypeQRCode,                      // 1\n                           AVMetadataObjectTypeAztecCode,\n                           AVMetadataObjectTypeUPCECode];\n        self.metadataOutput.metadataObjectTypes = types;\n    } else {\n        NSDictionary *userInfo = @{NSLocalizedDescriptionKey:\n                                       @\"Failed to still image output.\"};\n        *error = [NSError errorWithDomain:THCameraErrorDomain\n                                     code:THCameraErrorFailedToAddOutput\n                                 userInfo:userInfo];\n        return NO;\n    }\n    return YES;\n}\n- (void)captureOutput:(AVCaptureOutput *)captureOutput\ndidOutputMetadataObjects:(NSArray *)metadataObjects\n       fromConnection:(AVCaptureConnection *)connection {\n    [self.codeDetectionDelegate didDetectCodes:metadataObjects];            // 2\n}\n```","slug":"AVFoundation学习笔记十","published":1,"updated":"2019-07-09T08:13:34.928Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyzlbt85000c0j66hifeftyx","content":"<p>视频缩放<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (BOOL)cameraSupportsZoom &#123;</span><br><span class=\"line\"> \treturn self.activeCamera.activeFormat.videoMaxZoomFactor &gt; 1.0f;        // 1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (CGFloat)maxZoomFactor &#123;</span><br><span class=\"line\"> \treturn MIN(self.activeCamera.activeFormat.videoMaxZoomFactor, 4.0f);    // 2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (void)setZoomValue:(CGFloat)zoomValue &#123;                                   // 3</span><br><span class=\"line\"> \tif (!self.activeCamera.isRampingVideoZoom) &#123;</span><br><span class=\"line\">        NSError *error;</span><br><span class=\"line\">        if ([self.activeCamera lockForConfiguration:&amp;error]) &#123;              // 4</span><br><span class=\"line\">            // Provide linear feel to zoom slider</span><br><span class=\"line\"> \t\t\tCGFloat zoomFactor = pow([self maxZoomFactor], zoomValue);      // 5</span><br><span class=\"line\">            self.activeCamera.videoZoomFactor = zoomFactor;</span><br><span class=\"line\">            [self.activeCamera unlockForConfiguration];                     // 6</span><br><span class=\"line\"> \t\t&#125; else &#123;</span><br><span class=\"line\">            [self.delegate deviceConfigurationFailedWithError:error];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> \t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (void)rampZoomToValue:(CGFloat)zoomValue &#123;                                // 1</span><br><span class=\"line\">    CGFloat zoomFactor = pow([self maxZoomFactor], zoomValue);</span><br><span class=\"line\"> \tNSError *error;</span><br><span class=\"line\"> \tif ([self.activeCamera lockForConfiguration:&amp;error]) &#123;</span><br><span class=\"line\"> \t\t[self.activeCamera rampToVideoZoomFactor:zoomFactor                 // 2</span><br><span class=\"line\">                                        withRate:THZoomRate];</span><br><span class=\"line\"> \t\t[self.activeCamera unlockForConfiguration];</span><br><span class=\"line\"> \t&#125; else &#123;</span><br><span class=\"line\"> \t\t[self.delegate deviceConfigurationFailedWithError:error];</span><br><span class=\"line\"> \t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>人脸检测<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (BOOL)setupSessionOutputs:(NSError **)error &#123;</span><br><span class=\"line\">//设置输出数据类型</span><br><span class=\"line\">    self.metadataOutput = [[AVCaptureMetadataOutput alloc] init];           // 2</span><br><span class=\"line\">    if ([self.captureSession canAddOutput:self.metadataOutput]) &#123;</span><br><span class=\"line\">        [self.captureSession addOutput:self.metadataOutput];</span><br><span class=\"line\">//设置人脸检测</span><br><span class=\"line\">        NSArray *metadataObjectTypes = @[AVMetadataObjectTypeFace];         // 3</span><br><span class=\"line\">        self.metadataOutput.metadataObjectTypes = metadataObjectTypes;</span><br><span class=\"line\">        dispatch_queue_t mainQueue = dispatch_get_main_queue();</span><br><span class=\"line\">        [self.metadataOutput setMetadataObjectsDelegate:self                // 4</span><br><span class=\"line\">                                                  queue:mainQueue];</span><br><span class=\"line\">        return YES;</span><br><span class=\"line\">    &#125; else &#123;                                                                // 5</span><br><span class=\"line\">        if (error) &#123;</span><br><span class=\"line\">            NSDictionary *userInfo = @&#123;NSLocalizedDescriptionKey:</span><br><span class=\"line\">                                           @&quot;Failed to still image output.&quot;&#125;;</span><br><span class=\"line\">            *error = [NSError errorWithDomain:THCameraErrorDomain</span><br><span class=\"line\">                                         code:THCameraErrorFailedToAddOutput</span><br><span class=\"line\">                                     userInfo:userInfo];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return NO;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//人脸检测回调</span><br><span class=\"line\">- (void)captureOutput:(AVCaptureOutput *)captureOutput</span><br><span class=\"line\">didOutputMetadataObjects:(NSArray *)metadataObjects</span><br><span class=\"line\">       fromConnection:(AVCaptureConnection *)connection &#123;</span><br><span class=\"line\">    for (AVMetadataFaceObject *face in metadataObjects) &#123;                   // 2</span><br><span class=\"line\">        NSLog(@&quot;Face detected with ID: %li&quot;, (long)face.faceID);</span><br><span class=\"line\">        NSLog(@&quot;Face bounds: %@&quot;, NSStringFromCGRect(face.bounds));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    [self.faceDetectionDelegate didDetectFaces:metadataObjects];            // 3</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>条形码检测<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (BOOL)setupSessionOutputs:(NSError **)error &#123;</span><br><span class=\"line\">    self.metadataOutput = [[AVCaptureMetadataOutput alloc] init];</span><br><span class=\"line\">    if ([self.captureSession canAddOutput:self.metadataOutput]) &#123;</span><br><span class=\"line\">        [self.captureSession addOutput:self.metadataOutput];</span><br><span class=\"line\">        dispatch_queue_t mainQueue = dispatch_get_main_queue();</span><br><span class=\"line\">        [self.metadataOutput setMetadataObjectsDelegate:self</span><br><span class=\"line\">                                                  queue:mainQueue];</span><br><span class=\"line\">        NSArray *types = @[AVMetadataObjectTypeQRCode,                      // 1</span><br><span class=\"line\">                           AVMetadataObjectTypeAztecCode,</span><br><span class=\"line\">                           AVMetadataObjectTypeUPCECode];</span><br><span class=\"line\">        self.metadataOutput.metadataObjectTypes = types;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        NSDictionary *userInfo = @&#123;NSLocalizedDescriptionKey:</span><br><span class=\"line\">                                       @&quot;Failed to still image output.&quot;&#125;;</span><br><span class=\"line\">        *error = [NSError errorWithDomain:THCameraErrorDomain</span><br><span class=\"line\">                                     code:THCameraErrorFailedToAddOutput</span><br><span class=\"line\">                                 userInfo:userInfo];</span><br><span class=\"line\">        return NO;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return YES;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (void)captureOutput:(AVCaptureOutput *)captureOutput</span><br><span class=\"line\">didOutputMetadataObjects:(NSArray *)metadataObjects</span><br><span class=\"line\">       fromConnection:(AVCaptureConnection *)connection &#123;</span><br><span class=\"line\">    [self.codeDetectionDelegate didDetectCodes:metadataObjects];            // 2</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>视频缩放<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (BOOL)cameraSupportsZoom &#123;</span><br><span class=\"line\"> \treturn self.activeCamera.activeFormat.videoMaxZoomFactor &gt; 1.0f;        // 1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (CGFloat)maxZoomFactor &#123;</span><br><span class=\"line\"> \treturn MIN(self.activeCamera.activeFormat.videoMaxZoomFactor, 4.0f);    // 2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (void)setZoomValue:(CGFloat)zoomValue &#123;                                   // 3</span><br><span class=\"line\"> \tif (!self.activeCamera.isRampingVideoZoom) &#123;</span><br><span class=\"line\">        NSError *error;</span><br><span class=\"line\">        if ([self.activeCamera lockForConfiguration:&amp;error]) &#123;              // 4</span><br><span class=\"line\">            // Provide linear feel to zoom slider</span><br><span class=\"line\"> \t\t\tCGFloat zoomFactor = pow([self maxZoomFactor], zoomValue);      // 5</span><br><span class=\"line\">            self.activeCamera.videoZoomFactor = zoomFactor;</span><br><span class=\"line\">            [self.activeCamera unlockForConfiguration];                     // 6</span><br><span class=\"line\"> \t\t&#125; else &#123;</span><br><span class=\"line\">            [self.delegate deviceConfigurationFailedWithError:error];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> \t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (void)rampZoomToValue:(CGFloat)zoomValue &#123;                                // 1</span><br><span class=\"line\">    CGFloat zoomFactor = pow([self maxZoomFactor], zoomValue);</span><br><span class=\"line\"> \tNSError *error;</span><br><span class=\"line\"> \tif ([self.activeCamera lockForConfiguration:&amp;error]) &#123;</span><br><span class=\"line\"> \t\t[self.activeCamera rampToVideoZoomFactor:zoomFactor                 // 2</span><br><span class=\"line\">                                        withRate:THZoomRate];</span><br><span class=\"line\"> \t\t[self.activeCamera unlockForConfiguration];</span><br><span class=\"line\"> \t&#125; else &#123;</span><br><span class=\"line\"> \t\t[self.delegate deviceConfigurationFailedWithError:error];</span><br><span class=\"line\"> \t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>人脸检测<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (BOOL)setupSessionOutputs:(NSError **)error &#123;</span><br><span class=\"line\">//设置输出数据类型</span><br><span class=\"line\">    self.metadataOutput = [[AVCaptureMetadataOutput alloc] init];           // 2</span><br><span class=\"line\">    if ([self.captureSession canAddOutput:self.metadataOutput]) &#123;</span><br><span class=\"line\">        [self.captureSession addOutput:self.metadataOutput];</span><br><span class=\"line\">//设置人脸检测</span><br><span class=\"line\">        NSArray *metadataObjectTypes = @[AVMetadataObjectTypeFace];         // 3</span><br><span class=\"line\">        self.metadataOutput.metadataObjectTypes = metadataObjectTypes;</span><br><span class=\"line\">        dispatch_queue_t mainQueue = dispatch_get_main_queue();</span><br><span class=\"line\">        [self.metadataOutput setMetadataObjectsDelegate:self                // 4</span><br><span class=\"line\">                                                  queue:mainQueue];</span><br><span class=\"line\">        return YES;</span><br><span class=\"line\">    &#125; else &#123;                                                                // 5</span><br><span class=\"line\">        if (error) &#123;</span><br><span class=\"line\">            NSDictionary *userInfo = @&#123;NSLocalizedDescriptionKey:</span><br><span class=\"line\">                                           @&quot;Failed to still image output.&quot;&#125;;</span><br><span class=\"line\">            *error = [NSError errorWithDomain:THCameraErrorDomain</span><br><span class=\"line\">                                         code:THCameraErrorFailedToAddOutput</span><br><span class=\"line\">                                     userInfo:userInfo];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return NO;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//人脸检测回调</span><br><span class=\"line\">- (void)captureOutput:(AVCaptureOutput *)captureOutput</span><br><span class=\"line\">didOutputMetadataObjects:(NSArray *)metadataObjects</span><br><span class=\"line\">       fromConnection:(AVCaptureConnection *)connection &#123;</span><br><span class=\"line\">    for (AVMetadataFaceObject *face in metadataObjects) &#123;                   // 2</span><br><span class=\"line\">        NSLog(@&quot;Face detected with ID: %li&quot;, (long)face.faceID);</span><br><span class=\"line\">        NSLog(@&quot;Face bounds: %@&quot;, NSStringFromCGRect(face.bounds));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    [self.faceDetectionDelegate didDetectFaces:metadataObjects];            // 3</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>条形码检测<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (BOOL)setupSessionOutputs:(NSError **)error &#123;</span><br><span class=\"line\">    self.metadataOutput = [[AVCaptureMetadataOutput alloc] init];</span><br><span class=\"line\">    if ([self.captureSession canAddOutput:self.metadataOutput]) &#123;</span><br><span class=\"line\">        [self.captureSession addOutput:self.metadataOutput];</span><br><span class=\"line\">        dispatch_queue_t mainQueue = dispatch_get_main_queue();</span><br><span class=\"line\">        [self.metadataOutput setMetadataObjectsDelegate:self</span><br><span class=\"line\">                                                  queue:mainQueue];</span><br><span class=\"line\">        NSArray *types = @[AVMetadataObjectTypeQRCode,                      // 1</span><br><span class=\"line\">                           AVMetadataObjectTypeAztecCode,</span><br><span class=\"line\">                           AVMetadataObjectTypeUPCECode];</span><br><span class=\"line\">        self.metadataOutput.metadataObjectTypes = types;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        NSDictionary *userInfo = @&#123;NSLocalizedDescriptionKey:</span><br><span class=\"line\">                                       @&quot;Failed to still image output.&quot;&#125;;</span><br><span class=\"line\">        *error = [NSError errorWithDomain:THCameraErrorDomain</span><br><span class=\"line\">                                     code:THCameraErrorFailedToAddOutput</span><br><span class=\"line\">                                 userInfo:userInfo];</span><br><span class=\"line\">        return NO;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return YES;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (void)captureOutput:(AVCaptureOutput *)captureOutput</span><br><span class=\"line\">didOutputMetadataObjects:(NSArray *)metadataObjects</span><br><span class=\"line\">       fromConnection:(AVCaptureConnection *)connection &#123;</span><br><span class=\"line\">    [self.codeDetectionDelegate didDetectCodes:metadataObjects];            // 2</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"AVFoundation学习笔记十一 AVCaptureVideoDataOutput","author":"Cyrus","date":"2018-11-12T14:25:00.000Z","_content":"\n### AVCaptureVideoDataOutput\nAVCaptureVideoDataOutput是一个AVCaptureOutput子类，可以直接访问摄像头伟感器捕捉到的视频帧。这是一个强大的功能，因为这样我们就完全控制了视频数据的格式、时间和元数据，可以按照需求操作视频内容。\n注：AVFoundation为处理音频数据提供了一个底层捕捉输出AVCaptureAudioDataOutput。使用方法类似。\n\n与输出AVMetadataObject实例不同，AVCaptureVideoDataOutput输出的对象需要通过AVCaptureVideoDataOutputSampleBufferDelegate协议包含视频数据。\n\nAVCaptureVideoDataOutputSampleBufferDelegate定义了下面两个方法：\n```\n//每当有一个新的视频帧写入时该方法就会被调用。数据会基于视频数据输出的videoSetting属性进行解码或重新编码。\n- (void)captureOutput:(AVCaptureOutput *)output didOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer fromConnection:(AVCaptureConnection *)connection\n\n//每当一个迟到的视频帧被丢弃时就会调用该方法。通过是因为在didOutputSampleBuffer：调用中消耗了太多处理时间就会调用该方法。\n- (void)captureOutput:(AVCaptureOutput *)output didDropSampleBuffer:(CMSampleBufferRef)sampleBuffer fromConnection:(AVCaptureConnection *)connection\n```\n\n### CMSampleBuffer\nCMSampleBuffer是一个由Core Media框架提供的Core Foundation风格对象，用于在媒体管道传输数字样本。CMSampleBuffer的角色是将基础的样本数据进行封装并提供格式和时间信息，还会加上所有在转换和处理数据时用到的元数据。\n\n### 样本数据\n在使用AVCaptureVideoDataOutput时，sample buffer会包含一个CVPixelBuffer，它是一个带有带个视频帧原始像素数据的CoreVideo对象。\n\n```\n从sampleBuffer中获取图片\nCVImageBufferRef imageBuffer =  CMSampleBufferGetImageBuffer(sampleBuffer);\n    \n    CVPixelBufferLockBaseAddress(imageBuffer, 0);\n    void *baseAddress = CVPixelBufferGetBaseAddress(imageBuffer);\n    size_t width = CVPixelBufferGetWidth(imageBuffer);\n    size_t height = CVPixelBufferGetHeight(imageBuffer);\n    size_t bufferSize = CVPixelBufferGetDataSize(imageBuffer);\n    size_t bytesPerRow = CVPixelBufferGetBytesPerRowOfPlane(imageBuffer, 0);\n    \n    CGColorSpaceRef rgbColorSpace = CGColorSpaceCreateDeviceRGB();\n    CGDataProviderRef provider = CGDataProviderCreateWithData(NULL, baseAddress, bufferSize, NULL);\n     \n    CGImageRef cgImage = CGImageCreate(width, height, 8, 32, bytesPerRow, rgbColorSpace, kCGImageAlphaNoneSkipFirst|kCGBitmapByteOrder32Little, provider, NULL, true, kCGRenderingIntentDefault);\n\n    \n    UIImage *image = [UIImage imageWithCGImage:cgImage];\n     \n    CGImageRelease(cgImage);\n    CGDataProviderRelease(provider);\n    CGColorSpaceRelease(rgbColorSpace);\n\n    NSData* imageData = UIImageJPEGRepresentation(image, 1.0);\n    image = [UIImage imageWithData:imageData];\n    CVPixelBufferUnlockBaseAddress(imageBuffer, 0);\n    return image;\n```\n\n### 格式描述\n除了原始媒体样本本身之外，CMSampleBuffer还提供了以CMFormatDescription对象的形式来访问样本的信息。CMFormatDescription.h定义了大量函数用于访问媒体样本的更多细节。在头文件中带有CMFormatDescription的函数分别适用于获取视频和音频细节。\n```\n判断sampleBuffer格式\nCMFormatDescriptionRef formatDescription =                              // 2\n        CMSampleBufferGetFormatDescription(sampleBuffer);\n    CMMediaType mediaType = CMFormatDescriptionGetMediaType(formatDescription);\n    if (mediaType == kCMMediaType_Video) {\n        CVPixelBufferRef pixelBuffer = CMSampleBufferGetImageBuffer(sampleBuffer);\n        //process the frame of video\n    } else if(mediaType == kCMMediaType_Audio) {\n        CMBlockBufferRef blockBuffer = CMSampleBufferGetDataBuffer(sampleBuffer);\n        //process audio samples\n    }\n```\n\n### 时间信息\nCMSampleBuffer还定义了关于媒体样本的时间信息。可以分别使用CMSampleBufferGetPresentationTimeStamp函数和CMSampleBufferGetDecodeTimeStamp函数提取时间信息来得到原始的表示时间戳和解码时间戳\n\n### 附加的元数据\nCoreMedia还在CMAttachment.h中定义了一个CMAttachment形式的元数据协议。API提供了读取和写入底层元数据的基础架构，比如可交换图片文件格式（Exif）标签。\n从一个给定的CMSampleBuffer中获取Exif元数据。\n\n```\nCFDictionaryRef exifAttachments = CMGetAttachment(sampleBuffer, kCGImagePropertyExifDictionary, NULL);\n\n//打印的信息\n(lldb) po exifAttachments\n{\n    ApertureValue = \"2.27500704749987\";\n    BrightnessValue = \"3.366379752578831\";\n    ColorSpace = 1;\n    DateTimeDigitized = \"2018:11:12 15:22:21\";\n    DateTimeOriginal = \"2018:11:12 15:22:21\";\n    ExposureBiasValue = 0;\n    ExposureTime = \"0.03333333333333333\";\n    FNumber = \"2.2\";\n    Flash = 0;\n    FocalLenIn35mmFilm = 155;\n    FocalLength = \"2.87\";\n    ISOSpeedRatings =     (\n        64\n    );\n    LensMake = Apple;\n    LensModel = \"iPhone 8 front camera 2.87mm f/2.2\";\n    LensSpecification =     (\n        \"2.87\",\n        \"2.87\",\n        \"2.2\",\n        \"2.2\"\n    );\n    MeteringMode = 5;\n    PixelXDimension = 640;\n    PixelYDimension = 480;\n    SceneType = 1;\n    SensingMethod = 2;\n    ShutterSpeedValue = \"4.907121445283527\";\n    SubsecTimeDigitized = 923;\n    SubsecTimeOriginal = 923;\n    WhiteBalance = 0;\n}\n```","source":"_posts/AVFoundation学习笔记十一.md","raw":"title: AVFoundation学习笔记十一 AVCaptureVideoDataOutput\nauthor: Cyrus\ntags: []\ncategories:\n  - AVFoundation\ndate: 2018-11-12 22:25:00\n---\n\n### AVCaptureVideoDataOutput\nAVCaptureVideoDataOutput是一个AVCaptureOutput子类，可以直接访问摄像头伟感器捕捉到的视频帧。这是一个强大的功能，因为这样我们就完全控制了视频数据的格式、时间和元数据，可以按照需求操作视频内容。\n注：AVFoundation为处理音频数据提供了一个底层捕捉输出AVCaptureAudioDataOutput。使用方法类似。\n\n与输出AVMetadataObject实例不同，AVCaptureVideoDataOutput输出的对象需要通过AVCaptureVideoDataOutputSampleBufferDelegate协议包含视频数据。\n\nAVCaptureVideoDataOutputSampleBufferDelegate定义了下面两个方法：\n```\n//每当有一个新的视频帧写入时该方法就会被调用。数据会基于视频数据输出的videoSetting属性进行解码或重新编码。\n- (void)captureOutput:(AVCaptureOutput *)output didOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer fromConnection:(AVCaptureConnection *)connection\n\n//每当一个迟到的视频帧被丢弃时就会调用该方法。通过是因为在didOutputSampleBuffer：调用中消耗了太多处理时间就会调用该方法。\n- (void)captureOutput:(AVCaptureOutput *)output didDropSampleBuffer:(CMSampleBufferRef)sampleBuffer fromConnection:(AVCaptureConnection *)connection\n```\n\n### CMSampleBuffer\nCMSampleBuffer是一个由Core Media框架提供的Core Foundation风格对象，用于在媒体管道传输数字样本。CMSampleBuffer的角色是将基础的样本数据进行封装并提供格式和时间信息，还会加上所有在转换和处理数据时用到的元数据。\n\n### 样本数据\n在使用AVCaptureVideoDataOutput时，sample buffer会包含一个CVPixelBuffer，它是一个带有带个视频帧原始像素数据的CoreVideo对象。\n\n```\n从sampleBuffer中获取图片\nCVImageBufferRef imageBuffer =  CMSampleBufferGetImageBuffer(sampleBuffer);\n    \n    CVPixelBufferLockBaseAddress(imageBuffer, 0);\n    void *baseAddress = CVPixelBufferGetBaseAddress(imageBuffer);\n    size_t width = CVPixelBufferGetWidth(imageBuffer);\n    size_t height = CVPixelBufferGetHeight(imageBuffer);\n    size_t bufferSize = CVPixelBufferGetDataSize(imageBuffer);\n    size_t bytesPerRow = CVPixelBufferGetBytesPerRowOfPlane(imageBuffer, 0);\n    \n    CGColorSpaceRef rgbColorSpace = CGColorSpaceCreateDeviceRGB();\n    CGDataProviderRef provider = CGDataProviderCreateWithData(NULL, baseAddress, bufferSize, NULL);\n     \n    CGImageRef cgImage = CGImageCreate(width, height, 8, 32, bytesPerRow, rgbColorSpace, kCGImageAlphaNoneSkipFirst|kCGBitmapByteOrder32Little, provider, NULL, true, kCGRenderingIntentDefault);\n\n    \n    UIImage *image = [UIImage imageWithCGImage:cgImage];\n     \n    CGImageRelease(cgImage);\n    CGDataProviderRelease(provider);\n    CGColorSpaceRelease(rgbColorSpace);\n\n    NSData* imageData = UIImageJPEGRepresentation(image, 1.0);\n    image = [UIImage imageWithData:imageData];\n    CVPixelBufferUnlockBaseAddress(imageBuffer, 0);\n    return image;\n```\n\n### 格式描述\n除了原始媒体样本本身之外，CMSampleBuffer还提供了以CMFormatDescription对象的形式来访问样本的信息。CMFormatDescription.h定义了大量函数用于访问媒体样本的更多细节。在头文件中带有CMFormatDescription的函数分别适用于获取视频和音频细节。\n```\n判断sampleBuffer格式\nCMFormatDescriptionRef formatDescription =                              // 2\n        CMSampleBufferGetFormatDescription(sampleBuffer);\n    CMMediaType mediaType = CMFormatDescriptionGetMediaType(formatDescription);\n    if (mediaType == kCMMediaType_Video) {\n        CVPixelBufferRef pixelBuffer = CMSampleBufferGetImageBuffer(sampleBuffer);\n        //process the frame of video\n    } else if(mediaType == kCMMediaType_Audio) {\n        CMBlockBufferRef blockBuffer = CMSampleBufferGetDataBuffer(sampleBuffer);\n        //process audio samples\n    }\n```\n\n### 时间信息\nCMSampleBuffer还定义了关于媒体样本的时间信息。可以分别使用CMSampleBufferGetPresentationTimeStamp函数和CMSampleBufferGetDecodeTimeStamp函数提取时间信息来得到原始的表示时间戳和解码时间戳\n\n### 附加的元数据\nCoreMedia还在CMAttachment.h中定义了一个CMAttachment形式的元数据协议。API提供了读取和写入底层元数据的基础架构，比如可交换图片文件格式（Exif）标签。\n从一个给定的CMSampleBuffer中获取Exif元数据。\n\n```\nCFDictionaryRef exifAttachments = CMGetAttachment(sampleBuffer, kCGImagePropertyExifDictionary, NULL);\n\n//打印的信息\n(lldb) po exifAttachments\n{\n    ApertureValue = \"2.27500704749987\";\n    BrightnessValue = \"3.366379752578831\";\n    ColorSpace = 1;\n    DateTimeDigitized = \"2018:11:12 15:22:21\";\n    DateTimeOriginal = \"2018:11:12 15:22:21\";\n    ExposureBiasValue = 0;\n    ExposureTime = \"0.03333333333333333\";\n    FNumber = \"2.2\";\n    Flash = 0;\n    FocalLenIn35mmFilm = 155;\n    FocalLength = \"2.87\";\n    ISOSpeedRatings =     (\n        64\n    );\n    LensMake = Apple;\n    LensModel = \"iPhone 8 front camera 2.87mm f/2.2\";\n    LensSpecification =     (\n        \"2.87\",\n        \"2.87\",\n        \"2.2\",\n        \"2.2\"\n    );\n    MeteringMode = 5;\n    PixelXDimension = 640;\n    PixelYDimension = 480;\n    SceneType = 1;\n    SensingMethod = 2;\n    ShutterSpeedValue = \"4.907121445283527\";\n    SubsecTimeDigitized = 923;\n    SubsecTimeOriginal = 923;\n    WhiteBalance = 0;\n}\n```","slug":"AVFoundation学习笔记十一","published":1,"updated":"2019-07-09T08:13:34.928Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyzlbt87000f0j66gmccd8kb","content":"<h3 id=\"AVCaptureVideoDataOutput\"><a href=\"#AVCaptureVideoDataOutput\" class=\"headerlink\" title=\"AVCaptureVideoDataOutput\"></a>AVCaptureVideoDataOutput</h3><p>AVCaptureVideoDataOutput是一个AVCaptureOutput子类，可以直接访问摄像头伟感器捕捉到的视频帧。这是一个强大的功能，因为这样我们就完全控制了视频数据的格式、时间和元数据，可以按照需求操作视频内容。<br>注：AVFoundation为处理音频数据提供了一个底层捕捉输出AVCaptureAudioDataOutput。使用方法类似。</p>\n<p>与输出AVMetadataObject实例不同，AVCaptureVideoDataOutput输出的对象需要通过AVCaptureVideoDataOutputSampleBufferDelegate协议包含视频数据。</p>\n<p>AVCaptureVideoDataOutputSampleBufferDelegate定义了下面两个方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//每当有一个新的视频帧写入时该方法就会被调用。数据会基于视频数据输出的videoSetting属性进行解码或重新编码。</span><br><span class=\"line\">- (void)captureOutput:(AVCaptureOutput *)output didOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer fromConnection:(AVCaptureConnection *)connection</span><br><span class=\"line\"></span><br><span class=\"line\">//每当一个迟到的视频帧被丢弃时就会调用该方法。通过是因为在didOutputSampleBuffer：调用中消耗了太多处理时间就会调用该方法。</span><br><span class=\"line\">- (void)captureOutput:(AVCaptureOutput *)output didDropSampleBuffer:(CMSampleBufferRef)sampleBuffer fromConnection:(AVCaptureConnection *)connection</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"CMSampleBuffer\"><a href=\"#CMSampleBuffer\" class=\"headerlink\" title=\"CMSampleBuffer\"></a>CMSampleBuffer</h3><p>CMSampleBuffer是一个由Core Media框架提供的Core Foundation风格对象，用于在媒体管道传输数字样本。CMSampleBuffer的角色是将基础的样本数据进行封装并提供格式和时间信息，还会加上所有在转换和处理数据时用到的元数据。</p>\n<h3 id=\"样本数据\"><a href=\"#样本数据\" class=\"headerlink\" title=\"样本数据\"></a>样本数据</h3><p>在使用AVCaptureVideoDataOutput时，sample buffer会包含一个CVPixelBuffer，它是一个带有带个视频帧原始像素数据的CoreVideo对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">从sampleBuffer中获取图片</span><br><span class=\"line\">CVImageBufferRef imageBuffer =  CMSampleBufferGetImageBuffer(sampleBuffer);</span><br><span class=\"line\">    </span><br><span class=\"line\">    CVPixelBufferLockBaseAddress(imageBuffer, 0);</span><br><span class=\"line\">    void *baseAddress = CVPixelBufferGetBaseAddress(imageBuffer);</span><br><span class=\"line\">    size_t width = CVPixelBufferGetWidth(imageBuffer);</span><br><span class=\"line\">    size_t height = CVPixelBufferGetHeight(imageBuffer);</span><br><span class=\"line\">    size_t bufferSize = CVPixelBufferGetDataSize(imageBuffer);</span><br><span class=\"line\">    size_t bytesPerRow = CVPixelBufferGetBytesPerRowOfPlane(imageBuffer, 0);</span><br><span class=\"line\">    </span><br><span class=\"line\">    CGColorSpaceRef rgbColorSpace = CGColorSpaceCreateDeviceRGB();</span><br><span class=\"line\">    CGDataProviderRef provider = CGDataProviderCreateWithData(NULL, baseAddress, bufferSize, NULL);</span><br><span class=\"line\">     </span><br><span class=\"line\">    CGImageRef cgImage = CGImageCreate(width, height, 8, 32, bytesPerRow, rgbColorSpace, kCGImageAlphaNoneSkipFirst|kCGBitmapByteOrder32Little, provider, NULL, true, kCGRenderingIntentDefault);</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    UIImage *image = [UIImage imageWithCGImage:cgImage];</span><br><span class=\"line\">     </span><br><span class=\"line\">    CGImageRelease(cgImage);</span><br><span class=\"line\">    CGDataProviderRelease(provider);</span><br><span class=\"line\">    CGColorSpaceRelease(rgbColorSpace);</span><br><span class=\"line\"></span><br><span class=\"line\">    NSData* imageData = UIImageJPEGRepresentation(image, 1.0);</span><br><span class=\"line\">    image = [UIImage imageWithData:imageData];</span><br><span class=\"line\">    CVPixelBufferUnlockBaseAddress(imageBuffer, 0);</span><br><span class=\"line\">    return image;</span><br></pre></td></tr></table></figure>\n<h3 id=\"格式描述\"><a href=\"#格式描述\" class=\"headerlink\" title=\"格式描述\"></a>格式描述</h3><p>除了原始媒体样本本身之外，CMSampleBuffer还提供了以CMFormatDescription对象的形式来访问样本的信息。CMFormatDescription.h定义了大量函数用于访问媒体样本的更多细节。在头文件中带有CMFormatDescription的函数分别适用于获取视频和音频细节。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">判断sampleBuffer格式</span><br><span class=\"line\">CMFormatDescriptionRef formatDescription =                              // 2</span><br><span class=\"line\">        CMSampleBufferGetFormatDescription(sampleBuffer);</span><br><span class=\"line\">    CMMediaType mediaType = CMFormatDescriptionGetMediaType(formatDescription);</span><br><span class=\"line\">    if (mediaType == kCMMediaType_Video) &#123;</span><br><span class=\"line\">        CVPixelBufferRef pixelBuffer = CMSampleBufferGetImageBuffer(sampleBuffer);</span><br><span class=\"line\">        //process the frame of video</span><br><span class=\"line\">    &#125; else if(mediaType == kCMMediaType_Audio) &#123;</span><br><span class=\"line\">        CMBlockBufferRef blockBuffer = CMSampleBufferGetDataBuffer(sampleBuffer);</span><br><span class=\"line\">        //process audio samples</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"时间信息\"><a href=\"#时间信息\" class=\"headerlink\" title=\"时间信息\"></a>时间信息</h3><p>CMSampleBuffer还定义了关于媒体样本的时间信息。可以分别使用CMSampleBufferGetPresentationTimeStamp函数和CMSampleBufferGetDecodeTimeStamp函数提取时间信息来得到原始的表示时间戳和解码时间戳</p>\n<h3 id=\"附加的元数据\"><a href=\"#附加的元数据\" class=\"headerlink\" title=\"附加的元数据\"></a>附加的元数据</h3><p>CoreMedia还在CMAttachment.h中定义了一个CMAttachment形式的元数据协议。API提供了读取和写入底层元数据的基础架构，比如可交换图片文件格式（Exif）标签。<br>从一个给定的CMSampleBuffer中获取Exif元数据。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CFDictionaryRef exifAttachments = CMGetAttachment(sampleBuffer, kCGImagePropertyExifDictionary, NULL);</span><br><span class=\"line\"></span><br><span class=\"line\">//打印的信息</span><br><span class=\"line\">(lldb) po exifAttachments</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ApertureValue = &quot;2.27500704749987&quot;;</span><br><span class=\"line\">    BrightnessValue = &quot;3.366379752578831&quot;;</span><br><span class=\"line\">    ColorSpace = 1;</span><br><span class=\"line\">    DateTimeDigitized = &quot;2018:11:12 15:22:21&quot;;</span><br><span class=\"line\">    DateTimeOriginal = &quot;2018:11:12 15:22:21&quot;;</span><br><span class=\"line\">    ExposureBiasValue = 0;</span><br><span class=\"line\">    ExposureTime = &quot;0.03333333333333333&quot;;</span><br><span class=\"line\">    FNumber = &quot;2.2&quot;;</span><br><span class=\"line\">    Flash = 0;</span><br><span class=\"line\">    FocalLenIn35mmFilm = 155;</span><br><span class=\"line\">    FocalLength = &quot;2.87&quot;;</span><br><span class=\"line\">    ISOSpeedRatings =     (</span><br><span class=\"line\">        64</span><br><span class=\"line\">    );</span><br><span class=\"line\">    LensMake = Apple;</span><br><span class=\"line\">    LensModel = &quot;iPhone 8 front camera 2.87mm f/2.2&quot;;</span><br><span class=\"line\">    LensSpecification =     (</span><br><span class=\"line\">        &quot;2.87&quot;,</span><br><span class=\"line\">        &quot;2.87&quot;,</span><br><span class=\"line\">        &quot;2.2&quot;,</span><br><span class=\"line\">        &quot;2.2&quot;</span><br><span class=\"line\">    );</span><br><span class=\"line\">    MeteringMode = 5;</span><br><span class=\"line\">    PixelXDimension = 640;</span><br><span class=\"line\">    PixelYDimension = 480;</span><br><span class=\"line\">    SceneType = 1;</span><br><span class=\"line\">    SensingMethod = 2;</span><br><span class=\"line\">    ShutterSpeedValue = &quot;4.907121445283527&quot;;</span><br><span class=\"line\">    SubsecTimeDigitized = 923;</span><br><span class=\"line\">    SubsecTimeOriginal = 923;</span><br><span class=\"line\">    WhiteBalance = 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"AVCaptureVideoDataOutput\"><a href=\"#AVCaptureVideoDataOutput\" class=\"headerlink\" title=\"AVCaptureVideoDataOutput\"></a>AVCaptureVideoDataOutput</h3><p>AVCaptureVideoDataOutput是一个AVCaptureOutput子类，可以直接访问摄像头伟感器捕捉到的视频帧。这是一个强大的功能，因为这样我们就完全控制了视频数据的格式、时间和元数据，可以按照需求操作视频内容。<br>注：AVFoundation为处理音频数据提供了一个底层捕捉输出AVCaptureAudioDataOutput。使用方法类似。</p>\n<p>与输出AVMetadataObject实例不同，AVCaptureVideoDataOutput输出的对象需要通过AVCaptureVideoDataOutputSampleBufferDelegate协议包含视频数据。</p>\n<p>AVCaptureVideoDataOutputSampleBufferDelegate定义了下面两个方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//每当有一个新的视频帧写入时该方法就会被调用。数据会基于视频数据输出的videoSetting属性进行解码或重新编码。</span><br><span class=\"line\">- (void)captureOutput:(AVCaptureOutput *)output didOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer fromConnection:(AVCaptureConnection *)connection</span><br><span class=\"line\"></span><br><span class=\"line\">//每当一个迟到的视频帧被丢弃时就会调用该方法。通过是因为在didOutputSampleBuffer：调用中消耗了太多处理时间就会调用该方法。</span><br><span class=\"line\">- (void)captureOutput:(AVCaptureOutput *)output didDropSampleBuffer:(CMSampleBufferRef)sampleBuffer fromConnection:(AVCaptureConnection *)connection</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"CMSampleBuffer\"><a href=\"#CMSampleBuffer\" class=\"headerlink\" title=\"CMSampleBuffer\"></a>CMSampleBuffer</h3><p>CMSampleBuffer是一个由Core Media框架提供的Core Foundation风格对象，用于在媒体管道传输数字样本。CMSampleBuffer的角色是将基础的样本数据进行封装并提供格式和时间信息，还会加上所有在转换和处理数据时用到的元数据。</p>\n<h3 id=\"样本数据\"><a href=\"#样本数据\" class=\"headerlink\" title=\"样本数据\"></a>样本数据</h3><p>在使用AVCaptureVideoDataOutput时，sample buffer会包含一个CVPixelBuffer，它是一个带有带个视频帧原始像素数据的CoreVideo对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">从sampleBuffer中获取图片</span><br><span class=\"line\">CVImageBufferRef imageBuffer =  CMSampleBufferGetImageBuffer(sampleBuffer);</span><br><span class=\"line\">    </span><br><span class=\"line\">    CVPixelBufferLockBaseAddress(imageBuffer, 0);</span><br><span class=\"line\">    void *baseAddress = CVPixelBufferGetBaseAddress(imageBuffer);</span><br><span class=\"line\">    size_t width = CVPixelBufferGetWidth(imageBuffer);</span><br><span class=\"line\">    size_t height = CVPixelBufferGetHeight(imageBuffer);</span><br><span class=\"line\">    size_t bufferSize = CVPixelBufferGetDataSize(imageBuffer);</span><br><span class=\"line\">    size_t bytesPerRow = CVPixelBufferGetBytesPerRowOfPlane(imageBuffer, 0);</span><br><span class=\"line\">    </span><br><span class=\"line\">    CGColorSpaceRef rgbColorSpace = CGColorSpaceCreateDeviceRGB();</span><br><span class=\"line\">    CGDataProviderRef provider = CGDataProviderCreateWithData(NULL, baseAddress, bufferSize, NULL);</span><br><span class=\"line\">     </span><br><span class=\"line\">    CGImageRef cgImage = CGImageCreate(width, height, 8, 32, bytesPerRow, rgbColorSpace, kCGImageAlphaNoneSkipFirst|kCGBitmapByteOrder32Little, provider, NULL, true, kCGRenderingIntentDefault);</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    UIImage *image = [UIImage imageWithCGImage:cgImage];</span><br><span class=\"line\">     </span><br><span class=\"line\">    CGImageRelease(cgImage);</span><br><span class=\"line\">    CGDataProviderRelease(provider);</span><br><span class=\"line\">    CGColorSpaceRelease(rgbColorSpace);</span><br><span class=\"line\"></span><br><span class=\"line\">    NSData* imageData = UIImageJPEGRepresentation(image, 1.0);</span><br><span class=\"line\">    image = [UIImage imageWithData:imageData];</span><br><span class=\"line\">    CVPixelBufferUnlockBaseAddress(imageBuffer, 0);</span><br><span class=\"line\">    return image;</span><br></pre></td></tr></table></figure>\n<h3 id=\"格式描述\"><a href=\"#格式描述\" class=\"headerlink\" title=\"格式描述\"></a>格式描述</h3><p>除了原始媒体样本本身之外，CMSampleBuffer还提供了以CMFormatDescription对象的形式来访问样本的信息。CMFormatDescription.h定义了大量函数用于访问媒体样本的更多细节。在头文件中带有CMFormatDescription的函数分别适用于获取视频和音频细节。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">判断sampleBuffer格式</span><br><span class=\"line\">CMFormatDescriptionRef formatDescription =                              // 2</span><br><span class=\"line\">        CMSampleBufferGetFormatDescription(sampleBuffer);</span><br><span class=\"line\">    CMMediaType mediaType = CMFormatDescriptionGetMediaType(formatDescription);</span><br><span class=\"line\">    if (mediaType == kCMMediaType_Video) &#123;</span><br><span class=\"line\">        CVPixelBufferRef pixelBuffer = CMSampleBufferGetImageBuffer(sampleBuffer);</span><br><span class=\"line\">        //process the frame of video</span><br><span class=\"line\">    &#125; else if(mediaType == kCMMediaType_Audio) &#123;</span><br><span class=\"line\">        CMBlockBufferRef blockBuffer = CMSampleBufferGetDataBuffer(sampleBuffer);</span><br><span class=\"line\">        //process audio samples</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"时间信息\"><a href=\"#时间信息\" class=\"headerlink\" title=\"时间信息\"></a>时间信息</h3><p>CMSampleBuffer还定义了关于媒体样本的时间信息。可以分别使用CMSampleBufferGetPresentationTimeStamp函数和CMSampleBufferGetDecodeTimeStamp函数提取时间信息来得到原始的表示时间戳和解码时间戳</p>\n<h3 id=\"附加的元数据\"><a href=\"#附加的元数据\" class=\"headerlink\" title=\"附加的元数据\"></a>附加的元数据</h3><p>CoreMedia还在CMAttachment.h中定义了一个CMAttachment形式的元数据协议。API提供了读取和写入底层元数据的基础架构，比如可交换图片文件格式（Exif）标签。<br>从一个给定的CMSampleBuffer中获取Exif元数据。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CFDictionaryRef exifAttachments = CMGetAttachment(sampleBuffer, kCGImagePropertyExifDictionary, NULL);</span><br><span class=\"line\"></span><br><span class=\"line\">//打印的信息</span><br><span class=\"line\">(lldb) po exifAttachments</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ApertureValue = &quot;2.27500704749987&quot;;</span><br><span class=\"line\">    BrightnessValue = &quot;3.366379752578831&quot;;</span><br><span class=\"line\">    ColorSpace = 1;</span><br><span class=\"line\">    DateTimeDigitized = &quot;2018:11:12 15:22:21&quot;;</span><br><span class=\"line\">    DateTimeOriginal = &quot;2018:11:12 15:22:21&quot;;</span><br><span class=\"line\">    ExposureBiasValue = 0;</span><br><span class=\"line\">    ExposureTime = &quot;0.03333333333333333&quot;;</span><br><span class=\"line\">    FNumber = &quot;2.2&quot;;</span><br><span class=\"line\">    Flash = 0;</span><br><span class=\"line\">    FocalLenIn35mmFilm = 155;</span><br><span class=\"line\">    FocalLength = &quot;2.87&quot;;</span><br><span class=\"line\">    ISOSpeedRatings =     (</span><br><span class=\"line\">        64</span><br><span class=\"line\">    );</span><br><span class=\"line\">    LensMake = Apple;</span><br><span class=\"line\">    LensModel = &quot;iPhone 8 front camera 2.87mm f/2.2&quot;;</span><br><span class=\"line\">    LensSpecification =     (</span><br><span class=\"line\">        &quot;2.87&quot;,</span><br><span class=\"line\">        &quot;2.87&quot;,</span><br><span class=\"line\">        &quot;2.2&quot;,</span><br><span class=\"line\">        &quot;2.2&quot;</span><br><span class=\"line\">    );</span><br><span class=\"line\">    MeteringMode = 5;</span><br><span class=\"line\">    PixelXDimension = 640;</span><br><span class=\"line\">    PixelYDimension = 480;</span><br><span class=\"line\">    SceneType = 1;</span><br><span class=\"line\">    SensingMethod = 2;</span><br><span class=\"line\">    ShutterSpeedValue = &quot;4.907121445283527&quot;;</span><br><span class=\"line\">    SubsecTimeDigitized = 923;</span><br><span class=\"line\">    SubsecTimeOriginal = 923;</span><br><span class=\"line\">    WhiteBalance = 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"AVFoundation学习笔记十二 AVAssetReader AVAssetWriter","author":"Cyrus","date":"2018-11-12T14:33:00.000Z","_content":"\n![](read_write.png)\n\n### AVAssetReader\nAVAsserReader用于从AVAsset实例中读取媒体样本。通常会配置一个或多个AVAssetReaderOutput实例，并通过copyNextSampleBuffer方法可以访问音频样本和视频帧。AVAssetReaderOutput是一个抽象类，不过框架定义了3个具本实例来从指定的AVAssetTrack中读取解码的媒体样本，从多音频轨道中读取混合输出，或者从多视频轨道中读取组合输出。一个资源读取器的内部通道都是以多线程的方式不断提取下一个可用样本的，这样可以在系统请求资源时最小化时延。\n\n### AVAssetWriter\nAVAssetWriter是AVAssetReader对应的兄弟类，它用于对资源进行编码并将其写入到容器文件中。它由一个或多个AVAssetWriterInput对象配置，用于附加将包含要写入容器的媒体样本的CMSampleBuffer对象。AVAssetWriterInput被配置为可以处理指定的媒体类型，比如音频或视频，并且附加在其后的样本会在最终输出时生成一个独立的AVAssetTrack.当使用一个配置了处理视频样本的AVAssetWriterInput时，开发者会经常用到一个专门的适配器对象AVAssetWriterInputPixelBufferAdaptor.这个类在附加被包装为CVPixelBuffer对象的视频样本时提供最优性能。\nAVAssetWriter可用于实时操作和离线操作两种情况，不过对于每个场景都有不同的方法将样本buffer添加到写入对象的输入中：\n\n***实时***：当处理实时资源时，比如从AVCaptureVideoDataOutput写入捕捉的样本时，AVAssetWriterInput应该令 expectsMediaDataInRealTime属性为YES来确保 readyForMoreMediaData值被正确计算。从实时资源写入数据优化了写入器，这样一来，与维持交错效果相比，快速写入样本具有更高的优先级。这一优化效果不错，视频和音频样本以大致相同的速率捕捉，传入数据自然交错。\n\n***离线***： 当从离线资源读取媒体资源时，比如从AVAssetReader读取样本buffer，在附加样本前仍然需要观察写入的readyForMoreMediaData属性的状态，不过可以使用requestMediaDataWhenReadyOnQueue：usingBlock:方法控制数据的提供。传到这个方法中的代码会随写入器输入准备附加更多的样本而不断被调用，添加样本时开发者需要检索数据并从资源中找到下一个样本进行添加。\n\n读资源\n```\nAVAsset *asset = ...;\n    AVAssetTrack *track = [[asset tracksWithMediaType:AVMediaTypeVideo]firstObject];\n    AVAssetReader *assetReader = [[AVAssetReader alloc] initWithAsset:asset error:nil];\n    NSDictionary *readerOutputSettings = @{\n                                           (id)kCVPixelBufferPixelFormatTypeKey : @(kCVPixelFormatType_32BGRA)\n                                           };\n    AVAssetReaderOutput *trackOutput = [[AVAssetReaderTrackOutput alloc] initWithTrack:track outputSettings:readerOutputSettings];\n    [assetReader addOutput:trackOutput];\n    [assetReader startReading];\n```\n\n写资源\n```\nNSURL *outputURL = ...;\n    AVAssetWriter *assetWriter = [[AVAssetWriter alloc] initWithURL:outputURL fileType:AVFileTypeQuickTimeMovie error:nil];\n    NSDictionary *writerOutputSettings = @{\n                                           AVVideoCodecKey : AVVideoCodecH264,\n                                           AVVideoWidthKey : @1280,\n                                           AVVideoHeightKey : @720,\n                                           AVVideoCompressionPropertiesKey : @{\n                                                   AVVideoMaxKeyFrameIntervalKey : @1,\n                                                   AVVideoAverageBitRateKey : @10500000,\n                                                   AVVideoProfileLevelKey : AVVideoProfileLevelH264Main31\n                                                   }\n                                           };\n    AVAssetWriterInput *writerInput = [[AVAssetWriterInput alloc] initWithMediaType:AVMediaTypeVideo outputSettings:writerOutputSettings];\n    [assetWriter addInput:writerInput];\n    [assetWriter startWriting];\n```\n\n从AVAssetReader拉取数据写入到文件\n```\ndispatch_queue_t dispatchQueue = dispatch_queue_create(\"com.tapharmonic.writerQueue\", NULL);\n    [assetWriter startSessionAtSourceTime:kCMTimeZero];\n    [writerInput requestMediaDataWhenReadyOnQueue:dispatchQueue usingBlock:^{\n        BOOL complete = NO;\n        while ([writerInput isReadyForMoreMediaData] && !complete) {\n            CMSampleBufferRef sampleBuffer = [trackOutput copyNextSampleBuffer];\n            if (sampleBuffer) {\n                BOOL result = [writerInput appendSampleBuffer:sampleBuffer];\n                CFRelease(sampleBuffer);\n                complete = !result;\n            } else {\n                [writerInput markAsFinished];\n                complete = YES;\n            }\n        }\n        if (complete) {\n            [assetWriter finishWritingWithCompletionHandler:^{\n                AVAssetWriterStatus status = assetWriter.status;\n                if (status == AVAssetWriterStatusCompleted) {\n                    //Handle success case\n                } else {\n                    //Handle failure case\n                }\n            }];\n        }\n    }];\n```","source":"_posts/AVFoundation学习笔记十二-AVAssetReader-AVAssetWriter.md","raw":"title: AVFoundation学习笔记十二 AVAssetReader AVAssetWriter\nauthor: Cyrus\ntags: []\ncategories:\n  - AVFoundation\ndate: 2018-11-12 22:33:00\n---\n\n![](read_write.png)\n\n### AVAssetReader\nAVAsserReader用于从AVAsset实例中读取媒体样本。通常会配置一个或多个AVAssetReaderOutput实例，并通过copyNextSampleBuffer方法可以访问音频样本和视频帧。AVAssetReaderOutput是一个抽象类，不过框架定义了3个具本实例来从指定的AVAssetTrack中读取解码的媒体样本，从多音频轨道中读取混合输出，或者从多视频轨道中读取组合输出。一个资源读取器的内部通道都是以多线程的方式不断提取下一个可用样本的，这样可以在系统请求资源时最小化时延。\n\n### AVAssetWriter\nAVAssetWriter是AVAssetReader对应的兄弟类，它用于对资源进行编码并将其写入到容器文件中。它由一个或多个AVAssetWriterInput对象配置，用于附加将包含要写入容器的媒体样本的CMSampleBuffer对象。AVAssetWriterInput被配置为可以处理指定的媒体类型，比如音频或视频，并且附加在其后的样本会在最终输出时生成一个独立的AVAssetTrack.当使用一个配置了处理视频样本的AVAssetWriterInput时，开发者会经常用到一个专门的适配器对象AVAssetWriterInputPixelBufferAdaptor.这个类在附加被包装为CVPixelBuffer对象的视频样本时提供最优性能。\nAVAssetWriter可用于实时操作和离线操作两种情况，不过对于每个场景都有不同的方法将样本buffer添加到写入对象的输入中：\n\n***实时***：当处理实时资源时，比如从AVCaptureVideoDataOutput写入捕捉的样本时，AVAssetWriterInput应该令 expectsMediaDataInRealTime属性为YES来确保 readyForMoreMediaData值被正确计算。从实时资源写入数据优化了写入器，这样一来，与维持交错效果相比，快速写入样本具有更高的优先级。这一优化效果不错，视频和音频样本以大致相同的速率捕捉，传入数据自然交错。\n\n***离线***： 当从离线资源读取媒体资源时，比如从AVAssetReader读取样本buffer，在附加样本前仍然需要观察写入的readyForMoreMediaData属性的状态，不过可以使用requestMediaDataWhenReadyOnQueue：usingBlock:方法控制数据的提供。传到这个方法中的代码会随写入器输入准备附加更多的样本而不断被调用，添加样本时开发者需要检索数据并从资源中找到下一个样本进行添加。\n\n读资源\n```\nAVAsset *asset = ...;\n    AVAssetTrack *track = [[asset tracksWithMediaType:AVMediaTypeVideo]firstObject];\n    AVAssetReader *assetReader = [[AVAssetReader alloc] initWithAsset:asset error:nil];\n    NSDictionary *readerOutputSettings = @{\n                                           (id)kCVPixelBufferPixelFormatTypeKey : @(kCVPixelFormatType_32BGRA)\n                                           };\n    AVAssetReaderOutput *trackOutput = [[AVAssetReaderTrackOutput alloc] initWithTrack:track outputSettings:readerOutputSettings];\n    [assetReader addOutput:trackOutput];\n    [assetReader startReading];\n```\n\n写资源\n```\nNSURL *outputURL = ...;\n    AVAssetWriter *assetWriter = [[AVAssetWriter alloc] initWithURL:outputURL fileType:AVFileTypeQuickTimeMovie error:nil];\n    NSDictionary *writerOutputSettings = @{\n                                           AVVideoCodecKey : AVVideoCodecH264,\n                                           AVVideoWidthKey : @1280,\n                                           AVVideoHeightKey : @720,\n                                           AVVideoCompressionPropertiesKey : @{\n                                                   AVVideoMaxKeyFrameIntervalKey : @1,\n                                                   AVVideoAverageBitRateKey : @10500000,\n                                                   AVVideoProfileLevelKey : AVVideoProfileLevelH264Main31\n                                                   }\n                                           };\n    AVAssetWriterInput *writerInput = [[AVAssetWriterInput alloc] initWithMediaType:AVMediaTypeVideo outputSettings:writerOutputSettings];\n    [assetWriter addInput:writerInput];\n    [assetWriter startWriting];\n```\n\n从AVAssetReader拉取数据写入到文件\n```\ndispatch_queue_t dispatchQueue = dispatch_queue_create(\"com.tapharmonic.writerQueue\", NULL);\n    [assetWriter startSessionAtSourceTime:kCMTimeZero];\n    [writerInput requestMediaDataWhenReadyOnQueue:dispatchQueue usingBlock:^{\n        BOOL complete = NO;\n        while ([writerInput isReadyForMoreMediaData] && !complete) {\n            CMSampleBufferRef sampleBuffer = [trackOutput copyNextSampleBuffer];\n            if (sampleBuffer) {\n                BOOL result = [writerInput appendSampleBuffer:sampleBuffer];\n                CFRelease(sampleBuffer);\n                complete = !result;\n            } else {\n                [writerInput markAsFinished];\n                complete = YES;\n            }\n        }\n        if (complete) {\n            [assetWriter finishWritingWithCompletionHandler:^{\n                AVAssetWriterStatus status = assetWriter.status;\n                if (status == AVAssetWriterStatusCompleted) {\n                    //Handle success case\n                } else {\n                    //Handle failure case\n                }\n            }];\n        }\n    }];\n```","slug":"AVFoundation学习笔记十二-AVAssetReader-AVAssetWriter","published":1,"updated":"2019-07-09T08:13:34.929Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyzlbt88000h0j66pkspezn2","content":"<p><img src=\"//www.cyrus.fun/2018/11/12/AVFoundation学习笔记十二-AVAssetReader-AVAssetWriter/read_write.png\" alt=\"\"></p>\n<h3 id=\"AVAssetReader\"><a href=\"#AVAssetReader\" class=\"headerlink\" title=\"AVAssetReader\"></a>AVAssetReader</h3><p>AVAsserReader用于从AVAsset实例中读取媒体样本。通常会配置一个或多个AVAssetReaderOutput实例，并通过copyNextSampleBuffer方法可以访问音频样本和视频帧。AVAssetReaderOutput是一个抽象类，不过框架定义了3个具本实例来从指定的AVAssetTrack中读取解码的媒体样本，从多音频轨道中读取混合输出，或者从多视频轨道中读取组合输出。一个资源读取器的内部通道都是以多线程的方式不断提取下一个可用样本的，这样可以在系统请求资源时最小化时延。</p>\n<h3 id=\"AVAssetWriter\"><a href=\"#AVAssetWriter\" class=\"headerlink\" title=\"AVAssetWriter\"></a>AVAssetWriter</h3><p>AVAssetWriter是AVAssetReader对应的兄弟类，它用于对资源进行编码并将其写入到容器文件中。它由一个或多个AVAssetWriterInput对象配置，用于附加将包含要写入容器的媒体样本的CMSampleBuffer对象。AVAssetWriterInput被配置为可以处理指定的媒体类型，比如音频或视频，并且附加在其后的样本会在最终输出时生成一个独立的AVAssetTrack.当使用一个配置了处理视频样本的AVAssetWriterInput时，开发者会经常用到一个专门的适配器对象AVAssetWriterInputPixelBufferAdaptor.这个类在附加被包装为CVPixelBuffer对象的视频样本时提供最优性能。<br>AVAssetWriter可用于实时操作和离线操作两种情况，不过对于每个场景都有不同的方法将样本buffer添加到写入对象的输入中：</p>\n<p><strong><em>实时</em></strong>：当处理实时资源时，比如从AVCaptureVideoDataOutput写入捕捉的样本时，AVAssetWriterInput应该令 expectsMediaDataInRealTime属性为YES来确保 readyForMoreMediaData值被正确计算。从实时资源写入数据优化了写入器，这样一来，与维持交错效果相比，快速写入样本具有更高的优先级。这一优化效果不错，视频和音频样本以大致相同的速率捕捉，传入数据自然交错。</p>\n<p><strong><em>离线</em></strong>： 当从离线资源读取媒体资源时，比如从AVAssetReader读取样本buffer，在附加样本前仍然需要观察写入的readyForMoreMediaData属性的状态，不过可以使用requestMediaDataWhenReadyOnQueue：usingBlock:方法控制数据的提供。传到这个方法中的代码会随写入器输入准备附加更多的样本而不断被调用，添加样本时开发者需要检索数据并从资源中找到下一个样本进行添加。</p>\n<p>读资源<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AVAsset *asset = ...;</span><br><span class=\"line\">    AVAssetTrack *track = [[asset tracksWithMediaType:AVMediaTypeVideo]firstObject];</span><br><span class=\"line\">    AVAssetReader *assetReader = [[AVAssetReader alloc] initWithAsset:asset error:nil];</span><br><span class=\"line\">    NSDictionary *readerOutputSettings = @&#123;</span><br><span class=\"line\">                                           (id)kCVPixelBufferPixelFormatTypeKey : @(kCVPixelFormatType_32BGRA)</span><br><span class=\"line\">                                           &#125;;</span><br><span class=\"line\">    AVAssetReaderOutput *trackOutput = [[AVAssetReaderTrackOutput alloc] initWithTrack:track outputSettings:readerOutputSettings];</span><br><span class=\"line\">    [assetReader addOutput:trackOutput];</span><br><span class=\"line\">    [assetReader startReading];</span><br></pre></td></tr></table></figure></p>\n<p>写资源<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSURL *outputURL = ...;</span><br><span class=\"line\">    AVAssetWriter *assetWriter = [[AVAssetWriter alloc] initWithURL:outputURL fileType:AVFileTypeQuickTimeMovie error:nil];</span><br><span class=\"line\">    NSDictionary *writerOutputSettings = @&#123;</span><br><span class=\"line\">                                           AVVideoCodecKey : AVVideoCodecH264,</span><br><span class=\"line\">                                           AVVideoWidthKey : @1280,</span><br><span class=\"line\">                                           AVVideoHeightKey : @720,</span><br><span class=\"line\">                                           AVVideoCompressionPropertiesKey : @&#123;</span><br><span class=\"line\">                                                   AVVideoMaxKeyFrameIntervalKey : @1,</span><br><span class=\"line\">                                                   AVVideoAverageBitRateKey : @10500000,</span><br><span class=\"line\">                                                   AVVideoProfileLevelKey : AVVideoProfileLevelH264Main31</span><br><span class=\"line\">                                                   &#125;</span><br><span class=\"line\">                                           &#125;;</span><br><span class=\"line\">    AVAssetWriterInput *writerInput = [[AVAssetWriterInput alloc] initWithMediaType:AVMediaTypeVideo outputSettings:writerOutputSettings];</span><br><span class=\"line\">    [assetWriter addInput:writerInput];</span><br><span class=\"line\">    [assetWriter startWriting];</span><br></pre></td></tr></table></figure></p>\n<p>从AVAssetReader拉取数据写入到文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_queue_t dispatchQueue = dispatch_queue_create(&quot;com.tapharmonic.writerQueue&quot;, NULL);</span><br><span class=\"line\">    [assetWriter startSessionAtSourceTime:kCMTimeZero];</span><br><span class=\"line\">    [writerInput requestMediaDataWhenReadyOnQueue:dispatchQueue usingBlock:^&#123;</span><br><span class=\"line\">        BOOL complete = NO;</span><br><span class=\"line\">        while ([writerInput isReadyForMoreMediaData] &amp;&amp; !complete) &#123;</span><br><span class=\"line\">            CMSampleBufferRef sampleBuffer = [trackOutput copyNextSampleBuffer];</span><br><span class=\"line\">            if (sampleBuffer) &#123;</span><br><span class=\"line\">                BOOL result = [writerInput appendSampleBuffer:sampleBuffer];</span><br><span class=\"line\">                CFRelease(sampleBuffer);</span><br><span class=\"line\">                complete = !result;</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                [writerInput markAsFinished];</span><br><span class=\"line\">                complete = YES;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (complete) &#123;</span><br><span class=\"line\">            [assetWriter finishWritingWithCompletionHandler:^&#123;</span><br><span class=\"line\">                AVAssetWriterStatus status = assetWriter.status;</span><br><span class=\"line\">                if (status == AVAssetWriterStatusCompleted) &#123;</span><br><span class=\"line\">                    //Handle success case</span><br><span class=\"line\">                &#125; else &#123;</span><br><span class=\"line\">                    //Handle failure case</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;];</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"//www.cyrus.fun/2018/11/12/AVFoundation学习笔记十二-AVAssetReader-AVAssetWriter/read_write.png\" alt=\"\"></p>\n<h3 id=\"AVAssetReader\"><a href=\"#AVAssetReader\" class=\"headerlink\" title=\"AVAssetReader\"></a>AVAssetReader</h3><p>AVAsserReader用于从AVAsset实例中读取媒体样本。通常会配置一个或多个AVAssetReaderOutput实例，并通过copyNextSampleBuffer方法可以访问音频样本和视频帧。AVAssetReaderOutput是一个抽象类，不过框架定义了3个具本实例来从指定的AVAssetTrack中读取解码的媒体样本，从多音频轨道中读取混合输出，或者从多视频轨道中读取组合输出。一个资源读取器的内部通道都是以多线程的方式不断提取下一个可用样本的，这样可以在系统请求资源时最小化时延。</p>\n<h3 id=\"AVAssetWriter\"><a href=\"#AVAssetWriter\" class=\"headerlink\" title=\"AVAssetWriter\"></a>AVAssetWriter</h3><p>AVAssetWriter是AVAssetReader对应的兄弟类，它用于对资源进行编码并将其写入到容器文件中。它由一个或多个AVAssetWriterInput对象配置，用于附加将包含要写入容器的媒体样本的CMSampleBuffer对象。AVAssetWriterInput被配置为可以处理指定的媒体类型，比如音频或视频，并且附加在其后的样本会在最终输出时生成一个独立的AVAssetTrack.当使用一个配置了处理视频样本的AVAssetWriterInput时，开发者会经常用到一个专门的适配器对象AVAssetWriterInputPixelBufferAdaptor.这个类在附加被包装为CVPixelBuffer对象的视频样本时提供最优性能。<br>AVAssetWriter可用于实时操作和离线操作两种情况，不过对于每个场景都有不同的方法将样本buffer添加到写入对象的输入中：</p>\n<p><strong><em>实时</em></strong>：当处理实时资源时，比如从AVCaptureVideoDataOutput写入捕捉的样本时，AVAssetWriterInput应该令 expectsMediaDataInRealTime属性为YES来确保 readyForMoreMediaData值被正确计算。从实时资源写入数据优化了写入器，这样一来，与维持交错效果相比，快速写入样本具有更高的优先级。这一优化效果不错，视频和音频样本以大致相同的速率捕捉，传入数据自然交错。</p>\n<p><strong><em>离线</em></strong>： 当从离线资源读取媒体资源时，比如从AVAssetReader读取样本buffer，在附加样本前仍然需要观察写入的readyForMoreMediaData属性的状态，不过可以使用requestMediaDataWhenReadyOnQueue：usingBlock:方法控制数据的提供。传到这个方法中的代码会随写入器输入准备附加更多的样本而不断被调用，添加样本时开发者需要检索数据并从资源中找到下一个样本进行添加。</p>\n<p>读资源<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AVAsset *asset = ...;</span><br><span class=\"line\">    AVAssetTrack *track = [[asset tracksWithMediaType:AVMediaTypeVideo]firstObject];</span><br><span class=\"line\">    AVAssetReader *assetReader = [[AVAssetReader alloc] initWithAsset:asset error:nil];</span><br><span class=\"line\">    NSDictionary *readerOutputSettings = @&#123;</span><br><span class=\"line\">                                           (id)kCVPixelBufferPixelFormatTypeKey : @(kCVPixelFormatType_32BGRA)</span><br><span class=\"line\">                                           &#125;;</span><br><span class=\"line\">    AVAssetReaderOutput *trackOutput = [[AVAssetReaderTrackOutput alloc] initWithTrack:track outputSettings:readerOutputSettings];</span><br><span class=\"line\">    [assetReader addOutput:trackOutput];</span><br><span class=\"line\">    [assetReader startReading];</span><br></pre></td></tr></table></figure></p>\n<p>写资源<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSURL *outputURL = ...;</span><br><span class=\"line\">    AVAssetWriter *assetWriter = [[AVAssetWriter alloc] initWithURL:outputURL fileType:AVFileTypeQuickTimeMovie error:nil];</span><br><span class=\"line\">    NSDictionary *writerOutputSettings = @&#123;</span><br><span class=\"line\">                                           AVVideoCodecKey : AVVideoCodecH264,</span><br><span class=\"line\">                                           AVVideoWidthKey : @1280,</span><br><span class=\"line\">                                           AVVideoHeightKey : @720,</span><br><span class=\"line\">                                           AVVideoCompressionPropertiesKey : @&#123;</span><br><span class=\"line\">                                                   AVVideoMaxKeyFrameIntervalKey : @1,</span><br><span class=\"line\">                                                   AVVideoAverageBitRateKey : @10500000,</span><br><span class=\"line\">                                                   AVVideoProfileLevelKey : AVVideoProfileLevelH264Main31</span><br><span class=\"line\">                                                   &#125;</span><br><span class=\"line\">                                           &#125;;</span><br><span class=\"line\">    AVAssetWriterInput *writerInput = [[AVAssetWriterInput alloc] initWithMediaType:AVMediaTypeVideo outputSettings:writerOutputSettings];</span><br><span class=\"line\">    [assetWriter addInput:writerInput];</span><br><span class=\"line\">    [assetWriter startWriting];</span><br></pre></td></tr></table></figure></p>\n<p>从AVAssetReader拉取数据写入到文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_queue_t dispatchQueue = dispatch_queue_create(&quot;com.tapharmonic.writerQueue&quot;, NULL);</span><br><span class=\"line\">    [assetWriter startSessionAtSourceTime:kCMTimeZero];</span><br><span class=\"line\">    [writerInput requestMediaDataWhenReadyOnQueue:dispatchQueue usingBlock:^&#123;</span><br><span class=\"line\">        BOOL complete = NO;</span><br><span class=\"line\">        while ([writerInput isReadyForMoreMediaData] &amp;&amp; !complete) &#123;</span><br><span class=\"line\">            CMSampleBufferRef sampleBuffer = [trackOutput copyNextSampleBuffer];</span><br><span class=\"line\">            if (sampleBuffer) &#123;</span><br><span class=\"line\">                BOOL result = [writerInput appendSampleBuffer:sampleBuffer];</span><br><span class=\"line\">                CFRelease(sampleBuffer);</span><br><span class=\"line\">                complete = !result;</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                [writerInput markAsFinished];</span><br><span class=\"line\">                complete = YES;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (complete) &#123;</span><br><span class=\"line\">            [assetWriter finishWritingWithCompletionHandler:^&#123;</span><br><span class=\"line\">                AVAssetWriterStatus status = assetWriter.status;</span><br><span class=\"line\">                if (status == AVAssetWriterStatusCompleted) &#123;</span><br><span class=\"line\">                    //Handle success case</span><br><span class=\"line\">                &#125; else &#123;</span><br><span class=\"line\">                    //Handle failure case</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;];</span><br></pre></td></tr></table></figure></p>\n"},{"title":"H264 nalu类型及解析","author":"Cyrus","date":"2019-01-27T13:54:00.000Z","_content":"首先，先看两组数据：\n![](h264_data.png)\n\n上面的数据，就是h264的视频数据。H264结构中，一个视频图像编码后的数据叫做一帧，一帧由一个片（slice）或多个片组成，一个片由一个或多个宏块（MB）组成。\n\n#### 一、NAL\nNAL全称Network Abstract Layer，即网络抽象层。在H.264/AVC视频编码标准中，整个系统框架被分为了两个层面：视频编码层面（VCL）和网络抽象层面（NAL）。其中，前者负责有效表示视频数据的内容，而后者则负责格式化数据并提供头信息，以保证数据适合各种信道和存储介质上的传输。NAL单元是NAL的基本语法结构，它包含一个字节的头信息和一系列来自VCL的称为原始字节序列载荷（RBSP）的字节流。\n\n##### 1、帧格式\n\nH264在网络传输的是NALU，NALU的结构是：NAL头+RBSP，实际传输中的数据流如图所示：\n![](nalu_zc.png)\n\n##### 2、帧解析（参照开始数据红色部分）\n* 如果NALU对应的Slice为一帧的开始，则用4字节表示，即0x00 00 00 01;否则用3字节表示，0x00 00 01。\n* NAL Header:forbidden_bit （F）1bit （在 H.264 规范中规定了这一位必须为 0.）  nal_reference_bit(优先级 NRI)2bit，取00~11,似乎指示这个NALU的重要性,如00的NALU解码器可以丢弃它而不影响图像的回放,0～3，取值越大，表示当前NAL越重要，需要优先受到保护。如果当前NAL是属于参考帧的片，或是序列参数集，或是图像参数集这些重要的单位时，本句法元素必需大于0。nal_unit_type(类型)5bit,标识其中，nal_unit_type为1， 2， 3， 4， 5的NAL单元称为VCL的NAL单元，其他类型的NAL单元为非VCL的NAL单元。\n\nnal_unit_type. 这个NALU单元的类型,1～12由H.264使用，24～31由H.264以外的应用使用,简述如下:\n![](nalu_type_define.png)\n\n示例\n~~~\n00 00 00 01 67\n 帧开始\t | nal header\n \n 67 -->  0 1 1 0 0 1 1 1\n \t\t F|RNI| nal_unit_type\n 可以看出，此帧为优先级最高的SPS数据\n \n 同理\n 00 00 00 01 68  拥有最高优先级的PPS数据\n 00 00 00 01 06  拥有最低优先级的补充增强信息单元（SEI）\n 00 00 00 01 65  拥有最高优先级IDR图像中的片 （即I帧，关键帧）\n 00 00 00 01 61  拥有最高优先级非IDR图像的片（P/B帧)\n~~~\n\n#### 常见nal_unit_type 介绍\n\n* SPS(nal_unit_type=7)和PPS(nal_unit_type=8)包含了初始化H264解码器所需要的信息参数，包括编码所用的profile,level,图像的宽和高，deblock滤波器等。\n\n* I帧（nal_unit_type=5），帧内编码帧，I帧表示关键帧，可以理解为这一帧画面的完整保留，即拥有还原成图像所需的所有数据。\n* I帧特点：\n* 1、它是一个全帧压缩帧，将全帧图像信息进行JPEG压缩编码及传输；\n* 2、解码时仅用I帧的数据就可以重构完整图像\n* 3、I帧描述了图像背景和运动主体的详情。\n* 4、I帧不需要参考其他画面生成\n* 5、I帧是P帧和B帧的参考帧（其质量直接影响到同组中以后各帧的质量）\n* 6、I帧不需要考虑运动矢量\n* 7、I帧所占数据的信息量比较大\n\n* P帧（nal_unit_type=1），前向预测编码帧。P帧表示的是这一帧跟之前的一个关键帧（或P帧）的差别，解码时需要用之前缓存的画面叠加上本帧定义的差别，生成最终画面。（也就是差别帧，P帧没有完整画面数据，只有与前一帧的画面差别的数据）\n* P帧特点\n* 1、P帧是I帧后面相隔1~2帧的编码帧;\n* 2、P帧采用运动补偿的方法传送它与前面的I或P帧的差值及运动矢量(预测误差);\n* 3、解码时必须将I帧中的预测值与预测误差求和后才能重构完整的P帧图像;\n* 4、P帧属于前向预测的帧间编码。它只参考前面最靠近它的I帧或P帧;\n* 5、P帧可以是其后面P帧的参考帧,也可以是其前后的B帧的参考帧;\n* 6、由于P帧是参考帧,它可能造成解码错误的扩散;\n* 7、由于是差值传送,P帧的压缩比较高。\n\n* B帧（nal_unit_type=1），双向预测内插编码帧。B帧是双向差别帧，也就是B帧记录的是本帧与前后帧的差别，换言之，要解码B帧，不仅要取得之前的缓存画面，还要解码之后的画面，通过前后画面的与本帧数据的叠加取得最终的画面。B帧压缩率高，但是解码时CPU会比较累。\n* B帧特点\n* 1、B帧是由前面的I或P帧和后面的P帧来进行预测的;\n* 2、B帧传送的是它与前面的I或P帧和后面的P帧之间的预测误差及运动矢量;\n* 3、B帧是双向预测编码帧;\n* 4、B帧压缩比最高,因为它只反映丙参考帧间运动主体的变化情况,预测比较准确;\n* 5、B帧不是参考帧,不会造成解码错误的扩散。\n\n\n<font color=ff0000>注:I、B、P各帧是根据压缩算法的需要，是人为定义的,它们都是实实在在的物理帧。一般来说，I帧的压缩率是7（跟JPG差不多），P帧是20，B帧可以达到50。可见使用B帧能节省大量空间，节省出来的空间可以用来保存多一些I帧，这样在相同码率下，可以提供更好的画质。</font>\n","source":"_posts/H264-nalu类型及解析.md","raw":"title: H264 nalu类型及解析\nauthor: Cyrus\ntags: []\ncategories:\n  - 音视频\ndate: 2019-01-27 21:54:00\n---\n首先，先看两组数据：\n![](h264_data.png)\n\n上面的数据，就是h264的视频数据。H264结构中，一个视频图像编码后的数据叫做一帧，一帧由一个片（slice）或多个片组成，一个片由一个或多个宏块（MB）组成。\n\n#### 一、NAL\nNAL全称Network Abstract Layer，即网络抽象层。在H.264/AVC视频编码标准中，整个系统框架被分为了两个层面：视频编码层面（VCL）和网络抽象层面（NAL）。其中，前者负责有效表示视频数据的内容，而后者则负责格式化数据并提供头信息，以保证数据适合各种信道和存储介质上的传输。NAL单元是NAL的基本语法结构，它包含一个字节的头信息和一系列来自VCL的称为原始字节序列载荷（RBSP）的字节流。\n\n##### 1、帧格式\n\nH264在网络传输的是NALU，NALU的结构是：NAL头+RBSP，实际传输中的数据流如图所示：\n![](nalu_zc.png)\n\n##### 2、帧解析（参照开始数据红色部分）\n* 如果NALU对应的Slice为一帧的开始，则用4字节表示，即0x00 00 00 01;否则用3字节表示，0x00 00 01。\n* NAL Header:forbidden_bit （F）1bit （在 H.264 规范中规定了这一位必须为 0.）  nal_reference_bit(优先级 NRI)2bit，取00~11,似乎指示这个NALU的重要性,如00的NALU解码器可以丢弃它而不影响图像的回放,0～3，取值越大，表示当前NAL越重要，需要优先受到保护。如果当前NAL是属于参考帧的片，或是序列参数集，或是图像参数集这些重要的单位时，本句法元素必需大于0。nal_unit_type(类型)5bit,标识其中，nal_unit_type为1， 2， 3， 4， 5的NAL单元称为VCL的NAL单元，其他类型的NAL单元为非VCL的NAL单元。\n\nnal_unit_type. 这个NALU单元的类型,1～12由H.264使用，24～31由H.264以外的应用使用,简述如下:\n![](nalu_type_define.png)\n\n示例\n~~~\n00 00 00 01 67\n 帧开始\t | nal header\n \n 67 -->  0 1 1 0 0 1 1 1\n \t\t F|RNI| nal_unit_type\n 可以看出，此帧为优先级最高的SPS数据\n \n 同理\n 00 00 00 01 68  拥有最高优先级的PPS数据\n 00 00 00 01 06  拥有最低优先级的补充增强信息单元（SEI）\n 00 00 00 01 65  拥有最高优先级IDR图像中的片 （即I帧，关键帧）\n 00 00 00 01 61  拥有最高优先级非IDR图像的片（P/B帧)\n~~~\n\n#### 常见nal_unit_type 介绍\n\n* SPS(nal_unit_type=7)和PPS(nal_unit_type=8)包含了初始化H264解码器所需要的信息参数，包括编码所用的profile,level,图像的宽和高，deblock滤波器等。\n\n* I帧（nal_unit_type=5），帧内编码帧，I帧表示关键帧，可以理解为这一帧画面的完整保留，即拥有还原成图像所需的所有数据。\n* I帧特点：\n* 1、它是一个全帧压缩帧，将全帧图像信息进行JPEG压缩编码及传输；\n* 2、解码时仅用I帧的数据就可以重构完整图像\n* 3、I帧描述了图像背景和运动主体的详情。\n* 4、I帧不需要参考其他画面生成\n* 5、I帧是P帧和B帧的参考帧（其质量直接影响到同组中以后各帧的质量）\n* 6、I帧不需要考虑运动矢量\n* 7、I帧所占数据的信息量比较大\n\n* P帧（nal_unit_type=1），前向预测编码帧。P帧表示的是这一帧跟之前的一个关键帧（或P帧）的差别，解码时需要用之前缓存的画面叠加上本帧定义的差别，生成最终画面。（也就是差别帧，P帧没有完整画面数据，只有与前一帧的画面差别的数据）\n* P帧特点\n* 1、P帧是I帧后面相隔1~2帧的编码帧;\n* 2、P帧采用运动补偿的方法传送它与前面的I或P帧的差值及运动矢量(预测误差);\n* 3、解码时必须将I帧中的预测值与预测误差求和后才能重构完整的P帧图像;\n* 4、P帧属于前向预测的帧间编码。它只参考前面最靠近它的I帧或P帧;\n* 5、P帧可以是其后面P帧的参考帧,也可以是其前后的B帧的参考帧;\n* 6、由于P帧是参考帧,它可能造成解码错误的扩散;\n* 7、由于是差值传送,P帧的压缩比较高。\n\n* B帧（nal_unit_type=1），双向预测内插编码帧。B帧是双向差别帧，也就是B帧记录的是本帧与前后帧的差别，换言之，要解码B帧，不仅要取得之前的缓存画面，还要解码之后的画面，通过前后画面的与本帧数据的叠加取得最终的画面。B帧压缩率高，但是解码时CPU会比较累。\n* B帧特点\n* 1、B帧是由前面的I或P帧和后面的P帧来进行预测的;\n* 2、B帧传送的是它与前面的I或P帧和后面的P帧之间的预测误差及运动矢量;\n* 3、B帧是双向预测编码帧;\n* 4、B帧压缩比最高,因为它只反映丙参考帧间运动主体的变化情况,预测比较准确;\n* 5、B帧不是参考帧,不会造成解码错误的扩散。\n\n\n<font color=ff0000>注:I、B、P各帧是根据压缩算法的需要，是人为定义的,它们都是实实在在的物理帧。一般来说，I帧的压缩率是7（跟JPG差不多），P帧是20，B帧可以达到50。可见使用B帧能节省大量空间，节省出来的空间可以用来保存多一些I帧，这样在相同码率下，可以提供更好的画质。</font>\n","slug":"H264-nalu类型及解析","published":1,"updated":"2019-07-09T08:13:34.930Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyzlbt89000j0j66l5g5ycy9","content":"<p>首先，先看两组数据：<br><img src=\"//www.cyrus.fun/2019/01/27/H264-nalu类型及解析/h264_data.png\" alt=\"\"></p>\n<p>上面的数据，就是h264的视频数据。H264结构中，一个视频图像编码后的数据叫做一帧，一帧由一个片（slice）或多个片组成，一个片由一个或多个宏块（MB）组成。</p>\n<h4 id=\"一、NAL\"><a href=\"#一、NAL\" class=\"headerlink\" title=\"一、NAL\"></a>一、NAL</h4><p>NAL全称Network Abstract Layer，即网络抽象层。在H.264/AVC视频编码标准中，整个系统框架被分为了两个层面：视频编码层面（VCL）和网络抽象层面（NAL）。其中，前者负责有效表示视频数据的内容，而后者则负责格式化数据并提供头信息，以保证数据适合各种信道和存储介质上的传输。NAL单元是NAL的基本语法结构，它包含一个字节的头信息和一系列来自VCL的称为原始字节序列载荷（RBSP）的字节流。</p>\n<h5 id=\"1、帧格式\"><a href=\"#1、帧格式\" class=\"headerlink\" title=\"1、帧格式\"></a>1、帧格式</h5><p>H264在网络传输的是NALU，NALU的结构是：NAL头+RBSP，实际传输中的数据流如图所示：<br><img src=\"//www.cyrus.fun/2019/01/27/H264-nalu类型及解析/nalu_zc.png\" alt=\"\"></p>\n<h5 id=\"2、帧解析（参照开始数据红色部分）\"><a href=\"#2、帧解析（参照开始数据红色部分）\" class=\"headerlink\" title=\"2、帧解析（参照开始数据红色部分）\"></a>2、帧解析（参照开始数据红色部分）</h5><ul>\n<li>如果NALU对应的Slice为一帧的开始，则用4字节表示，即0x00 00 00 01;否则用3字节表示，0x00 00 01。</li>\n<li>NAL Header:forbidden_bit （F）1bit （在 H.264 规范中规定了这一位必须为 0.）  nal_reference_bit(优先级 NRI)2bit，取00~11,似乎指示这个NALU的重要性,如00的NALU解码器可以丢弃它而不影响图像的回放,0～3，取值越大，表示当前NAL越重要，需要优先受到保护。如果当前NAL是属于参考帧的片，或是序列参数集，或是图像参数集这些重要的单位时，本句法元素必需大于0。nal_unit_type(类型)5bit,标识其中，nal_unit_type为1， 2， 3， 4， 5的NAL单元称为VCL的NAL单元，其他类型的NAL单元为非VCL的NAL单元。</li>\n</ul>\n<p>nal_unit_type. 这个NALU单元的类型,1～12由H.264使用，24～31由H.264以外的应用使用,简述如下:<br><img src=\"//www.cyrus.fun/2019/01/27/H264-nalu类型及解析/nalu_type_define.png\" alt=\"\"></p>\n<p>示例<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">00 00 00 01 67</span><br><span class=\"line\"> 帧开始\t | nal header</span><br><span class=\"line\"> </span><br><span class=\"line\"> 67 --&gt;  0 1 1 0 0 1 1 1</span><br><span class=\"line\"> \t\t F|RNI| nal_unit_type</span><br><span class=\"line\"> 可以看出，此帧为优先级最高的SPS数据</span><br><span class=\"line\"> </span><br><span class=\"line\"> 同理</span><br><span class=\"line\"> 00 00 00 01 68  拥有最高优先级的PPS数据</span><br><span class=\"line\"> 00 00 00 01 06  拥有最低优先级的补充增强信息单元（SEI）</span><br><span class=\"line\"> 00 00 00 01 65  拥有最高优先级IDR图像中的片 （即I帧，关键帧）</span><br><span class=\"line\"> 00 00 00 01 61  拥有最高优先级非IDR图像的片（P/B帧)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"常见nal-unit-type-介绍\"><a href=\"#常见nal-unit-type-介绍\" class=\"headerlink\" title=\"常见nal_unit_type 介绍\"></a>常见nal_unit_type 介绍</h4><ul>\n<li><p>SPS(nal_unit_type=7)和PPS(nal_unit_type=8)包含了初始化H264解码器所需要的信息参数，包括编码所用的profile,level,图像的宽和高，deblock滤波器等。</p>\n</li>\n<li><p>I帧（nal_unit_type=5），帧内编码帧，I帧表示关键帧，可以理解为这一帧画面的完整保留，即拥有还原成图像所需的所有数据。</p>\n</li>\n<li>I帧特点：</li>\n<li>1、它是一个全帧压缩帧，将全帧图像信息进行JPEG压缩编码及传输；</li>\n<li>2、解码时仅用I帧的数据就可以重构完整图像</li>\n<li>3、I帧描述了图像背景和运动主体的详情。</li>\n<li>4、I帧不需要参考其他画面生成</li>\n<li>5、I帧是P帧和B帧的参考帧（其质量直接影响到同组中以后各帧的质量）</li>\n<li>6、I帧不需要考虑运动矢量</li>\n<li><p>7、I帧所占数据的信息量比较大</p>\n</li>\n<li><p>P帧（nal_unit_type=1），前向预测编码帧。P帧表示的是这一帧跟之前的一个关键帧（或P帧）的差别，解码时需要用之前缓存的画面叠加上本帧定义的差别，生成最终画面。（也就是差别帧，P帧没有完整画面数据，只有与前一帧的画面差别的数据）</p>\n</li>\n<li>P帧特点</li>\n<li>1、P帧是I帧后面相隔1~2帧的编码帧;</li>\n<li>2、P帧采用运动补偿的方法传送它与前面的I或P帧的差值及运动矢量(预测误差);</li>\n<li>3、解码时必须将I帧中的预测值与预测误差求和后才能重构完整的P帧图像;</li>\n<li>4、P帧属于前向预测的帧间编码。它只参考前面最靠近它的I帧或P帧;</li>\n<li>5、P帧可以是其后面P帧的参考帧,也可以是其前后的B帧的参考帧;</li>\n<li>6、由于P帧是参考帧,它可能造成解码错误的扩散;</li>\n<li><p>7、由于是差值传送,P帧的压缩比较高。</p>\n</li>\n<li><p>B帧（nal_unit_type=1），双向预测内插编码帧。B帧是双向差别帧，也就是B帧记录的是本帧与前后帧的差别，换言之，要解码B帧，不仅要取得之前的缓存画面，还要解码之后的画面，通过前后画面的与本帧数据的叠加取得最终的画面。B帧压缩率高，但是解码时CPU会比较累。</p>\n</li>\n<li>B帧特点</li>\n<li>1、B帧是由前面的I或P帧和后面的P帧来进行预测的;</li>\n<li>2、B帧传送的是它与前面的I或P帧和后面的P帧之间的预测误差及运动矢量;</li>\n<li>3、B帧是双向预测编码帧;</li>\n<li>4、B帧压缩比最高,因为它只反映丙参考帧间运动主体的变化情况,预测比较准确;</li>\n<li>5、B帧不是参考帧,不会造成解码错误的扩散。</li>\n</ul>\n<font color=\"ff0000\">注:I、B、P各帧是根据压缩算法的需要，是人为定义的,它们都是实实在在的物理帧。一般来说，I帧的压缩率是7（跟JPG差不多），P帧是20，B帧可以达到50。可见使用B帧能节省大量空间，节省出来的空间可以用来保存多一些I帧，这样在相同码率下，可以提供更好的画质。</font>\n","site":{"data":{}},"excerpt":"","more":"<p>首先，先看两组数据：<br><img src=\"//www.cyrus.fun/2019/01/27/H264-nalu类型及解析/h264_data.png\" alt=\"\"></p>\n<p>上面的数据，就是h264的视频数据。H264结构中，一个视频图像编码后的数据叫做一帧，一帧由一个片（slice）或多个片组成，一个片由一个或多个宏块（MB）组成。</p>\n<h4 id=\"一、NAL\"><a href=\"#一、NAL\" class=\"headerlink\" title=\"一、NAL\"></a>一、NAL</h4><p>NAL全称Network Abstract Layer，即网络抽象层。在H.264/AVC视频编码标准中，整个系统框架被分为了两个层面：视频编码层面（VCL）和网络抽象层面（NAL）。其中，前者负责有效表示视频数据的内容，而后者则负责格式化数据并提供头信息，以保证数据适合各种信道和存储介质上的传输。NAL单元是NAL的基本语法结构，它包含一个字节的头信息和一系列来自VCL的称为原始字节序列载荷（RBSP）的字节流。</p>\n<h5 id=\"1、帧格式\"><a href=\"#1、帧格式\" class=\"headerlink\" title=\"1、帧格式\"></a>1、帧格式</h5><p>H264在网络传输的是NALU，NALU的结构是：NAL头+RBSP，实际传输中的数据流如图所示：<br><img src=\"//www.cyrus.fun/2019/01/27/H264-nalu类型及解析/nalu_zc.png\" alt=\"\"></p>\n<h5 id=\"2、帧解析（参照开始数据红色部分）\"><a href=\"#2、帧解析（参照开始数据红色部分）\" class=\"headerlink\" title=\"2、帧解析（参照开始数据红色部分）\"></a>2、帧解析（参照开始数据红色部分）</h5><ul>\n<li>如果NALU对应的Slice为一帧的开始，则用4字节表示，即0x00 00 00 01;否则用3字节表示，0x00 00 01。</li>\n<li>NAL Header:forbidden_bit （F）1bit （在 H.264 规范中规定了这一位必须为 0.）  nal_reference_bit(优先级 NRI)2bit，取00~11,似乎指示这个NALU的重要性,如00的NALU解码器可以丢弃它而不影响图像的回放,0～3，取值越大，表示当前NAL越重要，需要优先受到保护。如果当前NAL是属于参考帧的片，或是序列参数集，或是图像参数集这些重要的单位时，本句法元素必需大于0。nal_unit_type(类型)5bit,标识其中，nal_unit_type为1， 2， 3， 4， 5的NAL单元称为VCL的NAL单元，其他类型的NAL单元为非VCL的NAL单元。</li>\n</ul>\n<p>nal_unit_type. 这个NALU单元的类型,1～12由H.264使用，24～31由H.264以外的应用使用,简述如下:<br><img src=\"//www.cyrus.fun/2019/01/27/H264-nalu类型及解析/nalu_type_define.png\" alt=\"\"></p>\n<p>示例<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">00 00 00 01 67</span><br><span class=\"line\"> 帧开始\t | nal header</span><br><span class=\"line\"> </span><br><span class=\"line\"> 67 --&gt;  0 1 1 0 0 1 1 1</span><br><span class=\"line\"> \t\t F|RNI| nal_unit_type</span><br><span class=\"line\"> 可以看出，此帧为优先级最高的SPS数据</span><br><span class=\"line\"> </span><br><span class=\"line\"> 同理</span><br><span class=\"line\"> 00 00 00 01 68  拥有最高优先级的PPS数据</span><br><span class=\"line\"> 00 00 00 01 06  拥有最低优先级的补充增强信息单元（SEI）</span><br><span class=\"line\"> 00 00 00 01 65  拥有最高优先级IDR图像中的片 （即I帧，关键帧）</span><br><span class=\"line\"> 00 00 00 01 61  拥有最高优先级非IDR图像的片（P/B帧)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"常见nal-unit-type-介绍\"><a href=\"#常见nal-unit-type-介绍\" class=\"headerlink\" title=\"常见nal_unit_type 介绍\"></a>常见nal_unit_type 介绍</h4><ul>\n<li><p>SPS(nal_unit_type=7)和PPS(nal_unit_type=8)包含了初始化H264解码器所需要的信息参数，包括编码所用的profile,level,图像的宽和高，deblock滤波器等。</p>\n</li>\n<li><p>I帧（nal_unit_type=5），帧内编码帧，I帧表示关键帧，可以理解为这一帧画面的完整保留，即拥有还原成图像所需的所有数据。</p>\n</li>\n<li>I帧特点：</li>\n<li>1、它是一个全帧压缩帧，将全帧图像信息进行JPEG压缩编码及传输；</li>\n<li>2、解码时仅用I帧的数据就可以重构完整图像</li>\n<li>3、I帧描述了图像背景和运动主体的详情。</li>\n<li>4、I帧不需要参考其他画面生成</li>\n<li>5、I帧是P帧和B帧的参考帧（其质量直接影响到同组中以后各帧的质量）</li>\n<li>6、I帧不需要考虑运动矢量</li>\n<li><p>7、I帧所占数据的信息量比较大</p>\n</li>\n<li><p>P帧（nal_unit_type=1），前向预测编码帧。P帧表示的是这一帧跟之前的一个关键帧（或P帧）的差别，解码时需要用之前缓存的画面叠加上本帧定义的差别，生成最终画面。（也就是差别帧，P帧没有完整画面数据，只有与前一帧的画面差别的数据）</p>\n</li>\n<li>P帧特点</li>\n<li>1、P帧是I帧后面相隔1~2帧的编码帧;</li>\n<li>2、P帧采用运动补偿的方法传送它与前面的I或P帧的差值及运动矢量(预测误差);</li>\n<li>3、解码时必须将I帧中的预测值与预测误差求和后才能重构完整的P帧图像;</li>\n<li>4、P帧属于前向预测的帧间编码。它只参考前面最靠近它的I帧或P帧;</li>\n<li>5、P帧可以是其后面P帧的参考帧,也可以是其前后的B帧的参考帧;</li>\n<li>6、由于P帧是参考帧,它可能造成解码错误的扩散;</li>\n<li><p>7、由于是差值传送,P帧的压缩比较高。</p>\n</li>\n<li><p>B帧（nal_unit_type=1），双向预测内插编码帧。B帧是双向差别帧，也就是B帧记录的是本帧与前后帧的差别，换言之，要解码B帧，不仅要取得之前的缓存画面，还要解码之后的画面，通过前后画面的与本帧数据的叠加取得最终的画面。B帧压缩率高，但是解码时CPU会比较累。</p>\n</li>\n<li>B帧特点</li>\n<li>1、B帧是由前面的I或P帧和后面的P帧来进行预测的;</li>\n<li>2、B帧传送的是它与前面的I或P帧和后面的P帧之间的预测误差及运动矢量;</li>\n<li>3、B帧是双向预测编码帧;</li>\n<li>4、B帧压缩比最高,因为它只反映丙参考帧间运动主体的变化情况,预测比较准确;</li>\n<li>5、B帧不是参考帧,不会造成解码错误的扩散。</li>\n</ul>\n<font color=\"ff0000\">注:I、B、P各帧是根据压缩算法的需要，是人为定义的,它们都是实实在在的物理帧。一般来说，I帧的压缩率是7（跟JPG差不多），P帧是20，B帧可以达到50。可见使用B帧能节省大量空间，节省出来的空间可以用来保存多一些I帧，这样在相同码率下，可以提供更好的画质。</font>\n"},{"title":"QT基础1","author":"Cyrus","date":"2018-12-12T14:48:00.000Z","_content":"QT是一个跨平台的C++应用程序开发框架。支持Linux、Windows、Mac、iOS、Android等几乎所有的平台。\n详见维基百科[https://zh.wikipedia.org/wiki/Qt]\n\nF1:帮助文档，不熟悉QT的情况下，F1是最有用的快捷键了。\n\nQT创建应用程序时自带三种视图：\n\n1、QMainWindow: 用于PC端，带菜单栏\n\n2、QDialog: 对话框 \n\n3、QWidget: QT视图基类，相当于iOS的UIView\n一般可以选用QMainWindow或QWidget。\n\nQT文件结构\n![](qt_files.png)\n\n首先，看一下main文件\n```\n#include  “mywidget.h\"\n//应用程序类\n#include <QApplication>\n\nint main(int argc, char *argv[])\n{\n\t//有且只有一个应用程序类的对象，配置运行环境\n\tQApplication a(argc, argv);\n\t//创建窗口\n\tMyWidget w;\n\t//显示窗口\n\tw.show();\n\n\t//运行程序，死循环，等待事件发生，相当于iOS的 主线程runloop\n\t//思路与iOS的main函数相当，只是iOS是在AppDelegate中创建界面\n\treturn a.exec();\n\t}\n```\n\n.pro配置文件\n```\n#模块 头文件 f1 查找文档可以找到所有QT类需要添加的模块\nQT += core gui\n\n#高于4的版本，添加 QT += widgets, 为了兼容QT4\ngreaterThan(QT_MAJOR_VERSION, 4): QT += widgets\n\n#应用程序的名字\nTARGET = QtTest\n#指定makefile的类型， app/lib库\nTEMPLATE = app\n\n#使用C++11需要添加\nCONFIG += c++11\n\n#源文件，.cpp文件，创建类后自动添加\nSOURCES += \\\nmain.cpp \\\nmywidget.cpp\n\n#头文件 .h文件，创建类后自动添加\nHEADERS += \\\nmywidget.h\n```\n\n<font color=ff0000>这里，QT += 模块，可以在使用相关类时，在类名处按F1,进入帮助文档界面查找。</font>\n![](help_add_frame.png)\n\n最后，看一下代码创建控件\n```\n//mywidget.h\n\n#ifndef MYWIDGET_H\n#define MYWIDGET_H\n\n#include <QWidget>\n#include <QPushButton>\n\nclass MyWidget : public QWidget\n{\n    Q_OBJECT\npublic:\n    explicit MyWidget(QWidget *parent = nullptr);\n\nsignals:\n\npublic slots:\n    void mySlot();\n\nprivate:\n\t//非指针对象需要添加为成员变量\n    QPushButton btn;\n};\n\n#endif // MYWIDGET_H\n\n\n//mywidget.cpp\n#include \"mywidget.h\"\n#include <QLabel>\n\n\nMyWidget::MyWidget(QWidget *parent) : QWidget(parent)\n{\n\t//指针变量，用new创建\n    QLabel *lb = new QLabel(this);\n    //设置内容\n    lb->setText(QString(\"hello world\"));\n\n\t//成员变量\n    btn.setParent(this);\n    btn.setText(\"hehe\");\n    btn.move(50, 50);\n\n\t//错误的创建方法,为局部变量，父视图没有强引用控件，不显示\n    QLabel lb(this);\n    //设置内容\n    lb.setText(QString(\"hello world\"));\n}\n```\n\n","source":"_posts/QT基础1.md","raw":"title: QT基础1\nauthor: Cyrus\ntags: []\ncategories:\n  - QT\ndate: 2018-12-12 22:48:00\n---\nQT是一个跨平台的C++应用程序开发框架。支持Linux、Windows、Mac、iOS、Android等几乎所有的平台。\n详见维基百科[https://zh.wikipedia.org/wiki/Qt]\n\nF1:帮助文档，不熟悉QT的情况下，F1是最有用的快捷键了。\n\nQT创建应用程序时自带三种视图：\n\n1、QMainWindow: 用于PC端，带菜单栏\n\n2、QDialog: 对话框 \n\n3、QWidget: QT视图基类，相当于iOS的UIView\n一般可以选用QMainWindow或QWidget。\n\nQT文件结构\n![](qt_files.png)\n\n首先，看一下main文件\n```\n#include  “mywidget.h\"\n//应用程序类\n#include <QApplication>\n\nint main(int argc, char *argv[])\n{\n\t//有且只有一个应用程序类的对象，配置运行环境\n\tQApplication a(argc, argv);\n\t//创建窗口\n\tMyWidget w;\n\t//显示窗口\n\tw.show();\n\n\t//运行程序，死循环，等待事件发生，相当于iOS的 主线程runloop\n\t//思路与iOS的main函数相当，只是iOS是在AppDelegate中创建界面\n\treturn a.exec();\n\t}\n```\n\n.pro配置文件\n```\n#模块 头文件 f1 查找文档可以找到所有QT类需要添加的模块\nQT += core gui\n\n#高于4的版本，添加 QT += widgets, 为了兼容QT4\ngreaterThan(QT_MAJOR_VERSION, 4): QT += widgets\n\n#应用程序的名字\nTARGET = QtTest\n#指定makefile的类型， app/lib库\nTEMPLATE = app\n\n#使用C++11需要添加\nCONFIG += c++11\n\n#源文件，.cpp文件，创建类后自动添加\nSOURCES += \\\nmain.cpp \\\nmywidget.cpp\n\n#头文件 .h文件，创建类后自动添加\nHEADERS += \\\nmywidget.h\n```\n\n<font color=ff0000>这里，QT += 模块，可以在使用相关类时，在类名处按F1,进入帮助文档界面查找。</font>\n![](help_add_frame.png)\n\n最后，看一下代码创建控件\n```\n//mywidget.h\n\n#ifndef MYWIDGET_H\n#define MYWIDGET_H\n\n#include <QWidget>\n#include <QPushButton>\n\nclass MyWidget : public QWidget\n{\n    Q_OBJECT\npublic:\n    explicit MyWidget(QWidget *parent = nullptr);\n\nsignals:\n\npublic slots:\n    void mySlot();\n\nprivate:\n\t//非指针对象需要添加为成员变量\n    QPushButton btn;\n};\n\n#endif // MYWIDGET_H\n\n\n//mywidget.cpp\n#include \"mywidget.h\"\n#include <QLabel>\n\n\nMyWidget::MyWidget(QWidget *parent) : QWidget(parent)\n{\n\t//指针变量，用new创建\n    QLabel *lb = new QLabel(this);\n    //设置内容\n    lb->setText(QString(\"hello world\"));\n\n\t//成员变量\n    btn.setParent(this);\n    btn.setText(\"hehe\");\n    btn.move(50, 50);\n\n\t//错误的创建方法,为局部变量，父视图没有强引用控件，不显示\n    QLabel lb(this);\n    //设置内容\n    lb.setText(QString(\"hello world\"));\n}\n```\n\n","slug":"QT基础1","published":1,"updated":"2019-07-09T08:13:34.936Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyzlbt8b000l0j66nb7jm83i","content":"<p>QT是一个跨平台的C++应用程序开发框架。支持Linux、Windows、Mac、iOS、Android等几乎所有的平台。<br>详见维基百科[<a href=\"https://zh.wikipedia.org/wiki/Qt]\" target=\"_blank\" rel=\"noopener\">https://zh.wikipedia.org/wiki/Qt]</a></p>\n<p>F1:帮助文档，不熟悉QT的情况下，F1是最有用的快捷键了。</p>\n<p>QT创建应用程序时自带三种视图：</p>\n<p>1、QMainWindow: 用于PC端，带菜单栏</p>\n<p>2、QDialog: 对话框 </p>\n<p>3、QWidget: QT视图基类，相当于iOS的UIView<br>一般可以选用QMainWindow或QWidget。</p>\n<p>QT文件结构<br><img src=\"//www.cyrus.fun/2018/12/12/QT基础1/qt_files.png\" alt=\"\"></p>\n<p>首先，看一下main文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include  “mywidget.h&quot;</span><br><span class=\"line\">//应用程序类</span><br><span class=\"line\">#include &lt;QApplication&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, char *argv[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t//有且只有一个应用程序类的对象，配置运行环境</span><br><span class=\"line\">\tQApplication a(argc, argv);</span><br><span class=\"line\">\t//创建窗口</span><br><span class=\"line\">\tMyWidget w;</span><br><span class=\"line\">\t//显示窗口</span><br><span class=\"line\">\tw.show();</span><br><span class=\"line\"></span><br><span class=\"line\">\t//运行程序，死循环，等待事件发生，相当于iOS的 主线程runloop</span><br><span class=\"line\">\t//思路与iOS的main函数相当，只是iOS是在AppDelegate中创建界面</span><br><span class=\"line\">\treturn a.exec();</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure></p>\n<p>.pro配置文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#模块 头文件 f1 查找文档可以找到所有QT类需要添加的模块</span><br><span class=\"line\">QT += core gui</span><br><span class=\"line\"></span><br><span class=\"line\">#高于4的版本，添加 QT += widgets, 为了兼容QT4</span><br><span class=\"line\">greaterThan(QT_MAJOR_VERSION, 4): QT += widgets</span><br><span class=\"line\"></span><br><span class=\"line\">#应用程序的名字</span><br><span class=\"line\">TARGET = QtTest</span><br><span class=\"line\">#指定makefile的类型， app/lib库</span><br><span class=\"line\">TEMPLATE = app</span><br><span class=\"line\"></span><br><span class=\"line\">#使用C++11需要添加</span><br><span class=\"line\">CONFIG += c++11</span><br><span class=\"line\"></span><br><span class=\"line\">#源文件，.cpp文件，创建类后自动添加</span><br><span class=\"line\">SOURCES += \\</span><br><span class=\"line\">main.cpp \\</span><br><span class=\"line\">mywidget.cpp</span><br><span class=\"line\"></span><br><span class=\"line\">#头文件 .h文件，创建类后自动添加</span><br><span class=\"line\">HEADERS += \\</span><br><span class=\"line\">mywidget.h</span><br></pre></td></tr></table></figure></p>\n<p><font color=\"ff0000\">这里，QT += 模块，可以在使用相关类时，在类名处按F1,进入帮助文档界面查找。</font><br><img src=\"//www.cyrus.fun/2018/12/12/QT基础1/help_add_frame.png\" alt=\"\"></p>\n<p>最后，看一下代码创建控件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//mywidget.h</span><br><span class=\"line\"></span><br><span class=\"line\">#ifndef MYWIDGET_H</span><br><span class=\"line\">#define MYWIDGET_H</span><br><span class=\"line\"></span><br><span class=\"line\">#include &lt;QWidget&gt;</span><br><span class=\"line\">#include &lt;QPushButton&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">class MyWidget : public QWidget</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Q_OBJECT</span><br><span class=\"line\">public:</span><br><span class=\"line\">    explicit MyWidget(QWidget *parent = nullptr);</span><br><span class=\"line\"></span><br><span class=\"line\">signals:</span><br><span class=\"line\"></span><br><span class=\"line\">public slots:</span><br><span class=\"line\">    void mySlot();</span><br><span class=\"line\"></span><br><span class=\"line\">private:</span><br><span class=\"line\">\t//非指针对象需要添加为成员变量</span><br><span class=\"line\">    QPushButton btn;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">#endif // MYWIDGET_H</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//mywidget.cpp</span><br><span class=\"line\">#include &quot;mywidget.h&quot;</span><br><span class=\"line\">#include &lt;QLabel&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">MyWidget::MyWidget(QWidget *parent) : QWidget(parent)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t//指针变量，用new创建</span><br><span class=\"line\">    QLabel *lb = new QLabel(this);</span><br><span class=\"line\">    //设置内容</span><br><span class=\"line\">    lb-&gt;setText(QString(&quot;hello world&quot;));</span><br><span class=\"line\"></span><br><span class=\"line\">\t//成员变量</span><br><span class=\"line\">    btn.setParent(this);</span><br><span class=\"line\">    btn.setText(&quot;hehe&quot;);</span><br><span class=\"line\">    btn.move(50, 50);</span><br><span class=\"line\"></span><br><span class=\"line\">\t//错误的创建方法,为局部变量，父视图没有强引用控件，不显示</span><br><span class=\"line\">    QLabel lb(this);</span><br><span class=\"line\">    //设置内容</span><br><span class=\"line\">    lb.setText(QString(&quot;hello world&quot;));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>QT是一个跨平台的C++应用程序开发框架。支持Linux、Windows、Mac、iOS、Android等几乎所有的平台。<br>详见维基百科[<a href=\"https://zh.wikipedia.org/wiki/Qt]\" target=\"_blank\" rel=\"noopener\">https://zh.wikipedia.org/wiki/Qt]</a></p>\n<p>F1:帮助文档，不熟悉QT的情况下，F1是最有用的快捷键了。</p>\n<p>QT创建应用程序时自带三种视图：</p>\n<p>1、QMainWindow: 用于PC端，带菜单栏</p>\n<p>2、QDialog: 对话框 </p>\n<p>3、QWidget: QT视图基类，相当于iOS的UIView<br>一般可以选用QMainWindow或QWidget。</p>\n<p>QT文件结构<br><img src=\"//www.cyrus.fun/2018/12/12/QT基础1/qt_files.png\" alt=\"\"></p>\n<p>首先，看一下main文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include  “mywidget.h&quot;</span><br><span class=\"line\">//应用程序类</span><br><span class=\"line\">#include &lt;QApplication&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, char *argv[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t//有且只有一个应用程序类的对象，配置运行环境</span><br><span class=\"line\">\tQApplication a(argc, argv);</span><br><span class=\"line\">\t//创建窗口</span><br><span class=\"line\">\tMyWidget w;</span><br><span class=\"line\">\t//显示窗口</span><br><span class=\"line\">\tw.show();</span><br><span class=\"line\"></span><br><span class=\"line\">\t//运行程序，死循环，等待事件发生，相当于iOS的 主线程runloop</span><br><span class=\"line\">\t//思路与iOS的main函数相当，只是iOS是在AppDelegate中创建界面</span><br><span class=\"line\">\treturn a.exec();</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure></p>\n<p>.pro配置文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#模块 头文件 f1 查找文档可以找到所有QT类需要添加的模块</span><br><span class=\"line\">QT += core gui</span><br><span class=\"line\"></span><br><span class=\"line\">#高于4的版本，添加 QT += widgets, 为了兼容QT4</span><br><span class=\"line\">greaterThan(QT_MAJOR_VERSION, 4): QT += widgets</span><br><span class=\"line\"></span><br><span class=\"line\">#应用程序的名字</span><br><span class=\"line\">TARGET = QtTest</span><br><span class=\"line\">#指定makefile的类型， app/lib库</span><br><span class=\"line\">TEMPLATE = app</span><br><span class=\"line\"></span><br><span class=\"line\">#使用C++11需要添加</span><br><span class=\"line\">CONFIG += c++11</span><br><span class=\"line\"></span><br><span class=\"line\">#源文件，.cpp文件，创建类后自动添加</span><br><span class=\"line\">SOURCES += \\</span><br><span class=\"line\">main.cpp \\</span><br><span class=\"line\">mywidget.cpp</span><br><span class=\"line\"></span><br><span class=\"line\">#头文件 .h文件，创建类后自动添加</span><br><span class=\"line\">HEADERS += \\</span><br><span class=\"line\">mywidget.h</span><br></pre></td></tr></table></figure></p>\n<p><font color=\"ff0000\">这里，QT += 模块，可以在使用相关类时，在类名处按F1,进入帮助文档界面查找。</font><br><img src=\"//www.cyrus.fun/2018/12/12/QT基础1/help_add_frame.png\" alt=\"\"></p>\n<p>最后，看一下代码创建控件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//mywidget.h</span><br><span class=\"line\"></span><br><span class=\"line\">#ifndef MYWIDGET_H</span><br><span class=\"line\">#define MYWIDGET_H</span><br><span class=\"line\"></span><br><span class=\"line\">#include &lt;QWidget&gt;</span><br><span class=\"line\">#include &lt;QPushButton&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">class MyWidget : public QWidget</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Q_OBJECT</span><br><span class=\"line\">public:</span><br><span class=\"line\">    explicit MyWidget(QWidget *parent = nullptr);</span><br><span class=\"line\"></span><br><span class=\"line\">signals:</span><br><span class=\"line\"></span><br><span class=\"line\">public slots:</span><br><span class=\"line\">    void mySlot();</span><br><span class=\"line\"></span><br><span class=\"line\">private:</span><br><span class=\"line\">\t//非指针对象需要添加为成员变量</span><br><span class=\"line\">    QPushButton btn;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">#endif // MYWIDGET_H</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//mywidget.cpp</span><br><span class=\"line\">#include &quot;mywidget.h&quot;</span><br><span class=\"line\">#include &lt;QLabel&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">MyWidget::MyWidget(QWidget *parent) : QWidget(parent)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t//指针变量，用new创建</span><br><span class=\"line\">    QLabel *lb = new QLabel(this);</span><br><span class=\"line\">    //设置内容</span><br><span class=\"line\">    lb-&gt;setText(QString(&quot;hello world&quot;));</span><br><span class=\"line\"></span><br><span class=\"line\">\t//成员变量</span><br><span class=\"line\">    btn.setParent(this);</span><br><span class=\"line\">    btn.setText(&quot;hehe&quot;);</span><br><span class=\"line\">    btn.move(50, 50);</span><br><span class=\"line\"></span><br><span class=\"line\">\t//错误的创建方法,为局部变量，父视图没有强引用控件，不显示</span><br><span class=\"line\">    QLabel lb(this);</span><br><span class=\"line\">    //设置内容</span><br><span class=\"line\">    lb.setText(QString(&quot;hello world&quot;));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"H264 profile类型、特点及解析","author":"Cyrus","date":"2019-01-24T15:14:00.000Z","_content":"#### 一、profile的几种类型\nH264 主要包括Baseline,  Ext，Main, High这几种常用profile和一些特殊用途的profies，如Constrain baseline， SVC，MVC和一系列high-Fidelity profiles 等等，各种profile是根据不同的应用场景设计的，具体余下：\n* Baseline主要是用于可视电话，会议电视，无线通讯等实时通信。要实时，就要减少视频decode和display的时延，所以没有B frame；为了提高针对网络丢包的容错能力，特意添加了FMO，ASO和冗余slice；\n* Main用于数字广播电视和数字视频存储，侧重点在于提高压缩率，所以有了CABAC，MBAFF，Interlace，B frame等。\n* Extend用于改进误码性能和码流切换（SP和SI slice），侧重于码流切换（SI，SP slice）和error resilience（数据分割）。\n*  High主要用于高压缩效率和质量， 引入8x8 DCT，选择量化矩阵等。\n\n各个不同profile的具体feature对比如下：\n![](profile_feather.png)\n\n#### 二、解码过程中profile的解析\nprofile参数存放在SPS之中，在做视频播放器时，为了让后续的解码过程可以使用SPS中包含的参数，必须对其中的数据进行解析。其中H.264标准协议中规定的SPS格式位于文档的7.3.2.1.1部分，如下图所示：\n![](profile_decode.png)\n\n各种类型的profile在SPS对应的profile_idc为：\n* <font color=#ff0000>baseline</font>:  profile_idc = 66 or constraint_set0_flag = 1\n* <font color=#ff0000>constrain baseline</font>: profile_idc = 66 && constraint_set1_flag = 1\n* <font color=#ff0000>main profile</font>: profile_idc = 77  or  constraint_set1_flag = 1\n* <font color=#ff0000>extend profile</font>: profile_idc = 88 or constraint_set2_flag = 1\n* <font color=#ff0000>high profile</font>: profile_idc = 100\n* <font color=#ff0000>High 10</font>: profile_idc = 110\n* <font color=#ff0000>High 422</font>: profile_idc = 122\n* <font color=#ff0000>High 444</font>: profile_idc = 244\n* <font color=#ff0000>Multiview</font>: profile_idc = 118\n* <font color=#ff0000>Stereo Hight</font>: profile_idc = 128\n\nReference：\n* https://blog.csdn.net/lixiaowei16/article/details/22370217\n* https://www.cnblogs.com/wainiwann/p/7477794.html","source":"_posts/H264-profile类型及特点.md","raw":"title: H264 profile类型、特点及解析\nauthor: Cyrus\ntags: []\ncategories:\n  - 音视频\ndate: 2019-01-24 23:14:00\n---\n#### 一、profile的几种类型\nH264 主要包括Baseline,  Ext，Main, High这几种常用profile和一些特殊用途的profies，如Constrain baseline， SVC，MVC和一系列high-Fidelity profiles 等等，各种profile是根据不同的应用场景设计的，具体余下：\n* Baseline主要是用于可视电话，会议电视，无线通讯等实时通信。要实时，就要减少视频decode和display的时延，所以没有B frame；为了提高针对网络丢包的容错能力，特意添加了FMO，ASO和冗余slice；\n* Main用于数字广播电视和数字视频存储，侧重点在于提高压缩率，所以有了CABAC，MBAFF，Interlace，B frame等。\n* Extend用于改进误码性能和码流切换（SP和SI slice），侧重于码流切换（SI，SP slice）和error resilience（数据分割）。\n*  High主要用于高压缩效率和质量， 引入8x8 DCT，选择量化矩阵等。\n\n各个不同profile的具体feature对比如下：\n![](profile_feather.png)\n\n#### 二、解码过程中profile的解析\nprofile参数存放在SPS之中，在做视频播放器时，为了让后续的解码过程可以使用SPS中包含的参数，必须对其中的数据进行解析。其中H.264标准协议中规定的SPS格式位于文档的7.3.2.1.1部分，如下图所示：\n![](profile_decode.png)\n\n各种类型的profile在SPS对应的profile_idc为：\n* <font color=#ff0000>baseline</font>:  profile_idc = 66 or constraint_set0_flag = 1\n* <font color=#ff0000>constrain baseline</font>: profile_idc = 66 && constraint_set1_flag = 1\n* <font color=#ff0000>main profile</font>: profile_idc = 77  or  constraint_set1_flag = 1\n* <font color=#ff0000>extend profile</font>: profile_idc = 88 or constraint_set2_flag = 1\n* <font color=#ff0000>high profile</font>: profile_idc = 100\n* <font color=#ff0000>High 10</font>: profile_idc = 110\n* <font color=#ff0000>High 422</font>: profile_idc = 122\n* <font color=#ff0000>High 444</font>: profile_idc = 244\n* <font color=#ff0000>Multiview</font>: profile_idc = 118\n* <font color=#ff0000>Stereo Hight</font>: profile_idc = 128\n\nReference：\n* https://blog.csdn.net/lixiaowei16/article/details/22370217\n* https://www.cnblogs.com/wainiwann/p/7477794.html","slug":"H264-profile类型及特点","published":1,"updated":"2019-07-09T08:13:34.933Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyzlbt8c000o0j66vnitzvxu","content":"<h4 id=\"一、profile的几种类型\"><a href=\"#一、profile的几种类型\" class=\"headerlink\" title=\"一、profile的几种类型\"></a>一、profile的几种类型</h4><p>H264 主要包括Baseline,  Ext，Main, High这几种常用profile和一些特殊用途的profies，如Constrain baseline， SVC，MVC和一系列high-Fidelity profiles 等等，各种profile是根据不同的应用场景设计的，具体余下：</p>\n<ul>\n<li>Baseline主要是用于可视电话，会议电视，无线通讯等实时通信。要实时，就要减少视频decode和display的时延，所以没有B frame；为了提高针对网络丢包的容错能力，特意添加了FMO，ASO和冗余slice；</li>\n<li>Main用于数字广播电视和数字视频存储，侧重点在于提高压缩率，所以有了CABAC，MBAFF，Interlace，B frame等。</li>\n<li>Extend用于改进误码性能和码流切换（SP和SI slice），侧重于码流切换（SI，SP slice）和error resilience（数据分割）。</li>\n<li>High主要用于高压缩效率和质量， 引入8x8 DCT，选择量化矩阵等。</li>\n</ul>\n<p>各个不同profile的具体feature对比如下：<br><img src=\"//www.cyrus.fun/2019/01/24/H264-profile类型及特点/profile_feather.png\" alt=\"\"></p>\n<h4 id=\"二、解码过程中profile的解析\"><a href=\"#二、解码过程中profile的解析\" class=\"headerlink\" title=\"二、解码过程中profile的解析\"></a>二、解码过程中profile的解析</h4><p>profile参数存放在SPS之中，在做视频播放器时，为了让后续的解码过程可以使用SPS中包含的参数，必须对其中的数据进行解析。其中H.264标准协议中规定的SPS格式位于文档的7.3.2.1.1部分，如下图所示：<br><img src=\"//www.cyrus.fun/2019/01/24/H264-profile类型及特点/profile_decode.png\" alt=\"\"></p>\n<p>各种类型的profile在SPS对应的profile_idc为：</p>\n<ul>\n<li><font color=\"#ff0000\">baseline</font>:  profile_idc = 66 or constraint_set0_flag = 1</li>\n<li><font color=\"#ff0000\">constrain baseline</font>: profile_idc = 66 &amp;&amp; constraint_set1_flag = 1</li>\n<li><font color=\"#ff0000\">main profile</font>: profile_idc = 77  or  constraint_set1_flag = 1</li>\n<li><font color=\"#ff0000\">extend profile</font>: profile_idc = 88 or constraint_set2_flag = 1</li>\n<li><font color=\"#ff0000\">high profile</font>: profile_idc = 100</li>\n<li><font color=\"#ff0000\">High 10</font>: profile_idc = 110</li>\n<li><font color=\"#ff0000\">High 422</font>: profile_idc = 122</li>\n<li><font color=\"#ff0000\">High 444</font>: profile_idc = 244</li>\n<li><font color=\"#ff0000\">Multiview</font>: profile_idc = 118</li>\n<li><font color=\"#ff0000\">Stereo Hight</font>: profile_idc = 128</li>\n</ul>\n<p>Reference：</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/lixiaowei16/article/details/22370217\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/lixiaowei16/article/details/22370217</a></li>\n<li><a href=\"https://www.cnblogs.com/wainiwann/p/7477794.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/wainiwann/p/7477794.html</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"一、profile的几种类型\"><a href=\"#一、profile的几种类型\" class=\"headerlink\" title=\"一、profile的几种类型\"></a>一、profile的几种类型</h4><p>H264 主要包括Baseline,  Ext，Main, High这几种常用profile和一些特殊用途的profies，如Constrain baseline， SVC，MVC和一系列high-Fidelity profiles 等等，各种profile是根据不同的应用场景设计的，具体余下：</p>\n<ul>\n<li>Baseline主要是用于可视电话，会议电视，无线通讯等实时通信。要实时，就要减少视频decode和display的时延，所以没有B frame；为了提高针对网络丢包的容错能力，特意添加了FMO，ASO和冗余slice；</li>\n<li>Main用于数字广播电视和数字视频存储，侧重点在于提高压缩率，所以有了CABAC，MBAFF，Interlace，B frame等。</li>\n<li>Extend用于改进误码性能和码流切换（SP和SI slice），侧重于码流切换（SI，SP slice）和error resilience（数据分割）。</li>\n<li>High主要用于高压缩效率和质量， 引入8x8 DCT，选择量化矩阵等。</li>\n</ul>\n<p>各个不同profile的具体feature对比如下：<br><img src=\"//www.cyrus.fun/2019/01/24/H264-profile类型及特点/profile_feather.png\" alt=\"\"></p>\n<h4 id=\"二、解码过程中profile的解析\"><a href=\"#二、解码过程中profile的解析\" class=\"headerlink\" title=\"二、解码过程中profile的解析\"></a>二、解码过程中profile的解析</h4><p>profile参数存放在SPS之中，在做视频播放器时，为了让后续的解码过程可以使用SPS中包含的参数，必须对其中的数据进行解析。其中H.264标准协议中规定的SPS格式位于文档的7.3.2.1.1部分，如下图所示：<br><img src=\"//www.cyrus.fun/2019/01/24/H264-profile类型及特点/profile_decode.png\" alt=\"\"></p>\n<p>各种类型的profile在SPS对应的profile_idc为：</p>\n<ul>\n<li><font color=\"#ff0000\">baseline</font>:  profile_idc = 66 or constraint_set0_flag = 1</li>\n<li><font color=\"#ff0000\">constrain baseline</font>: profile_idc = 66 &amp;&amp; constraint_set1_flag = 1</li>\n<li><font color=\"#ff0000\">main profile</font>: profile_idc = 77  or  constraint_set1_flag = 1</li>\n<li><font color=\"#ff0000\">extend profile</font>: profile_idc = 88 or constraint_set2_flag = 1</li>\n<li><font color=\"#ff0000\">high profile</font>: profile_idc = 100</li>\n<li><font color=\"#ff0000\">High 10</font>: profile_idc = 110</li>\n<li><font color=\"#ff0000\">High 422</font>: profile_idc = 122</li>\n<li><font color=\"#ff0000\">High 444</font>: profile_idc = 244</li>\n<li><font color=\"#ff0000\">Multiview</font>: profile_idc = 118</li>\n<li><font color=\"#ff0000\">Stereo Hight</font>: profile_idc = 128</li>\n</ul>\n<p>Reference：</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/lixiaowei16/article/details/22370217\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/lixiaowei16/article/details/22370217</a></li>\n<li><a href=\"https://www.cnblogs.com/wainiwann/p/7477794.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/wainiwann/p/7477794.html</a></li>\n</ul>\n"},{"title":"QT基础10——UDP","author":"Cyrus","date":"2019-01-01T13:17:00.000Z","_content":"```\n1、创建socket\nsocket = new QUdpSocket(this);\n\n2、绑定端口\nsocket->bind(10000);\n\n3、处理收到数据信号\nconnect(socket, &QUdpSocket::readyRead,\n            [=](){\n        char buf[2048] = {0};\n        QHostAddress cliAddr;\n        quint16 port;\n        \n        //udp需要使用读取数据报的函数，否则无法成功读取数据\n        qint64 length = socket->readDatagram(buf, sizeof(buf), &cliAddr, &port);\n        if(length > 0) {\n            QString str = QString(\"[%1:%2]:%3\").arg(cliAddr.toString()).arg(port).arg(buf);\n            ui->textEdit->setText(str);\n        }\n\n    });\n    \n    //发送数据\n    QString str = \"hello world\";\n    socket->writeDatagram(str.toUtf8(), QHostAddress(\"127.0.0.1\"), 10000);\n    \n    //若写数据报时地址改为255.255.255.255则为广播\n    QString str = \"hello world\";\n    socket->writeDatagram(str.toUtf8(), QHostAddress(\"255.255.255.255\"), 10000);\n    \n    //如果想要组播，则需要加入组播地址\n    //socket->joinMulticastGroup(xxx)\n// socket->leaveMulticastGroup(xxx)\n```","source":"_posts/QT基础10——UDP.md","raw":"title: QT基础10——UDP\nauthor: Cyrus\ntags: []\ncategories:\n  - QT\ndate: 2019-01-01 21:17:00\n---\n```\n1、创建socket\nsocket = new QUdpSocket(this);\n\n2、绑定端口\nsocket->bind(10000);\n\n3、处理收到数据信号\nconnect(socket, &QUdpSocket::readyRead,\n            [=](){\n        char buf[2048] = {0};\n        QHostAddress cliAddr;\n        quint16 port;\n        \n        //udp需要使用读取数据报的函数，否则无法成功读取数据\n        qint64 length = socket->readDatagram(buf, sizeof(buf), &cliAddr, &port);\n        if(length > 0) {\n            QString str = QString(\"[%1:%2]:%3\").arg(cliAddr.toString()).arg(port).arg(buf);\n            ui->textEdit->setText(str);\n        }\n\n    });\n    \n    //发送数据\n    QString str = \"hello world\";\n    socket->writeDatagram(str.toUtf8(), QHostAddress(\"127.0.0.1\"), 10000);\n    \n    //若写数据报时地址改为255.255.255.255则为广播\n    QString str = \"hello world\";\n    socket->writeDatagram(str.toUtf8(), QHostAddress(\"255.255.255.255\"), 10000);\n    \n    //如果想要组播，则需要加入组播地址\n    //socket->joinMulticastGroup(xxx)\n// socket->leaveMulticastGroup(xxx)\n```","slug":"QT基础10——UDP","published":1,"updated":"2019-07-09T08:13:34.938Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyzlbt8d000q0j66o4axsm00","content":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、创建socket</span><br><span class=\"line\">socket = new QUdpSocket(this);</span><br><span class=\"line\"></span><br><span class=\"line\">2、绑定端口</span><br><span class=\"line\">socket-&gt;bind(10000);</span><br><span class=\"line\"></span><br><span class=\"line\">3、处理收到数据信号</span><br><span class=\"line\">connect(socket, &amp;QUdpSocket::readyRead,</span><br><span class=\"line\">            [=]()&#123;</span><br><span class=\"line\">        char buf[2048] = &#123;0&#125;;</span><br><span class=\"line\">        QHostAddress cliAddr;</span><br><span class=\"line\">        quint16 port;</span><br><span class=\"line\">        </span><br><span class=\"line\">        //udp需要使用读取数据报的函数，否则无法成功读取数据</span><br><span class=\"line\">        qint64 length = socket-&gt;readDatagram(buf, sizeof(buf), &amp;cliAddr, &amp;port);</span><br><span class=\"line\">        if(length &gt; 0) &#123;</span><br><span class=\"line\">            QString str = QString(&quot;[%1:%2]:%3&quot;).arg(cliAddr.toString()).arg(port).arg(buf);</span><br><span class=\"line\">            ui-&gt;textEdit-&gt;setText(str);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    //发送数据</span><br><span class=\"line\">    QString str = &quot;hello world&quot;;</span><br><span class=\"line\">    socket-&gt;writeDatagram(str.toUtf8(), QHostAddress(&quot;127.0.0.1&quot;), 10000);</span><br><span class=\"line\">    </span><br><span class=\"line\">    //若写数据报时地址改为255.255.255.255则为广播</span><br><span class=\"line\">    QString str = &quot;hello world&quot;;</span><br><span class=\"line\">    socket-&gt;writeDatagram(str.toUtf8(), QHostAddress(&quot;255.255.255.255&quot;), 10000);</span><br><span class=\"line\">    </span><br><span class=\"line\">    //如果想要组播，则需要加入组播地址</span><br><span class=\"line\">    //socket-&gt;joinMulticastGroup(xxx)</span><br><span class=\"line\">// socket-&gt;leaveMulticastGroup(xxx)</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、创建socket</span><br><span class=\"line\">socket = new QUdpSocket(this);</span><br><span class=\"line\"></span><br><span class=\"line\">2、绑定端口</span><br><span class=\"line\">socket-&gt;bind(10000);</span><br><span class=\"line\"></span><br><span class=\"line\">3、处理收到数据信号</span><br><span class=\"line\">connect(socket, &amp;QUdpSocket::readyRead,</span><br><span class=\"line\">            [=]()&#123;</span><br><span class=\"line\">        char buf[2048] = &#123;0&#125;;</span><br><span class=\"line\">        QHostAddress cliAddr;</span><br><span class=\"line\">        quint16 port;</span><br><span class=\"line\">        </span><br><span class=\"line\">        //udp需要使用读取数据报的函数，否则无法成功读取数据</span><br><span class=\"line\">        qint64 length = socket-&gt;readDatagram(buf, sizeof(buf), &amp;cliAddr, &amp;port);</span><br><span class=\"line\">        if(length &gt; 0) &#123;</span><br><span class=\"line\">            QString str = QString(&quot;[%1:%2]:%3&quot;).arg(cliAddr.toString()).arg(port).arg(buf);</span><br><span class=\"line\">            ui-&gt;textEdit-&gt;setText(str);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    //发送数据</span><br><span class=\"line\">    QString str = &quot;hello world&quot;;</span><br><span class=\"line\">    socket-&gt;writeDatagram(str.toUtf8(), QHostAddress(&quot;127.0.0.1&quot;), 10000);</span><br><span class=\"line\">    </span><br><span class=\"line\">    //若写数据报时地址改为255.255.255.255则为广播</span><br><span class=\"line\">    QString str = &quot;hello world&quot;;</span><br><span class=\"line\">    socket-&gt;writeDatagram(str.toUtf8(), QHostAddress(&quot;255.255.255.255&quot;), 10000);</span><br><span class=\"line\">    </span><br><span class=\"line\">    //如果想要组播，则需要加入组播地址</span><br><span class=\"line\">    //socket-&gt;joinMulticastGroup(xxx)</span><br><span class=\"line\">// socket-&gt;leaveMulticastGroup(xxx)</span><br></pre></td></tr></table></figure>"},{"title":"QT基础2——信号和槽","author":"Cyrus","date":"2018-12-13T14:17:00.000Z","_content":"信号和槽是QT中用于对象间通信的一种机制，也是QT的核心机制。在GUI编程中，我们经常需要在改变一个组件的同时，通知另一个组件做出响应。\n\n### 一、信号连接函数\n```\n//信号连接函数\nQMetaObject::Connection QObject::connect(const QObject *sender, const char *signal, const QObject *receiver, const char *method, Qt::ConnectionType type = Qt::AutoConnection)\n\n示例：\n//btn为成员变量\n\tbtn.setParent(this);\n    btn.setText(\"hehe\");\n    btn.move(50, 50);\n    connect(&btn, &QPushButton::pressed, this, &MyWidget::close);\n    \n    /*\n    * QObject *sender, 即&btn，信号发出者,指针类型\n    * const char *signal，即&QPushButton::pressed，处理的信号， &发送者类名::信号名\n    * QObject *receiver，即this(这里是父视图，也可以是其他对象），信号接收者\n    * const char *method，即&MyWidget::close，槽函数，&接收的类名::槽函数名字\n    */\n    \n对比iOS的UIControl(UIButton的父类）添加事件的方法：\n- (void)addTarget:(nullable id)target action:(SEL)action forControlEvents:(UIControlEvents)controlEvents;\n\n示例：\nUIButton *button = [UIButton buttonWithType:UIButtonTypeCustom];\n    [button addTarget:self action:@selector(close) forControlEvents:UIControlEventTouchUpInside];\n    \n对比一下：\n&btn 对应 button  -->事件产生者\n&QPushButton::pressed 对应 UIControlEventTouchUpInside  -->事件的类型\nthis 对应  self   -->事件的接收者\n&MyWidget::close 对应  @selector(close)  -->事件的响应函数\n而且，事件类型和响应函数只需要字符数组类型，这说明槽函数有着类似iOS运行时的实现机制，可以通过函数名找到相应的函数实现。\n```\n\n### 二、自定义信号函数和槽函数\n在我们的.h文件中:\n```\n#ifndef MYWIDGET_H\n#define MYWIDGET_H\n\n#include <QWidget>\n#include <QPushButton>\n\nclass MyWidget : public QWidget\n{\n    Q_OBJECT\npublic:\n    explicit MyWidget(QWidget *parent = nullptr);\n\n//这里写信号函数\n   /* 信号必须有signals关键字声明\n    * 信号没有返回值，但可以有参数\n    * 信号就是函数的声明，只需要声明，无需实现\n    * 使用: emit  函数() 发送信号   \n    */\nsignals:\n\tvoid mySignal();\t//对应信息发送 emit mySignal();\n    void mySignal1(int, QString);\t//对应信息发送 emit mySignal1(123， “123”);\n    \n//这里写槽函数\n\t/* 槽函数特点：\n\t * 可以为任意的成员函数，普通全局函数，静态函数\n\t * 槽函数需要和信号一致（参数，返回值 ）\n\t * 信号都没有返回值，所以，槽函数一定没有返回值 \n    */\npublic slots:\n    void mySlot();\n    void mySlot1(int, QString);\n\nprivate:\n    QPushButton btn;\n};\n\n#endif // MYWIDGET_H\n```\n\n在.m文件中\n```\n#include \"mywidget.h\"\n#include <QLabel>\n#include <QDebug>\n\nMyWidget::MyWidget(QWidget *parent) : QWidget(parent)\n{\n    btn.setParent(this);\n    btn.setText(\"hehe\");\n    btn.move(50, 50);\n    \n    //自发自收，^-^\n    connect(this, &MyWidget::mySignal, this, &MyWidget::mySlot);\n   \tconnect(this, &MyWidget::mySignal1, this, &MyWidget::mySlot1);\n    \n    emit mySignal();\n    emit mySignal1(123, \"123\");\n}\n\n\nvoid MyWidget::mySlot() {\n    btn.setText(\"点击了\");\n}\n\nvoid MyWidget::mySlot1(int a, QString str) {\n    qDebug() << a << str;\n}\n```\n\n### 三、信号连接函数的几种写法\n```\n1、QT5的写法\nconnect(&btn, &QPushButton::pressed, this, &MyWidget::close);\n\n2、QT4的写法\n//QT4槽函数必须有slots关键字来修饰 .h public slots:\nconnect(&btn, SIGNAL(released()), this, SLOT(mySlot()));\n\n3、Lambda 表达式的写法\nconnect(&btn, &QPushButton::released,\n            [=]() {\n            btn.setText(\"456\");\n            qDebug() << \"123\";\n                  }\n    );\n    \n```\n\n重点讲一下关于Lambda表达式的写法：\n* C++11增加的新特性 .pro文件 CONFIG += C++11\n* 配合信号一起使用，类似iOS的block\n* [btn，a, b]传参，将btn,a, b传入表达式\n* 可以直接用【=】，将外部所有局部变量、类中的所有成员变量传入表达式\n*【=】() mutable {} 可以修改变量值，相当于iOS的__block\n* [this] 类中的所有成员以值传递方式, [&] 把外部所有局部变量，引用符号\n* 信号带参数 【】(参数列表){},参数列表与信号相对应，如上面的mySlot1信号\n```\nconnect(this, &MyWidget::mySignal1,\n          [=](int a, QString str) {\n            qDebug() << a << str;\n         }\n        );\n//发送信号\nemit mySignal1(123, \"123\");\n```\n","source":"_posts/QT基础2——信号和槽.md","raw":"title: QT基础2——信号和槽\nauthor: Cyrus\ntags: []\ncategories:\n  - QT\ndate: 2018-12-13 22:17:00\n---\n信号和槽是QT中用于对象间通信的一种机制，也是QT的核心机制。在GUI编程中，我们经常需要在改变一个组件的同时，通知另一个组件做出响应。\n\n### 一、信号连接函数\n```\n//信号连接函数\nQMetaObject::Connection QObject::connect(const QObject *sender, const char *signal, const QObject *receiver, const char *method, Qt::ConnectionType type = Qt::AutoConnection)\n\n示例：\n//btn为成员变量\n\tbtn.setParent(this);\n    btn.setText(\"hehe\");\n    btn.move(50, 50);\n    connect(&btn, &QPushButton::pressed, this, &MyWidget::close);\n    \n    /*\n    * QObject *sender, 即&btn，信号发出者,指针类型\n    * const char *signal，即&QPushButton::pressed，处理的信号， &发送者类名::信号名\n    * QObject *receiver，即this(这里是父视图，也可以是其他对象），信号接收者\n    * const char *method，即&MyWidget::close，槽函数，&接收的类名::槽函数名字\n    */\n    \n对比iOS的UIControl(UIButton的父类）添加事件的方法：\n- (void)addTarget:(nullable id)target action:(SEL)action forControlEvents:(UIControlEvents)controlEvents;\n\n示例：\nUIButton *button = [UIButton buttonWithType:UIButtonTypeCustom];\n    [button addTarget:self action:@selector(close) forControlEvents:UIControlEventTouchUpInside];\n    \n对比一下：\n&btn 对应 button  -->事件产生者\n&QPushButton::pressed 对应 UIControlEventTouchUpInside  -->事件的类型\nthis 对应  self   -->事件的接收者\n&MyWidget::close 对应  @selector(close)  -->事件的响应函数\n而且，事件类型和响应函数只需要字符数组类型，这说明槽函数有着类似iOS运行时的实现机制，可以通过函数名找到相应的函数实现。\n```\n\n### 二、自定义信号函数和槽函数\n在我们的.h文件中:\n```\n#ifndef MYWIDGET_H\n#define MYWIDGET_H\n\n#include <QWidget>\n#include <QPushButton>\n\nclass MyWidget : public QWidget\n{\n    Q_OBJECT\npublic:\n    explicit MyWidget(QWidget *parent = nullptr);\n\n//这里写信号函数\n   /* 信号必须有signals关键字声明\n    * 信号没有返回值，但可以有参数\n    * 信号就是函数的声明，只需要声明，无需实现\n    * 使用: emit  函数() 发送信号   \n    */\nsignals:\n\tvoid mySignal();\t//对应信息发送 emit mySignal();\n    void mySignal1(int, QString);\t//对应信息发送 emit mySignal1(123， “123”);\n    \n//这里写槽函数\n\t/* 槽函数特点：\n\t * 可以为任意的成员函数，普通全局函数，静态函数\n\t * 槽函数需要和信号一致（参数，返回值 ）\n\t * 信号都没有返回值，所以，槽函数一定没有返回值 \n    */\npublic slots:\n    void mySlot();\n    void mySlot1(int, QString);\n\nprivate:\n    QPushButton btn;\n};\n\n#endif // MYWIDGET_H\n```\n\n在.m文件中\n```\n#include \"mywidget.h\"\n#include <QLabel>\n#include <QDebug>\n\nMyWidget::MyWidget(QWidget *parent) : QWidget(parent)\n{\n    btn.setParent(this);\n    btn.setText(\"hehe\");\n    btn.move(50, 50);\n    \n    //自发自收，^-^\n    connect(this, &MyWidget::mySignal, this, &MyWidget::mySlot);\n   \tconnect(this, &MyWidget::mySignal1, this, &MyWidget::mySlot1);\n    \n    emit mySignal();\n    emit mySignal1(123, \"123\");\n}\n\n\nvoid MyWidget::mySlot() {\n    btn.setText(\"点击了\");\n}\n\nvoid MyWidget::mySlot1(int a, QString str) {\n    qDebug() << a << str;\n}\n```\n\n### 三、信号连接函数的几种写法\n```\n1、QT5的写法\nconnect(&btn, &QPushButton::pressed, this, &MyWidget::close);\n\n2、QT4的写法\n//QT4槽函数必须有slots关键字来修饰 .h public slots:\nconnect(&btn, SIGNAL(released()), this, SLOT(mySlot()));\n\n3、Lambda 表达式的写法\nconnect(&btn, &QPushButton::released,\n            [=]() {\n            btn.setText(\"456\");\n            qDebug() << \"123\";\n                  }\n    );\n    \n```\n\n重点讲一下关于Lambda表达式的写法：\n* C++11增加的新特性 .pro文件 CONFIG += C++11\n* 配合信号一起使用，类似iOS的block\n* [btn，a, b]传参，将btn,a, b传入表达式\n* 可以直接用【=】，将外部所有局部变量、类中的所有成员变量传入表达式\n*【=】() mutable {} 可以修改变量值，相当于iOS的__block\n* [this] 类中的所有成员以值传递方式, [&] 把外部所有局部变量，引用符号\n* 信号带参数 【】(参数列表){},参数列表与信号相对应，如上面的mySlot1信号\n```\nconnect(this, &MyWidget::mySignal1,\n          [=](int a, QString str) {\n            qDebug() << a << str;\n         }\n        );\n//发送信号\nemit mySignal1(123, \"123\");\n```\n","slug":"QT基础2——信号和槽","published":1,"updated":"2019-07-09T08:13:34.938Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyzlbt8e000s0j66k0d6jxf6","content":"<p>信号和槽是QT中用于对象间通信的一种机制，也是QT的核心机制。在GUI编程中，我们经常需要在改变一个组件的同时，通知另一个组件做出响应。</p>\n<h3 id=\"一、信号连接函数\"><a href=\"#一、信号连接函数\" class=\"headerlink\" title=\"一、信号连接函数\"></a>一、信号连接函数</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//信号连接函数</span><br><span class=\"line\">QMetaObject::Connection QObject::connect(const QObject *sender, const char *signal, const QObject *receiver, const char *method, Qt::ConnectionType type = Qt::AutoConnection)</span><br><span class=\"line\"></span><br><span class=\"line\">示例：</span><br><span class=\"line\">//btn为成员变量</span><br><span class=\"line\">\tbtn.setParent(this);</span><br><span class=\"line\">    btn.setText(&quot;hehe&quot;);</span><br><span class=\"line\">    btn.move(50, 50);</span><br><span class=\"line\">    connect(&amp;btn, &amp;QPushButton::pressed, this, &amp;MyWidget::close);</span><br><span class=\"line\">    </span><br><span class=\"line\">    /*</span><br><span class=\"line\">    * QObject *sender, 即&amp;btn，信号发出者,指针类型</span><br><span class=\"line\">    * const char *signal，即&amp;QPushButton::pressed，处理的信号， &amp;发送者类名::信号名</span><br><span class=\"line\">    * QObject *receiver，即this(这里是父视图，也可以是其他对象），信号接收者</span><br><span class=\"line\">    * const char *method，即&amp;MyWidget::close，槽函数，&amp;接收的类名::槽函数名字</span><br><span class=\"line\">    */</span><br><span class=\"line\">    </span><br><span class=\"line\">对比iOS的UIControl(UIButton的父类）添加事件的方法：</span><br><span class=\"line\">- (void)addTarget:(nullable id)target action:(SEL)action forControlEvents:(UIControlEvents)controlEvents;</span><br><span class=\"line\"></span><br><span class=\"line\">示例：</span><br><span class=\"line\">UIButton *button = [UIButton buttonWithType:UIButtonTypeCustom];</span><br><span class=\"line\">    [button addTarget:self action:@selector(close) forControlEvents:UIControlEventTouchUpInside];</span><br><span class=\"line\">    </span><br><span class=\"line\">对比一下：</span><br><span class=\"line\">&amp;btn 对应 button  --&gt;事件产生者</span><br><span class=\"line\">&amp;QPushButton::pressed 对应 UIControlEventTouchUpInside  --&gt;事件的类型</span><br><span class=\"line\">this 对应  self   --&gt;事件的接收者</span><br><span class=\"line\">&amp;MyWidget::close 对应  @selector(close)  --&gt;事件的响应函数</span><br><span class=\"line\">而且，事件类型和响应函数只需要字符数组类型，这说明槽函数有着类似iOS运行时的实现机制，可以通过函数名找到相应的函数实现。</span><br></pre></td></tr></table></figure>\n<h3 id=\"二、自定义信号函数和槽函数\"><a href=\"#二、自定义信号函数和槽函数\" class=\"headerlink\" title=\"二、自定义信号函数和槽函数\"></a>二、自定义信号函数和槽函数</h3><p>在我们的.h文件中:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#ifndef MYWIDGET_H</span><br><span class=\"line\">#define MYWIDGET_H</span><br><span class=\"line\"></span><br><span class=\"line\">#include &lt;QWidget&gt;</span><br><span class=\"line\">#include &lt;QPushButton&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">class MyWidget : public QWidget</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Q_OBJECT</span><br><span class=\"line\">public:</span><br><span class=\"line\">    explicit MyWidget(QWidget *parent = nullptr);</span><br><span class=\"line\"></span><br><span class=\"line\">//这里写信号函数</span><br><span class=\"line\">   /* 信号必须有signals关键字声明</span><br><span class=\"line\">    * 信号没有返回值，但可以有参数</span><br><span class=\"line\">    * 信号就是函数的声明，只需要声明，无需实现</span><br><span class=\"line\">    * 使用: emit  函数() 发送信号   </span><br><span class=\"line\">    */</span><br><span class=\"line\">signals:</span><br><span class=\"line\">\tvoid mySignal();\t//对应信息发送 emit mySignal();</span><br><span class=\"line\">    void mySignal1(int, QString);\t//对应信息发送 emit mySignal1(123， “123”);</span><br><span class=\"line\">    </span><br><span class=\"line\">//这里写槽函数</span><br><span class=\"line\">\t/* 槽函数特点：</span><br><span class=\"line\">\t * 可以为任意的成员函数，普通全局函数，静态函数</span><br><span class=\"line\">\t * 槽函数需要和信号一致（参数，返回值 ）</span><br><span class=\"line\">\t * 信号都没有返回值，所以，槽函数一定没有返回值 </span><br><span class=\"line\">    */</span><br><span class=\"line\">public slots:</span><br><span class=\"line\">    void mySlot();</span><br><span class=\"line\">    void mySlot1(int, QString);</span><br><span class=\"line\"></span><br><span class=\"line\">private:</span><br><span class=\"line\">    QPushButton btn;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">#endif // MYWIDGET_H</span><br></pre></td></tr></table></figure></p>\n<p>在.m文件中<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &quot;mywidget.h&quot;</span><br><span class=\"line\">#include &lt;QLabel&gt;</span><br><span class=\"line\">#include &lt;QDebug&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">MyWidget::MyWidget(QWidget *parent) : QWidget(parent)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    btn.setParent(this);</span><br><span class=\"line\">    btn.setText(&quot;hehe&quot;);</span><br><span class=\"line\">    btn.move(50, 50);</span><br><span class=\"line\">    </span><br><span class=\"line\">    //自发自收，^-^</span><br><span class=\"line\">    connect(this, &amp;MyWidget::mySignal, this, &amp;MyWidget::mySlot);</span><br><span class=\"line\">   \tconnect(this, &amp;MyWidget::mySignal1, this, &amp;MyWidget::mySlot1);</span><br><span class=\"line\">    </span><br><span class=\"line\">    emit mySignal();</span><br><span class=\"line\">    emit mySignal1(123, &quot;123&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">void MyWidget::mySlot() &#123;</span><br><span class=\"line\">    btn.setText(&quot;点击了&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void MyWidget::mySlot1(int a, QString str) &#123;</span><br><span class=\"line\">    qDebug() &lt;&lt; a &lt;&lt; str;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"三、信号连接函数的几种写法\"><a href=\"#三、信号连接函数的几种写法\" class=\"headerlink\" title=\"三、信号连接函数的几种写法\"></a>三、信号连接函数的几种写法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、QT5的写法</span><br><span class=\"line\">connect(&amp;btn, &amp;QPushButton::pressed, this, &amp;MyWidget::close);</span><br><span class=\"line\"></span><br><span class=\"line\">2、QT4的写法</span><br><span class=\"line\">//QT4槽函数必须有slots关键字来修饰 .h public slots:</span><br><span class=\"line\">connect(&amp;btn, SIGNAL(released()), this, SLOT(mySlot()));</span><br><span class=\"line\"></span><br><span class=\"line\">3、Lambda 表达式的写法</span><br><span class=\"line\">connect(&amp;btn, &amp;QPushButton::released,</span><br><span class=\"line\">            [=]() &#123;</span><br><span class=\"line\">            btn.setText(&quot;456&quot;);</span><br><span class=\"line\">            qDebug() &lt;&lt; &quot;123&quot;;</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">    );</span><br></pre></td></tr></table></figure>\n<p>重点讲一下关于Lambda表达式的写法：</p>\n<ul>\n<li>C++11增加的新特性 .pro文件 CONFIG += C++11</li>\n<li>配合信号一起使用，类似iOS的block</li>\n<li>[btn，a, b]传参，将btn,a, b传入表达式</li>\n<li>可以直接用【=】，将外部所有局部变量、类中的所有成员变量传入表达式<br>*【=】() mutable {} 可以修改变量值，相当于iOS的__block</li>\n<li>[this] 类中的所有成员以值传递方式, [&amp;] 把外部所有局部变量，引用符号</li>\n<li>信号带参数 【】(参数列表){},参数列表与信号相对应，如上面的mySlot1信号<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">connect(this, &amp;MyWidget::mySignal1,</span><br><span class=\"line\">          [=](int a, QString str) &#123;</span><br><span class=\"line\">            qDebug() &lt;&lt; a &lt;&lt; str;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">        );</span><br><span class=\"line\">//发送信号</span><br><span class=\"line\">emit mySignal1(123, &quot;123&quot;);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>信号和槽是QT中用于对象间通信的一种机制，也是QT的核心机制。在GUI编程中，我们经常需要在改变一个组件的同时，通知另一个组件做出响应。</p>\n<h3 id=\"一、信号连接函数\"><a href=\"#一、信号连接函数\" class=\"headerlink\" title=\"一、信号连接函数\"></a>一、信号连接函数</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//信号连接函数</span><br><span class=\"line\">QMetaObject::Connection QObject::connect(const QObject *sender, const char *signal, const QObject *receiver, const char *method, Qt::ConnectionType type = Qt::AutoConnection)</span><br><span class=\"line\"></span><br><span class=\"line\">示例：</span><br><span class=\"line\">//btn为成员变量</span><br><span class=\"line\">\tbtn.setParent(this);</span><br><span class=\"line\">    btn.setText(&quot;hehe&quot;);</span><br><span class=\"line\">    btn.move(50, 50);</span><br><span class=\"line\">    connect(&amp;btn, &amp;QPushButton::pressed, this, &amp;MyWidget::close);</span><br><span class=\"line\">    </span><br><span class=\"line\">    /*</span><br><span class=\"line\">    * QObject *sender, 即&amp;btn，信号发出者,指针类型</span><br><span class=\"line\">    * const char *signal，即&amp;QPushButton::pressed，处理的信号， &amp;发送者类名::信号名</span><br><span class=\"line\">    * QObject *receiver，即this(这里是父视图，也可以是其他对象），信号接收者</span><br><span class=\"line\">    * const char *method，即&amp;MyWidget::close，槽函数，&amp;接收的类名::槽函数名字</span><br><span class=\"line\">    */</span><br><span class=\"line\">    </span><br><span class=\"line\">对比iOS的UIControl(UIButton的父类）添加事件的方法：</span><br><span class=\"line\">- (void)addTarget:(nullable id)target action:(SEL)action forControlEvents:(UIControlEvents)controlEvents;</span><br><span class=\"line\"></span><br><span class=\"line\">示例：</span><br><span class=\"line\">UIButton *button = [UIButton buttonWithType:UIButtonTypeCustom];</span><br><span class=\"line\">    [button addTarget:self action:@selector(close) forControlEvents:UIControlEventTouchUpInside];</span><br><span class=\"line\">    </span><br><span class=\"line\">对比一下：</span><br><span class=\"line\">&amp;btn 对应 button  --&gt;事件产生者</span><br><span class=\"line\">&amp;QPushButton::pressed 对应 UIControlEventTouchUpInside  --&gt;事件的类型</span><br><span class=\"line\">this 对应  self   --&gt;事件的接收者</span><br><span class=\"line\">&amp;MyWidget::close 对应  @selector(close)  --&gt;事件的响应函数</span><br><span class=\"line\">而且，事件类型和响应函数只需要字符数组类型，这说明槽函数有着类似iOS运行时的实现机制，可以通过函数名找到相应的函数实现。</span><br></pre></td></tr></table></figure>\n<h3 id=\"二、自定义信号函数和槽函数\"><a href=\"#二、自定义信号函数和槽函数\" class=\"headerlink\" title=\"二、自定义信号函数和槽函数\"></a>二、自定义信号函数和槽函数</h3><p>在我们的.h文件中:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#ifndef MYWIDGET_H</span><br><span class=\"line\">#define MYWIDGET_H</span><br><span class=\"line\"></span><br><span class=\"line\">#include &lt;QWidget&gt;</span><br><span class=\"line\">#include &lt;QPushButton&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">class MyWidget : public QWidget</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Q_OBJECT</span><br><span class=\"line\">public:</span><br><span class=\"line\">    explicit MyWidget(QWidget *parent = nullptr);</span><br><span class=\"line\"></span><br><span class=\"line\">//这里写信号函数</span><br><span class=\"line\">   /* 信号必须有signals关键字声明</span><br><span class=\"line\">    * 信号没有返回值，但可以有参数</span><br><span class=\"line\">    * 信号就是函数的声明，只需要声明，无需实现</span><br><span class=\"line\">    * 使用: emit  函数() 发送信号   </span><br><span class=\"line\">    */</span><br><span class=\"line\">signals:</span><br><span class=\"line\">\tvoid mySignal();\t//对应信息发送 emit mySignal();</span><br><span class=\"line\">    void mySignal1(int, QString);\t//对应信息发送 emit mySignal1(123， “123”);</span><br><span class=\"line\">    </span><br><span class=\"line\">//这里写槽函数</span><br><span class=\"line\">\t/* 槽函数特点：</span><br><span class=\"line\">\t * 可以为任意的成员函数，普通全局函数，静态函数</span><br><span class=\"line\">\t * 槽函数需要和信号一致（参数，返回值 ）</span><br><span class=\"line\">\t * 信号都没有返回值，所以，槽函数一定没有返回值 </span><br><span class=\"line\">    */</span><br><span class=\"line\">public slots:</span><br><span class=\"line\">    void mySlot();</span><br><span class=\"line\">    void mySlot1(int, QString);</span><br><span class=\"line\"></span><br><span class=\"line\">private:</span><br><span class=\"line\">    QPushButton btn;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">#endif // MYWIDGET_H</span><br></pre></td></tr></table></figure></p>\n<p>在.m文件中<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &quot;mywidget.h&quot;</span><br><span class=\"line\">#include &lt;QLabel&gt;</span><br><span class=\"line\">#include &lt;QDebug&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">MyWidget::MyWidget(QWidget *parent) : QWidget(parent)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    btn.setParent(this);</span><br><span class=\"line\">    btn.setText(&quot;hehe&quot;);</span><br><span class=\"line\">    btn.move(50, 50);</span><br><span class=\"line\">    </span><br><span class=\"line\">    //自发自收，^-^</span><br><span class=\"line\">    connect(this, &amp;MyWidget::mySignal, this, &amp;MyWidget::mySlot);</span><br><span class=\"line\">   \tconnect(this, &amp;MyWidget::mySignal1, this, &amp;MyWidget::mySlot1);</span><br><span class=\"line\">    </span><br><span class=\"line\">    emit mySignal();</span><br><span class=\"line\">    emit mySignal1(123, &quot;123&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">void MyWidget::mySlot() &#123;</span><br><span class=\"line\">    btn.setText(&quot;点击了&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void MyWidget::mySlot1(int a, QString str) &#123;</span><br><span class=\"line\">    qDebug() &lt;&lt; a &lt;&lt; str;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"三、信号连接函数的几种写法\"><a href=\"#三、信号连接函数的几种写法\" class=\"headerlink\" title=\"三、信号连接函数的几种写法\"></a>三、信号连接函数的几种写法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、QT5的写法</span><br><span class=\"line\">connect(&amp;btn, &amp;QPushButton::pressed, this, &amp;MyWidget::close);</span><br><span class=\"line\"></span><br><span class=\"line\">2、QT4的写法</span><br><span class=\"line\">//QT4槽函数必须有slots关键字来修饰 .h public slots:</span><br><span class=\"line\">connect(&amp;btn, SIGNAL(released()), this, SLOT(mySlot()));</span><br><span class=\"line\"></span><br><span class=\"line\">3、Lambda 表达式的写法</span><br><span class=\"line\">connect(&amp;btn, &amp;QPushButton::released,</span><br><span class=\"line\">            [=]() &#123;</span><br><span class=\"line\">            btn.setText(&quot;456&quot;);</span><br><span class=\"line\">            qDebug() &lt;&lt; &quot;123&quot;;</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">    );</span><br></pre></td></tr></table></figure>\n<p>重点讲一下关于Lambda表达式的写法：</p>\n<ul>\n<li>C++11增加的新特性 .pro文件 CONFIG += C++11</li>\n<li>配合信号一起使用，类似iOS的block</li>\n<li>[btn，a, b]传参，将btn,a, b传入表达式</li>\n<li>可以直接用【=】，将外部所有局部变量、类中的所有成员变量传入表达式<br>*【=】() mutable {} 可以修改变量值，相当于iOS的__block</li>\n<li>[this] 类中的所有成员以值传递方式, [&amp;] 把外部所有局部变量，引用符号</li>\n<li>信号带参数 【】(参数列表){},参数列表与信号相对应，如上面的mySlot1信号<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">connect(this, &amp;MyWidget::mySignal1,</span><br><span class=\"line\">          [=](int a, QString str) &#123;</span><br><span class=\"line\">            qDebug() &lt;&lt; a &lt;&lt; str;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">        );</span><br><span class=\"line\">//发送信号</span><br><span class=\"line\">emit mySignal1(123, &quot;123&quot;);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n"},{"title":"QT基础3——QMainWindow及相关控件","author":"Cyrus","date":"2018-12-15T10:09:00.000Z","_content":"MainWindow 是QT创建应用程序三种界面中的一种，也是比较常用的一种。与QWidget相比，MainWindow自带了许多控件，如QMenuBar、QToolBar、QStatusBar等等。\n\n### 菜单栏\n```\n//获取菜单栏\nQMenuBar *mBar = menuBar();\n//添加菜单\nQMenu *pFile = mBar->addMenu(QString(\"File\"));\n//菜单下拉选项\nQAction *pNew = pFile->addAction(QString(\"New\"));\n//选项绑定事件\nconnect(pNew, &QAction::triggered,\n      \t[=]() {\n\t\t\tqDebug() << \"New\";\n      \t}\n);\n    \n//菜单添加分割线\npFile->addSeparator();\n\n//添加另一个下拉选项和对应的事件\nQAction *pOpen = pFile->addAction(QString(\"Open\"));\nconnect(pOpen, &QAction::triggered,\n        [=]() {\n                qDebug() << \"Open\";\n        }\n);\n```\n\n### 工具栏\n```\n\t//工具栏， 菜单栏对应的快捷方式\n    QToolBar *toolBar = addToolBar(\"toolBar\");\n    //工具栏添加快捷键\n    toolBar->addAction(pNew);\n    toolBar->addAction(pOpen);\n\n    QPushButton *b = new QPushButton(this);\n    b->setText(\"*_*\");\n    //添加小控件\n    toolBar->addWidget(b);\n    connect(b, &QPushButton::clicked,\n            [=](){\n        b->setText(\"^-^\");\n    });\n```\n\n### 状态栏\n```\n    //状态栏\n    QStatusBar *sbar = statusBar();\n    QLabel *label = new QLabel(this);\n    label->setText(\"long long time ago\");\n    sbar->addWidget(label);\n    //从左往右加\n    sbar->addWidget(new QLabel(\"hehe\", this));\n    //从右往左加\n    sbar->addPermanentWidget(new QLabel(\"xixi\", this));\n```\n\n### 设置核心控件和浮动窗口\n```\n\tQTextEdit *textEdit = new QTextEdit(this);\n    //将文本编辑设为核心控件\n    setCentralWidget(textEdit);\n    \n    //浮动窗口\n    QDockWidget *dock = new QDockWidget(this);\n    addDockWidget(Qt::LeftDockWidgetArea, dock);\n```\n\n### 对话框\n```\n//一、模态对话框\n//模态对话框，使用exex()调用，无法操作当前窗口，关闭窗口后才能继续运行MainWindow代码\nQDialog dlg;\ndlg.exec();\n\n\n//二、非模态对话框\n//非模态对话框，使用show()调用，不会阻塞MainWindow代码\n\n错误写法如下：对话框一闪而过\nQDialog dlg;\ndlg.show();\n\n修正写法：\n1、使用new创建对象，缺点是不能主动释放，生成太多对话框的话内存高\nQDialog *dlg = new QDialog(this);\ndlg->show();\n\n2、将QDialog设为成员变量，直接调用show()\n\n3、将QDialog属性设置为关闭时释放,即方法1的修正写法\nQDialog *dlg = new QDialog;\ndlg->setAttribute(Qt::WA_DeleteOnClose);\ndlg->show();\n```\n\n### 选择弹框\n```\n//多个按钮由|分隔，选择的按钮存在于返回值中\n    int ret = QMessageBox::warning(this, tr(\"MyApplication\"), tr(\"The document has been modified.\\n\" \"Do you want to save your changes?\"),\nQMessageBox::Save | QMessageBox::Discard | QMessageBox::Cancel, QMessageBox::Save);\n\t//枚举返回值进行相应处理\n    switch (ret) {\n        case QMessageBox::Save:\n            qDebug() << \"save\";\n        break;\n        case QMessageBox::Discard:\n            qDebug() << \"Discard\";\n         break;\n        case QMessageBox::Cancel:\n            qDebug() << \"Cancel\";\n        break;\n    default:\n        break;\n    }\n    \n    //文件名选择框，返回选择的文件名\n    QString fileName = QFileDialog::getOpenFileName(this,tr(\"Open Image\"), \"../\", tr(\"Image Files (*.png *.jpg *.bmp)\"));\n    qDebug() << fileName;\n```\n","source":"_posts/QT基础3——QMainWindow及相关控件.md","raw":"title: QT基础3——QMainWindow及相关控件\nauthor: Cyrus\ntags: []\ncategories:\n  - QT\ndate: 2018-12-15 18:09:00\n---\nMainWindow 是QT创建应用程序三种界面中的一种，也是比较常用的一种。与QWidget相比，MainWindow自带了许多控件，如QMenuBar、QToolBar、QStatusBar等等。\n\n### 菜单栏\n```\n//获取菜单栏\nQMenuBar *mBar = menuBar();\n//添加菜单\nQMenu *pFile = mBar->addMenu(QString(\"File\"));\n//菜单下拉选项\nQAction *pNew = pFile->addAction(QString(\"New\"));\n//选项绑定事件\nconnect(pNew, &QAction::triggered,\n      \t[=]() {\n\t\t\tqDebug() << \"New\";\n      \t}\n);\n    \n//菜单添加分割线\npFile->addSeparator();\n\n//添加另一个下拉选项和对应的事件\nQAction *pOpen = pFile->addAction(QString(\"Open\"));\nconnect(pOpen, &QAction::triggered,\n        [=]() {\n                qDebug() << \"Open\";\n        }\n);\n```\n\n### 工具栏\n```\n\t//工具栏， 菜单栏对应的快捷方式\n    QToolBar *toolBar = addToolBar(\"toolBar\");\n    //工具栏添加快捷键\n    toolBar->addAction(pNew);\n    toolBar->addAction(pOpen);\n\n    QPushButton *b = new QPushButton(this);\n    b->setText(\"*_*\");\n    //添加小控件\n    toolBar->addWidget(b);\n    connect(b, &QPushButton::clicked,\n            [=](){\n        b->setText(\"^-^\");\n    });\n```\n\n### 状态栏\n```\n    //状态栏\n    QStatusBar *sbar = statusBar();\n    QLabel *label = new QLabel(this);\n    label->setText(\"long long time ago\");\n    sbar->addWidget(label);\n    //从左往右加\n    sbar->addWidget(new QLabel(\"hehe\", this));\n    //从右往左加\n    sbar->addPermanentWidget(new QLabel(\"xixi\", this));\n```\n\n### 设置核心控件和浮动窗口\n```\n\tQTextEdit *textEdit = new QTextEdit(this);\n    //将文本编辑设为核心控件\n    setCentralWidget(textEdit);\n    \n    //浮动窗口\n    QDockWidget *dock = new QDockWidget(this);\n    addDockWidget(Qt::LeftDockWidgetArea, dock);\n```\n\n### 对话框\n```\n//一、模态对话框\n//模态对话框，使用exex()调用，无法操作当前窗口，关闭窗口后才能继续运行MainWindow代码\nQDialog dlg;\ndlg.exec();\n\n\n//二、非模态对话框\n//非模态对话框，使用show()调用，不会阻塞MainWindow代码\n\n错误写法如下：对话框一闪而过\nQDialog dlg;\ndlg.show();\n\n修正写法：\n1、使用new创建对象，缺点是不能主动释放，生成太多对话框的话内存高\nQDialog *dlg = new QDialog(this);\ndlg->show();\n\n2、将QDialog设为成员变量，直接调用show()\n\n3、将QDialog属性设置为关闭时释放,即方法1的修正写法\nQDialog *dlg = new QDialog;\ndlg->setAttribute(Qt::WA_DeleteOnClose);\ndlg->show();\n```\n\n### 选择弹框\n```\n//多个按钮由|分隔，选择的按钮存在于返回值中\n    int ret = QMessageBox::warning(this, tr(\"MyApplication\"), tr(\"The document has been modified.\\n\" \"Do you want to save your changes?\"),\nQMessageBox::Save | QMessageBox::Discard | QMessageBox::Cancel, QMessageBox::Save);\n\t//枚举返回值进行相应处理\n    switch (ret) {\n        case QMessageBox::Save:\n            qDebug() << \"save\";\n        break;\n        case QMessageBox::Discard:\n            qDebug() << \"Discard\";\n         break;\n        case QMessageBox::Cancel:\n            qDebug() << \"Cancel\";\n        break;\n    default:\n        break;\n    }\n    \n    //文件名选择框，返回选择的文件名\n    QString fileName = QFileDialog::getOpenFileName(this,tr(\"Open Image\"), \"../\", tr(\"Image Files (*.png *.jpg *.bmp)\"));\n    qDebug() << fileName;\n```\n","slug":"QT基础3——QMainWindow及相关控件","published":1,"updated":"2019-07-09T08:13:34.939Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyzlbt8g000v0j66h4kk80xf","content":"<p>MainWindow 是QT创建应用程序三种界面中的一种，也是比较常用的一种。与QWidget相比，MainWindow自带了许多控件，如QMenuBar、QToolBar、QStatusBar等等。</p>\n<h3 id=\"菜单栏\"><a href=\"#菜单栏\" class=\"headerlink\" title=\"菜单栏\"></a>菜单栏</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//获取菜单栏</span><br><span class=\"line\">QMenuBar *mBar = menuBar();</span><br><span class=\"line\">//添加菜单</span><br><span class=\"line\">QMenu *pFile = mBar-&gt;addMenu(QString(&quot;File&quot;));</span><br><span class=\"line\">//菜单下拉选项</span><br><span class=\"line\">QAction *pNew = pFile-&gt;addAction(QString(&quot;New&quot;));</span><br><span class=\"line\">//选项绑定事件</span><br><span class=\"line\">connect(pNew, &amp;QAction::triggered,</span><br><span class=\"line\">      \t[=]() &#123;</span><br><span class=\"line\">\t\t\tqDebug() &lt;&lt; &quot;New&quot;;</span><br><span class=\"line\">      \t&#125;</span><br><span class=\"line\">);</span><br><span class=\"line\">    </span><br><span class=\"line\">//菜单添加分割线</span><br><span class=\"line\">pFile-&gt;addSeparator();</span><br><span class=\"line\"></span><br><span class=\"line\">//添加另一个下拉选项和对应的事件</span><br><span class=\"line\">QAction *pOpen = pFile-&gt;addAction(QString(&quot;Open&quot;));</span><br><span class=\"line\">connect(pOpen, &amp;QAction::triggered,</span><br><span class=\"line\">        [=]() &#123;</span><br><span class=\"line\">                qDebug() &lt;&lt; &quot;Open&quot;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<h3 id=\"工具栏\"><a href=\"#工具栏\" class=\"headerlink\" title=\"工具栏\"></a>工具栏</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//工具栏， 菜单栏对应的快捷方式</span><br><span class=\"line\">   QToolBar *toolBar = addToolBar(&quot;toolBar&quot;);</span><br><span class=\"line\">   //工具栏添加快捷键</span><br><span class=\"line\">   toolBar-&gt;addAction(pNew);</span><br><span class=\"line\">   toolBar-&gt;addAction(pOpen);</span><br><span class=\"line\"></span><br><span class=\"line\">   QPushButton *b = new QPushButton(this);</span><br><span class=\"line\">   b-&gt;setText(&quot;*_*&quot;);</span><br><span class=\"line\">   //添加小控件</span><br><span class=\"line\">   toolBar-&gt;addWidget(b);</span><br><span class=\"line\">   connect(b, &amp;QPushButton::clicked,</span><br><span class=\"line\">           [=]()&#123;</span><br><span class=\"line\">       b-&gt;setText(&quot;^-^&quot;);</span><br><span class=\"line\">   &#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"状态栏\"><a href=\"#状态栏\" class=\"headerlink\" title=\"状态栏\"></a>状态栏</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//状态栏</span><br><span class=\"line\">QStatusBar *sbar = statusBar();</span><br><span class=\"line\">QLabel *label = new QLabel(this);</span><br><span class=\"line\">label-&gt;setText(&quot;long long time ago&quot;);</span><br><span class=\"line\">sbar-&gt;addWidget(label);</span><br><span class=\"line\">//从左往右加</span><br><span class=\"line\">sbar-&gt;addWidget(new QLabel(&quot;hehe&quot;, this));</span><br><span class=\"line\">//从右往左加</span><br><span class=\"line\">sbar-&gt;addPermanentWidget(new QLabel(&quot;xixi&quot;, this));</span><br></pre></td></tr></table></figure>\n<h3 id=\"设置核心控件和浮动窗口\"><a href=\"#设置核心控件和浮动窗口\" class=\"headerlink\" title=\"设置核心控件和浮动窗口\"></a>设置核心控件和浮动窗口</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">QTextEdit *textEdit = new QTextEdit(this);</span><br><span class=\"line\">   //将文本编辑设为核心控件</span><br><span class=\"line\">   setCentralWidget(textEdit);</span><br><span class=\"line\">   </span><br><span class=\"line\">   //浮动窗口</span><br><span class=\"line\">   QDockWidget *dock = new QDockWidget(this);</span><br><span class=\"line\">   addDockWidget(Qt::LeftDockWidgetArea, dock);</span><br></pre></td></tr></table></figure>\n<h3 id=\"对话框\"><a href=\"#对话框\" class=\"headerlink\" title=\"对话框\"></a>对话框</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//一、模态对话框</span><br><span class=\"line\">//模态对话框，使用exex()调用，无法操作当前窗口，关闭窗口后才能继续运行MainWindow代码</span><br><span class=\"line\">QDialog dlg;</span><br><span class=\"line\">dlg.exec();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//二、非模态对话框</span><br><span class=\"line\">//非模态对话框，使用show()调用，不会阻塞MainWindow代码</span><br><span class=\"line\"></span><br><span class=\"line\">错误写法如下：对话框一闪而过</span><br><span class=\"line\">QDialog dlg;</span><br><span class=\"line\">dlg.show();</span><br><span class=\"line\"></span><br><span class=\"line\">修正写法：</span><br><span class=\"line\">1、使用new创建对象，缺点是不能主动释放，生成太多对话框的话内存高</span><br><span class=\"line\">QDialog *dlg = new QDialog(this);</span><br><span class=\"line\">dlg-&gt;show();</span><br><span class=\"line\"></span><br><span class=\"line\">2、将QDialog设为成员变量，直接调用show()</span><br><span class=\"line\"></span><br><span class=\"line\">3、将QDialog属性设置为关闭时释放,即方法1的修正写法</span><br><span class=\"line\">QDialog *dlg = new QDialog;</span><br><span class=\"line\">dlg-&gt;setAttribute(Qt::WA_DeleteOnClose);</span><br><span class=\"line\">dlg-&gt;show();</span><br></pre></td></tr></table></figure>\n<h3 id=\"选择弹框\"><a href=\"#选择弹框\" class=\"headerlink\" title=\"选择弹框\"></a>选择弹框</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//多个按钮由|分隔，选择的按钮存在于返回值中</span><br><span class=\"line\">    int ret = QMessageBox::warning(this, tr(&quot;MyApplication&quot;), tr(&quot;The document has been modified.\\n&quot; &quot;Do you want to save your changes?&quot;),</span><br><span class=\"line\">QMessageBox::Save | QMessageBox::Discard | QMessageBox::Cancel, QMessageBox::Save);</span><br><span class=\"line\">\t//枚举返回值进行相应处理</span><br><span class=\"line\">    switch (ret) &#123;</span><br><span class=\"line\">        case QMessageBox::Save:</span><br><span class=\"line\">            qDebug() &lt;&lt; &quot;save&quot;;</span><br><span class=\"line\">        break;</span><br><span class=\"line\">        case QMessageBox::Discard:</span><br><span class=\"line\">            qDebug() &lt;&lt; &quot;Discard&quot;;</span><br><span class=\"line\">         break;</span><br><span class=\"line\">        case QMessageBox::Cancel:</span><br><span class=\"line\">            qDebug() &lt;&lt; &quot;Cancel&quot;;</span><br><span class=\"line\">        break;</span><br><span class=\"line\">    default:</span><br><span class=\"line\">        break;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    //文件名选择框，返回选择的文件名</span><br><span class=\"line\">    QString fileName = QFileDialog::getOpenFileName(this,tr(&quot;Open Image&quot;), &quot;../&quot;, tr(&quot;Image Files (*.png *.jpg *.bmp)&quot;));</span><br><span class=\"line\">    qDebug() &lt;&lt; fileName;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>MainWindow 是QT创建应用程序三种界面中的一种，也是比较常用的一种。与QWidget相比，MainWindow自带了许多控件，如QMenuBar、QToolBar、QStatusBar等等。</p>\n<h3 id=\"菜单栏\"><a href=\"#菜单栏\" class=\"headerlink\" title=\"菜单栏\"></a>菜单栏</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//获取菜单栏</span><br><span class=\"line\">QMenuBar *mBar = menuBar();</span><br><span class=\"line\">//添加菜单</span><br><span class=\"line\">QMenu *pFile = mBar-&gt;addMenu(QString(&quot;File&quot;));</span><br><span class=\"line\">//菜单下拉选项</span><br><span class=\"line\">QAction *pNew = pFile-&gt;addAction(QString(&quot;New&quot;));</span><br><span class=\"line\">//选项绑定事件</span><br><span class=\"line\">connect(pNew, &amp;QAction::triggered,</span><br><span class=\"line\">      \t[=]() &#123;</span><br><span class=\"line\">\t\t\tqDebug() &lt;&lt; &quot;New&quot;;</span><br><span class=\"line\">      \t&#125;</span><br><span class=\"line\">);</span><br><span class=\"line\">    </span><br><span class=\"line\">//菜单添加分割线</span><br><span class=\"line\">pFile-&gt;addSeparator();</span><br><span class=\"line\"></span><br><span class=\"line\">//添加另一个下拉选项和对应的事件</span><br><span class=\"line\">QAction *pOpen = pFile-&gt;addAction(QString(&quot;Open&quot;));</span><br><span class=\"line\">connect(pOpen, &amp;QAction::triggered,</span><br><span class=\"line\">        [=]() &#123;</span><br><span class=\"line\">                qDebug() &lt;&lt; &quot;Open&quot;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<h3 id=\"工具栏\"><a href=\"#工具栏\" class=\"headerlink\" title=\"工具栏\"></a>工具栏</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//工具栏， 菜单栏对应的快捷方式</span><br><span class=\"line\">   QToolBar *toolBar = addToolBar(&quot;toolBar&quot;);</span><br><span class=\"line\">   //工具栏添加快捷键</span><br><span class=\"line\">   toolBar-&gt;addAction(pNew);</span><br><span class=\"line\">   toolBar-&gt;addAction(pOpen);</span><br><span class=\"line\"></span><br><span class=\"line\">   QPushButton *b = new QPushButton(this);</span><br><span class=\"line\">   b-&gt;setText(&quot;*_*&quot;);</span><br><span class=\"line\">   //添加小控件</span><br><span class=\"line\">   toolBar-&gt;addWidget(b);</span><br><span class=\"line\">   connect(b, &amp;QPushButton::clicked,</span><br><span class=\"line\">           [=]()&#123;</span><br><span class=\"line\">       b-&gt;setText(&quot;^-^&quot;);</span><br><span class=\"line\">   &#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"状态栏\"><a href=\"#状态栏\" class=\"headerlink\" title=\"状态栏\"></a>状态栏</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//状态栏</span><br><span class=\"line\">QStatusBar *sbar = statusBar();</span><br><span class=\"line\">QLabel *label = new QLabel(this);</span><br><span class=\"line\">label-&gt;setText(&quot;long long time ago&quot;);</span><br><span class=\"line\">sbar-&gt;addWidget(label);</span><br><span class=\"line\">//从左往右加</span><br><span class=\"line\">sbar-&gt;addWidget(new QLabel(&quot;hehe&quot;, this));</span><br><span class=\"line\">//从右往左加</span><br><span class=\"line\">sbar-&gt;addPermanentWidget(new QLabel(&quot;xixi&quot;, this));</span><br></pre></td></tr></table></figure>\n<h3 id=\"设置核心控件和浮动窗口\"><a href=\"#设置核心控件和浮动窗口\" class=\"headerlink\" title=\"设置核心控件和浮动窗口\"></a>设置核心控件和浮动窗口</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">QTextEdit *textEdit = new QTextEdit(this);</span><br><span class=\"line\">   //将文本编辑设为核心控件</span><br><span class=\"line\">   setCentralWidget(textEdit);</span><br><span class=\"line\">   </span><br><span class=\"line\">   //浮动窗口</span><br><span class=\"line\">   QDockWidget *dock = new QDockWidget(this);</span><br><span class=\"line\">   addDockWidget(Qt::LeftDockWidgetArea, dock);</span><br></pre></td></tr></table></figure>\n<h3 id=\"对话框\"><a href=\"#对话框\" class=\"headerlink\" title=\"对话框\"></a>对话框</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//一、模态对话框</span><br><span class=\"line\">//模态对话框，使用exex()调用，无法操作当前窗口，关闭窗口后才能继续运行MainWindow代码</span><br><span class=\"line\">QDialog dlg;</span><br><span class=\"line\">dlg.exec();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//二、非模态对话框</span><br><span class=\"line\">//非模态对话框，使用show()调用，不会阻塞MainWindow代码</span><br><span class=\"line\"></span><br><span class=\"line\">错误写法如下：对话框一闪而过</span><br><span class=\"line\">QDialog dlg;</span><br><span class=\"line\">dlg.show();</span><br><span class=\"line\"></span><br><span class=\"line\">修正写法：</span><br><span class=\"line\">1、使用new创建对象，缺点是不能主动释放，生成太多对话框的话内存高</span><br><span class=\"line\">QDialog *dlg = new QDialog(this);</span><br><span class=\"line\">dlg-&gt;show();</span><br><span class=\"line\"></span><br><span class=\"line\">2、将QDialog设为成员变量，直接调用show()</span><br><span class=\"line\"></span><br><span class=\"line\">3、将QDialog属性设置为关闭时释放,即方法1的修正写法</span><br><span class=\"line\">QDialog *dlg = new QDialog;</span><br><span class=\"line\">dlg-&gt;setAttribute(Qt::WA_DeleteOnClose);</span><br><span class=\"line\">dlg-&gt;show();</span><br></pre></td></tr></table></figure>\n<h3 id=\"选择弹框\"><a href=\"#选择弹框\" class=\"headerlink\" title=\"选择弹框\"></a>选择弹框</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//多个按钮由|分隔，选择的按钮存在于返回值中</span><br><span class=\"line\">    int ret = QMessageBox::warning(this, tr(&quot;MyApplication&quot;), tr(&quot;The document has been modified.\\n&quot; &quot;Do you want to save your changes?&quot;),</span><br><span class=\"line\">QMessageBox::Save | QMessageBox::Discard | QMessageBox::Cancel, QMessageBox::Save);</span><br><span class=\"line\">\t//枚举返回值进行相应处理</span><br><span class=\"line\">    switch (ret) &#123;</span><br><span class=\"line\">        case QMessageBox::Save:</span><br><span class=\"line\">            qDebug() &lt;&lt; &quot;save&quot;;</span><br><span class=\"line\">        break;</span><br><span class=\"line\">        case QMessageBox::Discard:</span><br><span class=\"line\">            qDebug() &lt;&lt; &quot;Discard&quot;;</span><br><span class=\"line\">         break;</span><br><span class=\"line\">        case QMessageBox::Cancel:</span><br><span class=\"line\">            qDebug() &lt;&lt; &quot;Cancel&quot;;</span><br><span class=\"line\">        break;</span><br><span class=\"line\">    default:</span><br><span class=\"line\">        break;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    //文件名选择框，返回选择的文件名</span><br><span class=\"line\">    QString fileName = QFileDialog::getOpenFileName(this,tr(&quot;Open Image&quot;), &quot;../&quot;, tr(&quot;Image Files (*.png *.jpg *.bmp)&quot;));</span><br><span class=\"line\">    qDebug() &lt;&lt; fileName;</span><br></pre></td></tr></table></figure>\n"},{"title":"QT基础4——可视化编程","author":"Cyrus","date":"2018-12-16T14:37:00.000Z","_content":"前面的视图都是使用代码创建，QT也支持可视化编程，且性能强大。只需要在创建项目时勾选“创建界面”（默认勾选），生成的项目中就会自动生成支持可视化编程的.ui文件。\n\n点击左侧“设计”按钮，.ui的样式如下：\n![](design_all.png)\n\n### 控件区\n* Layouts 布局区，少用\n\n* Spacers 填补布局时的间隙，缩放界面时自适应（详看上图）\n\n1、Horizontal Spacer 可以填补水平间隙\n\n2、Vertical Spacer\t可以填补垂直间隙\n\n* Buttons\n\n1、Push Button\t常用按钮\n\n2、Tool Button \n\n3、Radio Button 单选按钮，必须处于同一父视图同一层级\n\n4、Check Box\t多选按钮\n\n* Item Views 和 Item Widgets\n\n* Containers 各种可以作为父视图的控件\n\n* Input Widgets 各种输入控件\n\n* Display Widgets 各种展示类控件\n\n示例\n![](design_add.png) ![](design_result.png)\n\n### 视图层级区\n可以查看当前窗口的所有视图及相应的层级分布，layout状态。可以修改相应控件的名称及进行其他操作。\n\n### 控件属性区\n属性区由控件的继承关系从上到下展示控件的可编辑属性，如控件名称，控件大小，是否可拉伸等等。\n\n### 信号和槽区\n信号和槽区可以对窗口控件直接添可信号和相当的槽响应，无需编写Connect函数。\n\n### 代码调用.ui文件创建的控件\n```\nMainWindow::MainWindow(QWidget *parent) :\n    QMainWindow(parent),\n    ui(new Ui::MainWindow)\n{\n\t//ui文件初始化，勾选“创建界面”后系统自动生成\n    ui->setupUi(this);\n\n\t//ui->控件名，可以选取相应控件的指针，控件名可以在“视图层级区”查看及修改\n    ui->myButton->setText(\"我了个去\");\n}\n```\n\n### 创建按钮槽事件\n选择相应的按钮（如myButton)，右键，转到槽，选择相应的按钮信号（如released()），就会自动生成槽函数 void on_按钮名_信号名（）。\n```\n.h文件\nprivate slots:\n    void on_myButton_released();\n    \n.cpp文件\nvoid MainWindow::on_myButton_released()\n{\n    \n}\n```\n也可以创建好相应的槽函数后，在信号与槽编辑区直接添加绑定，不用调用Connect函数\n![](design_slot.png)\n\n### 在ui界面中使用自定义类\n* 1、创建自定义类子类，如QPushButton子类 MyButton\n* 2、选中一个QPushButton，右键->提升为，填写“提升的类名称”->MyButton， 勾选“全局包含”， 点击“添加”, 再点击“提升”即可。\n\n将自定义降为父类：选中提升后的控件，右键选择“选择xxx的提升”。\n\n\n","source":"_posts/QT基础4——可视化编程.md","raw":"title: QT基础4——可视化编程\nauthor: Cyrus\ntags: []\ncategories:\n  - QT\ndate: 2018-12-16 22:37:00\n---\n前面的视图都是使用代码创建，QT也支持可视化编程，且性能强大。只需要在创建项目时勾选“创建界面”（默认勾选），生成的项目中就会自动生成支持可视化编程的.ui文件。\n\n点击左侧“设计”按钮，.ui的样式如下：\n![](design_all.png)\n\n### 控件区\n* Layouts 布局区，少用\n\n* Spacers 填补布局时的间隙，缩放界面时自适应（详看上图）\n\n1、Horizontal Spacer 可以填补水平间隙\n\n2、Vertical Spacer\t可以填补垂直间隙\n\n* Buttons\n\n1、Push Button\t常用按钮\n\n2、Tool Button \n\n3、Radio Button 单选按钮，必须处于同一父视图同一层级\n\n4、Check Box\t多选按钮\n\n* Item Views 和 Item Widgets\n\n* Containers 各种可以作为父视图的控件\n\n* Input Widgets 各种输入控件\n\n* Display Widgets 各种展示类控件\n\n示例\n![](design_add.png) ![](design_result.png)\n\n### 视图层级区\n可以查看当前窗口的所有视图及相应的层级分布，layout状态。可以修改相应控件的名称及进行其他操作。\n\n### 控件属性区\n属性区由控件的继承关系从上到下展示控件的可编辑属性，如控件名称，控件大小，是否可拉伸等等。\n\n### 信号和槽区\n信号和槽区可以对窗口控件直接添可信号和相当的槽响应，无需编写Connect函数。\n\n### 代码调用.ui文件创建的控件\n```\nMainWindow::MainWindow(QWidget *parent) :\n    QMainWindow(parent),\n    ui(new Ui::MainWindow)\n{\n\t//ui文件初始化，勾选“创建界面”后系统自动生成\n    ui->setupUi(this);\n\n\t//ui->控件名，可以选取相应控件的指针，控件名可以在“视图层级区”查看及修改\n    ui->myButton->setText(\"我了个去\");\n}\n```\n\n### 创建按钮槽事件\n选择相应的按钮（如myButton)，右键，转到槽，选择相应的按钮信号（如released()），就会自动生成槽函数 void on_按钮名_信号名（）。\n```\n.h文件\nprivate slots:\n    void on_myButton_released();\n    \n.cpp文件\nvoid MainWindow::on_myButton_released()\n{\n    \n}\n```\n也可以创建好相应的槽函数后，在信号与槽编辑区直接添加绑定，不用调用Connect函数\n![](design_slot.png)\n\n### 在ui界面中使用自定义类\n* 1、创建自定义类子类，如QPushButton子类 MyButton\n* 2、选中一个QPushButton，右键->提升为，填写“提升的类名称”->MyButton， 勾选“全局包含”， 点击“添加”, 再点击“提升”即可。\n\n将自定义降为父类：选中提升后的控件，右键选择“选择xxx的提升”。\n\n\n","slug":"QT基础4——可视化编程","published":1,"updated":"2019-07-09T08:13:34.939Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyzlbt8h000x0j66w16723ma","content":"<p>前面的视图都是使用代码创建，QT也支持可视化编程，且性能强大。只需要在创建项目时勾选“创建界面”（默认勾选），生成的项目中就会自动生成支持可视化编程的.ui文件。</p>\n<p>点击左侧“设计”按钮，.ui的样式如下：<br><img src=\"//www.cyrus.fun/2018/12/16/QT基础4——可视化编程/design_all.png\" alt=\"\"></p>\n<h3 id=\"控件区\"><a href=\"#控件区\" class=\"headerlink\" title=\"控件区\"></a>控件区</h3><ul>\n<li><p>Layouts 布局区，少用</p>\n</li>\n<li><p>Spacers 填补布局时的间隙，缩放界面时自适应（详看上图）</p>\n</li>\n</ul>\n<p>1、Horizontal Spacer 可以填补水平间隙</p>\n<p>2、Vertical Spacer    可以填补垂直间隙</p>\n<ul>\n<li>Buttons</li>\n</ul>\n<p>1、Push Button    常用按钮</p>\n<p>2、Tool Button </p>\n<p>3、Radio Button 单选按钮，必须处于同一父视图同一层级</p>\n<p>4、Check Box    多选按钮</p>\n<ul>\n<li><p>Item Views 和 Item Widgets</p>\n</li>\n<li><p>Containers 各种可以作为父视图的控件</p>\n</li>\n<li><p>Input Widgets 各种输入控件</p>\n</li>\n<li><p>Display Widgets 各种展示类控件</p>\n</li>\n</ul>\n<p>示例<br><img src=\"//www.cyrus.fun/2018/12/16/QT基础4——可视化编程/design_add.png\" alt=\"\"> <img src=\"//www.cyrus.fun/2018/12/16/QT基础4——可视化编程/design_result.png\" alt=\"\"></p>\n<h3 id=\"视图层级区\"><a href=\"#视图层级区\" class=\"headerlink\" title=\"视图层级区\"></a>视图层级区</h3><p>可以查看当前窗口的所有视图及相应的层级分布，layout状态。可以修改相应控件的名称及进行其他操作。</p>\n<h3 id=\"控件属性区\"><a href=\"#控件属性区\" class=\"headerlink\" title=\"控件属性区\"></a>控件属性区</h3><p>属性区由控件的继承关系从上到下展示控件的可编辑属性，如控件名称，控件大小，是否可拉伸等等。</p>\n<h3 id=\"信号和槽区\"><a href=\"#信号和槽区\" class=\"headerlink\" title=\"信号和槽区\"></a>信号和槽区</h3><p>信号和槽区可以对窗口控件直接添可信号和相当的槽响应，无需编写Connect函数。</p>\n<h3 id=\"代码调用-ui文件创建的控件\"><a href=\"#代码调用-ui文件创建的控件\" class=\"headerlink\" title=\"代码调用.ui文件创建的控件\"></a>代码调用.ui文件创建的控件</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MainWindow::MainWindow(QWidget *parent) :</span><br><span class=\"line\">    QMainWindow(parent),</span><br><span class=\"line\">    ui(new Ui::MainWindow)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t//ui文件初始化，勾选“创建界面”后系统自动生成</span><br><span class=\"line\">    ui-&gt;setupUi(this);</span><br><span class=\"line\"></span><br><span class=\"line\">\t//ui-&gt;控件名，可以选取相应控件的指针，控件名可以在“视图层级区”查看及修改</span><br><span class=\"line\">    ui-&gt;myButton-&gt;setText(&quot;我了个去&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"创建按钮槽事件\"><a href=\"#创建按钮槽事件\" class=\"headerlink\" title=\"创建按钮槽事件\"></a>创建按钮槽事件</h3><p>选择相应的按钮（如myButton)，右键，转到槽，选择相应的按钮信号（如released()），就会自动生成槽函数 void on_按钮名_信号名（）。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.h文件</span><br><span class=\"line\">private slots:</span><br><span class=\"line\">    void on_myButton_released();</span><br><span class=\"line\">    </span><br><span class=\"line\">.cpp文件</span><br><span class=\"line\">void MainWindow::on_myButton_released()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>也可以创建好相应的槽函数后，在信号与槽编辑区直接添加绑定，不用调用Connect函数<br><img src=\"//www.cyrus.fun/2018/12/16/QT基础4——可视化编程/design_slot.png\" alt=\"\"></p>\n<h3 id=\"在ui界面中使用自定义类\"><a href=\"#在ui界面中使用自定义类\" class=\"headerlink\" title=\"在ui界面中使用自定义类\"></a>在ui界面中使用自定义类</h3><ul>\n<li>1、创建自定义类子类，如QPushButton子类 MyButton</li>\n<li>2、选中一个QPushButton，右键-&gt;提升为，填写“提升的类名称”-&gt;MyButton， 勾选“全局包含”， 点击“添加”, 再点击“提升”即可。</li>\n</ul>\n<p>将自定义降为父类：选中提升后的控件，右键选择“选择xxx的提升”。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>前面的视图都是使用代码创建，QT也支持可视化编程，且性能强大。只需要在创建项目时勾选“创建界面”（默认勾选），生成的项目中就会自动生成支持可视化编程的.ui文件。</p>\n<p>点击左侧“设计”按钮，.ui的样式如下：<br><img src=\"//www.cyrus.fun/2018/12/16/QT基础4——可视化编程/design_all.png\" alt=\"\"></p>\n<h3 id=\"控件区\"><a href=\"#控件区\" class=\"headerlink\" title=\"控件区\"></a>控件区</h3><ul>\n<li><p>Layouts 布局区，少用</p>\n</li>\n<li><p>Spacers 填补布局时的间隙，缩放界面时自适应（详看上图）</p>\n</li>\n</ul>\n<p>1、Horizontal Spacer 可以填补水平间隙</p>\n<p>2、Vertical Spacer    可以填补垂直间隙</p>\n<ul>\n<li>Buttons</li>\n</ul>\n<p>1、Push Button    常用按钮</p>\n<p>2、Tool Button </p>\n<p>3、Radio Button 单选按钮，必须处于同一父视图同一层级</p>\n<p>4、Check Box    多选按钮</p>\n<ul>\n<li><p>Item Views 和 Item Widgets</p>\n</li>\n<li><p>Containers 各种可以作为父视图的控件</p>\n</li>\n<li><p>Input Widgets 各种输入控件</p>\n</li>\n<li><p>Display Widgets 各种展示类控件</p>\n</li>\n</ul>\n<p>示例<br><img src=\"//www.cyrus.fun/2018/12/16/QT基础4——可视化编程/design_add.png\" alt=\"\"> <img src=\"//www.cyrus.fun/2018/12/16/QT基础4——可视化编程/design_result.png\" alt=\"\"></p>\n<h3 id=\"视图层级区\"><a href=\"#视图层级区\" class=\"headerlink\" title=\"视图层级区\"></a>视图层级区</h3><p>可以查看当前窗口的所有视图及相应的层级分布，layout状态。可以修改相应控件的名称及进行其他操作。</p>\n<h3 id=\"控件属性区\"><a href=\"#控件属性区\" class=\"headerlink\" title=\"控件属性区\"></a>控件属性区</h3><p>属性区由控件的继承关系从上到下展示控件的可编辑属性，如控件名称，控件大小，是否可拉伸等等。</p>\n<h3 id=\"信号和槽区\"><a href=\"#信号和槽区\" class=\"headerlink\" title=\"信号和槽区\"></a>信号和槽区</h3><p>信号和槽区可以对窗口控件直接添可信号和相当的槽响应，无需编写Connect函数。</p>\n<h3 id=\"代码调用-ui文件创建的控件\"><a href=\"#代码调用-ui文件创建的控件\" class=\"headerlink\" title=\"代码调用.ui文件创建的控件\"></a>代码调用.ui文件创建的控件</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MainWindow::MainWindow(QWidget *parent) :</span><br><span class=\"line\">    QMainWindow(parent),</span><br><span class=\"line\">    ui(new Ui::MainWindow)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t//ui文件初始化，勾选“创建界面”后系统自动生成</span><br><span class=\"line\">    ui-&gt;setupUi(this);</span><br><span class=\"line\"></span><br><span class=\"line\">\t//ui-&gt;控件名，可以选取相应控件的指针，控件名可以在“视图层级区”查看及修改</span><br><span class=\"line\">    ui-&gt;myButton-&gt;setText(&quot;我了个去&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"创建按钮槽事件\"><a href=\"#创建按钮槽事件\" class=\"headerlink\" title=\"创建按钮槽事件\"></a>创建按钮槽事件</h3><p>选择相应的按钮（如myButton)，右键，转到槽，选择相应的按钮信号（如released()），就会自动生成槽函数 void on_按钮名_信号名（）。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.h文件</span><br><span class=\"line\">private slots:</span><br><span class=\"line\">    void on_myButton_released();</span><br><span class=\"line\">    </span><br><span class=\"line\">.cpp文件</span><br><span class=\"line\">void MainWindow::on_myButton_released()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>也可以创建好相应的槽函数后，在信号与槽编辑区直接添加绑定，不用调用Connect函数<br><img src=\"//www.cyrus.fun/2018/12/16/QT基础4——可视化编程/design_slot.png\" alt=\"\"></p>\n<h3 id=\"在ui界面中使用自定义类\"><a href=\"#在ui界面中使用自定义类\" class=\"headerlink\" title=\"在ui界面中使用自定义类\"></a>在ui界面中使用自定义类</h3><ul>\n<li>1、创建自定义类子类，如QPushButton子类 MyButton</li>\n<li>2、选中一个QPushButton，右键-&gt;提升为，填写“提升的类名称”-&gt;MyButton， 勾选“全局包含”， 点击“添加”, 再点击“提升”即可。</li>\n</ul>\n<p>将自定义降为父类：选中提升后的控件，右键选择“选择xxx的提升”。</p>\n"},{"title":"QT基础5——事件处理","author":"Cyrus","date":"2018-12-20T14:15:00.000Z","_content":"QT的事件是由事件基类QEvent派生出来的，而控件的事件是从QObject和QWidget继续来的虚函数，可以重写实现。\n\n### 控件事件\n示例代码：\n```\n//.h文件\n#ifndef EVENTLABEL_H\n#define EVENTLABEL_H\n\n#include <QObject>\n#include <QLabel>\n#include <QWidget>\n\nclass EventLabel : public QLabel\n{\n    Q_OBJECT\npublic:\n    explicit EventLabel(QWidget *parent = nullptr);\n\nprotected:\n\t//鼠标按下事件\n    void mousePressEvent(QMouseEvent *ev);\n\t//鼠标移动事件\n    void mouseMoveEvent(QMouseEvent *event);\n\t//鼠标释放事件\n    void mouseReleaseEvent(QMouseEvent *event);\n\t//鼠标离开控件事件 virtual关键字可写可不写\n    virtual void leaveEvent(QEvent *event);\n\t//鼠标进入控件事件\n    virtual void enterEvent(QEvent *event);\n\nsignals:\n\npublic slots:\n};\n\n#endif // EVENTLABEL_H\n\n\n\n.cpp 文件\n#include \"eventlabel.h\"\n#include <QMouseEvent>\n#include <QDebug>\n\nEventLabel::EventLabel(QWidget *parent) : QLabel(parent)\n{\n\n}\n\nvoid EventLabel::mousePressEvent(QMouseEvent *ev)\n{\n    int i = ev->x();\n    int j = ev->y();\n\n    if (ev->button() == Qt::LeftButton) {\n        qDebug() << \"left\";\n    } else if (ev->button() == Qt::RightButton) {\n        qDebug() << \"Right\";\n    } else if (ev->button() == Qt::MidButton) {\n        qDebug() << \"Mid\";\n    }\n\n    QString text = QString(\"<center><h1>Mouse Press: (%1, %2)</h1></center>\").arg(i).arg(j);\n    this->setText(text);\n}\n\nvoid EventLabel::mouseReleaseEvent(QMouseEvent *ev) {\n    QString text = QString(\"<center><h1>Mouse Release: (%1, %2)</h1></center>\").arg(ev->x()).arg(ev->y());\n    this->setText(text);\n\n}\n\nvoid EventLabel::mouseMoveEvent(QMouseEvent *ev)\n{\n    QString text = QString(\"<center><h1>Mouse Move: (%1, %2)</h1></center>\").arg(ev->x()).arg(ev->y());\n    this->setText(text);\n}\n\nvoid EventLabel::leaveEvent(QEvent *event)\n{\n    QString text = QString(\"<center><h1>leave</h1></center>\");\n    this->setText(text);\n}\n\nvoid EventLabel::enterEvent(QEvent *event)\n{\n    QString text = QString(\"<center><h1>enter</h1></center>\");\n    this->setText(text);\n}\n```\n\n### 键盘事件\n```\n.h文件\nprotected:\n    void keyPressEvent(QKeyEvent *);\n    \n.cpp 文件\nvoid MainWindow::keyPressEvent(QKeyEvent *e)\n{\n\t//QKeyEvent 键盘按键事件\n    //e->key() 被下的按键\n    //Qt::Key_x   键盘按键的枚举值\n    qDebug() << (char)e->key();\n    if (e->key() == Qt::Key_A)\n    {\n        qDebug() << \"Qt::Key_A\";\n    }\n}\n```\n\n### 定时器事件\n```\n.h 文件\nprotected:\n\tvoid timerEvent(QTimerEvent *e);\n    \nprivate:\n\tint timerID;\n    \n    \n.cpp 文件\n//启动定时器,单位为ms\ntimerID = this->startTimer(1000);\n\n//定时器处理函数，所有定时器事件都通过些函数处理，不像OC的NSTimer单独指定\nvoid MainWindow::timerEvent(QTimerEvent *e)\n{\n\t//e->timerId()获取触发事件的定时器\n    if (timerID == e->timerId()) {  \n        static int sec = 0;\n        sec++;\n\n        ui->label->setText(QString(\"<center><h1>timer out: %1</h1></center>\").arg(sec));\n\n        if (sec == 5) {\n        \t//关闭定时器\n            killTimer(timerID);\n        }\n    }\n}\n```\n\n### 事件的接收和忽略\n```\n//e->accept() 接收事件，即处理事件\n//e->ignore() 忽略事件，不处理\nvoid MainWindow::closeEvent(QCloseEvent *e) {\n    int ret = QMessageBox::question(this, \"question\", \"是否关闭窗口\");\n    if(ret == QMessageBox::Yes) {\n        //接收事件，执行事件， 事件不再传递，关闭事件->关闭窗口\n        e->accept();\n    } else {\n        //忽略事件，事件传递给父组件直到找到事件接收者或者无父组件丢弃\n        e->ignore();\n    }\n}\n```\n\n### 事件分发\n```\n\n  class MyClass : public QWidget\n  {\n      Q_OBJECT\n\n  public:\n      MyClass(QWidget *parent = 0);\n      ~MyClass();\n\n\t\t//事件处理函数 返回true停止事件传递， false 继续事件传递\n      bool event(QEvent* ev) override\n      {\t\n      \t//判断事件类型，分发给相应的处理函数\n          if (ev->type() == QEvent::PolishRequest) {\n              // overwrite handling of PolishRequest if any\n              doThings();\n              return true;\n          } else  if (ev->type() == QEvent::Show) {\n              // complement handling of Show if any\n              doThings2();\n              //调用父类处理函数，即进行默认处理\n              QWidget::event(ev);\n              return true;\n          }\n          // Make sure the rest of events are handled\n          //调用父类处理函数，即进行默认处理\n          return QWidget::event(ev);\n      }\n  };\n```\n\n\n### 事件过滤器\n```\n  class MainWindow : public QMainWindow\n  {\n  public:\n      MainWindow();\n\n  protected:\n  //1、重写事件过滤函数\n      bool eventFilter(QObject *obj, QEvent *ev) override;\n\n  private:\n      QTextEdit *textEdit;\n  };\n\n  MainWindow::MainWindow()\n  {\n      textEdit = new QTextEdit;\n      setCentralWidget(textEdit);\n      \n\t//2、控件初始化过滤\n      textEdit->installEventFilter(this);\n  }\n\n//3、具体事件处理\n  bool MainWindow::eventFilter(QObject *obj, QEvent *event)\n  {\n      if (obj == textEdit) {\n          if (event->type() == QEvent::KeyPress) {\n              QKeyEvent *keyEvent = static_cast<QKeyEvent*>(event);\n              qDebug() << \"Ate key press\" << keyEvent->key();\n              return true;\n          } else {\n              return false;\n          }\n      } else {\n          // pass the event on to the parent class\n          return QMainWindow::eventFilter(obj, event);\n      }\n  }\n```","source":"_posts/QT基础5——事件处理.md","raw":"title: QT基础5——事件处理\nauthor: Cyrus\ntags: []\ncategories:\n  - QT\ndate: 2018-12-20 22:15:00\n---\nQT的事件是由事件基类QEvent派生出来的，而控件的事件是从QObject和QWidget继续来的虚函数，可以重写实现。\n\n### 控件事件\n示例代码：\n```\n//.h文件\n#ifndef EVENTLABEL_H\n#define EVENTLABEL_H\n\n#include <QObject>\n#include <QLabel>\n#include <QWidget>\n\nclass EventLabel : public QLabel\n{\n    Q_OBJECT\npublic:\n    explicit EventLabel(QWidget *parent = nullptr);\n\nprotected:\n\t//鼠标按下事件\n    void mousePressEvent(QMouseEvent *ev);\n\t//鼠标移动事件\n    void mouseMoveEvent(QMouseEvent *event);\n\t//鼠标释放事件\n    void mouseReleaseEvent(QMouseEvent *event);\n\t//鼠标离开控件事件 virtual关键字可写可不写\n    virtual void leaveEvent(QEvent *event);\n\t//鼠标进入控件事件\n    virtual void enterEvent(QEvent *event);\n\nsignals:\n\npublic slots:\n};\n\n#endif // EVENTLABEL_H\n\n\n\n.cpp 文件\n#include \"eventlabel.h\"\n#include <QMouseEvent>\n#include <QDebug>\n\nEventLabel::EventLabel(QWidget *parent) : QLabel(parent)\n{\n\n}\n\nvoid EventLabel::mousePressEvent(QMouseEvent *ev)\n{\n    int i = ev->x();\n    int j = ev->y();\n\n    if (ev->button() == Qt::LeftButton) {\n        qDebug() << \"left\";\n    } else if (ev->button() == Qt::RightButton) {\n        qDebug() << \"Right\";\n    } else if (ev->button() == Qt::MidButton) {\n        qDebug() << \"Mid\";\n    }\n\n    QString text = QString(\"<center><h1>Mouse Press: (%1, %2)</h1></center>\").arg(i).arg(j);\n    this->setText(text);\n}\n\nvoid EventLabel::mouseReleaseEvent(QMouseEvent *ev) {\n    QString text = QString(\"<center><h1>Mouse Release: (%1, %2)</h1></center>\").arg(ev->x()).arg(ev->y());\n    this->setText(text);\n\n}\n\nvoid EventLabel::mouseMoveEvent(QMouseEvent *ev)\n{\n    QString text = QString(\"<center><h1>Mouse Move: (%1, %2)</h1></center>\").arg(ev->x()).arg(ev->y());\n    this->setText(text);\n}\n\nvoid EventLabel::leaveEvent(QEvent *event)\n{\n    QString text = QString(\"<center><h1>leave</h1></center>\");\n    this->setText(text);\n}\n\nvoid EventLabel::enterEvent(QEvent *event)\n{\n    QString text = QString(\"<center><h1>enter</h1></center>\");\n    this->setText(text);\n}\n```\n\n### 键盘事件\n```\n.h文件\nprotected:\n    void keyPressEvent(QKeyEvent *);\n    \n.cpp 文件\nvoid MainWindow::keyPressEvent(QKeyEvent *e)\n{\n\t//QKeyEvent 键盘按键事件\n    //e->key() 被下的按键\n    //Qt::Key_x   键盘按键的枚举值\n    qDebug() << (char)e->key();\n    if (e->key() == Qt::Key_A)\n    {\n        qDebug() << \"Qt::Key_A\";\n    }\n}\n```\n\n### 定时器事件\n```\n.h 文件\nprotected:\n\tvoid timerEvent(QTimerEvent *e);\n    \nprivate:\n\tint timerID;\n    \n    \n.cpp 文件\n//启动定时器,单位为ms\ntimerID = this->startTimer(1000);\n\n//定时器处理函数，所有定时器事件都通过些函数处理，不像OC的NSTimer单独指定\nvoid MainWindow::timerEvent(QTimerEvent *e)\n{\n\t//e->timerId()获取触发事件的定时器\n    if (timerID == e->timerId()) {  \n        static int sec = 0;\n        sec++;\n\n        ui->label->setText(QString(\"<center><h1>timer out: %1</h1></center>\").arg(sec));\n\n        if (sec == 5) {\n        \t//关闭定时器\n            killTimer(timerID);\n        }\n    }\n}\n```\n\n### 事件的接收和忽略\n```\n//e->accept() 接收事件，即处理事件\n//e->ignore() 忽略事件，不处理\nvoid MainWindow::closeEvent(QCloseEvent *e) {\n    int ret = QMessageBox::question(this, \"question\", \"是否关闭窗口\");\n    if(ret == QMessageBox::Yes) {\n        //接收事件，执行事件， 事件不再传递，关闭事件->关闭窗口\n        e->accept();\n    } else {\n        //忽略事件，事件传递给父组件直到找到事件接收者或者无父组件丢弃\n        e->ignore();\n    }\n}\n```\n\n### 事件分发\n```\n\n  class MyClass : public QWidget\n  {\n      Q_OBJECT\n\n  public:\n      MyClass(QWidget *parent = 0);\n      ~MyClass();\n\n\t\t//事件处理函数 返回true停止事件传递， false 继续事件传递\n      bool event(QEvent* ev) override\n      {\t\n      \t//判断事件类型，分发给相应的处理函数\n          if (ev->type() == QEvent::PolishRequest) {\n              // overwrite handling of PolishRequest if any\n              doThings();\n              return true;\n          } else  if (ev->type() == QEvent::Show) {\n              // complement handling of Show if any\n              doThings2();\n              //调用父类处理函数，即进行默认处理\n              QWidget::event(ev);\n              return true;\n          }\n          // Make sure the rest of events are handled\n          //调用父类处理函数，即进行默认处理\n          return QWidget::event(ev);\n      }\n  };\n```\n\n\n### 事件过滤器\n```\n  class MainWindow : public QMainWindow\n  {\n  public:\n      MainWindow();\n\n  protected:\n  //1、重写事件过滤函数\n      bool eventFilter(QObject *obj, QEvent *ev) override;\n\n  private:\n      QTextEdit *textEdit;\n  };\n\n  MainWindow::MainWindow()\n  {\n      textEdit = new QTextEdit;\n      setCentralWidget(textEdit);\n      \n\t//2、控件初始化过滤\n      textEdit->installEventFilter(this);\n  }\n\n//3、具体事件处理\n  bool MainWindow::eventFilter(QObject *obj, QEvent *event)\n  {\n      if (obj == textEdit) {\n          if (event->type() == QEvent::KeyPress) {\n              QKeyEvent *keyEvent = static_cast<QKeyEvent*>(event);\n              qDebug() << \"Ate key press\" << keyEvent->key();\n              return true;\n          } else {\n              return false;\n          }\n      } else {\n          // pass the event on to the parent class\n          return QMainWindow::eventFilter(obj, event);\n      }\n  }\n```","slug":"QT基础5——事件处理","published":1,"updated":"2019-07-09T08:13:34.942Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyzlbt8j00100j66ju4c3ezn","content":"<p>QT的事件是由事件基类QEvent派生出来的，而控件的事件是从QObject和QWidget继续来的虚函数，可以重写实现。</p>\n<h3 id=\"控件事件\"><a href=\"#控件事件\" class=\"headerlink\" title=\"控件事件\"></a>控件事件</h3><p>示例代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//.h文件</span><br><span class=\"line\">#ifndef EVENTLABEL_H</span><br><span class=\"line\">#define EVENTLABEL_H</span><br><span class=\"line\"></span><br><span class=\"line\">#include &lt;QObject&gt;</span><br><span class=\"line\">#include &lt;QLabel&gt;</span><br><span class=\"line\">#include &lt;QWidget&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">class EventLabel : public QLabel</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Q_OBJECT</span><br><span class=\"line\">public:</span><br><span class=\"line\">    explicit EventLabel(QWidget *parent = nullptr);</span><br><span class=\"line\"></span><br><span class=\"line\">protected:</span><br><span class=\"line\">\t//鼠标按下事件</span><br><span class=\"line\">    void mousePressEvent(QMouseEvent *ev);</span><br><span class=\"line\">\t//鼠标移动事件</span><br><span class=\"line\">    void mouseMoveEvent(QMouseEvent *event);</span><br><span class=\"line\">\t//鼠标释放事件</span><br><span class=\"line\">    void mouseReleaseEvent(QMouseEvent *event);</span><br><span class=\"line\">\t//鼠标离开控件事件 virtual关键字可写可不写</span><br><span class=\"line\">    virtual void leaveEvent(QEvent *event);</span><br><span class=\"line\">\t//鼠标进入控件事件</span><br><span class=\"line\">    virtual void enterEvent(QEvent *event);</span><br><span class=\"line\"></span><br><span class=\"line\">signals:</span><br><span class=\"line\"></span><br><span class=\"line\">public slots:</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">#endif // EVENTLABEL_H</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">.cpp 文件</span><br><span class=\"line\">#include &quot;eventlabel.h&quot;</span><br><span class=\"line\">#include &lt;QMouseEvent&gt;</span><br><span class=\"line\">#include &lt;QDebug&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">EventLabel::EventLabel(QWidget *parent) : QLabel(parent)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void EventLabel::mousePressEvent(QMouseEvent *ev)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int i = ev-&gt;x();</span><br><span class=\"line\">    int j = ev-&gt;y();</span><br><span class=\"line\"></span><br><span class=\"line\">    if (ev-&gt;button() == Qt::LeftButton) &#123;</span><br><span class=\"line\">        qDebug() &lt;&lt; &quot;left&quot;;</span><br><span class=\"line\">    &#125; else if (ev-&gt;button() == Qt::RightButton) &#123;</span><br><span class=\"line\">        qDebug() &lt;&lt; &quot;Right&quot;;</span><br><span class=\"line\">    &#125; else if (ev-&gt;button() == Qt::MidButton) &#123;</span><br><span class=\"line\">        qDebug() &lt;&lt; &quot;Mid&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    QString text = QString(&quot;&lt;center&gt;&lt;h1&gt;Mouse Press: (%1, %2)&lt;/h1&gt;&lt;/center&gt;&quot;).arg(i).arg(j);</span><br><span class=\"line\">    this-&gt;setText(text);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void EventLabel::mouseReleaseEvent(QMouseEvent *ev) &#123;</span><br><span class=\"line\">    QString text = QString(&quot;&lt;center&gt;&lt;h1&gt;Mouse Release: (%1, %2)&lt;/h1&gt;&lt;/center&gt;&quot;).arg(ev-&gt;x()).arg(ev-&gt;y());</span><br><span class=\"line\">    this-&gt;setText(text);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void EventLabel::mouseMoveEvent(QMouseEvent *ev)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    QString text = QString(&quot;&lt;center&gt;&lt;h1&gt;Mouse Move: (%1, %2)&lt;/h1&gt;&lt;/center&gt;&quot;).arg(ev-&gt;x()).arg(ev-&gt;y());</span><br><span class=\"line\">    this-&gt;setText(text);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void EventLabel::leaveEvent(QEvent *event)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    QString text = QString(&quot;&lt;center&gt;&lt;h1&gt;leave&lt;/h1&gt;&lt;/center&gt;&quot;);</span><br><span class=\"line\">    this-&gt;setText(text);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void EventLabel::enterEvent(QEvent *event)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    QString text = QString(&quot;&lt;center&gt;&lt;h1&gt;enter&lt;/h1&gt;&lt;/center&gt;&quot;);</span><br><span class=\"line\">    this-&gt;setText(text);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"键盘事件\"><a href=\"#键盘事件\" class=\"headerlink\" title=\"键盘事件\"></a>键盘事件</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.h文件</span><br><span class=\"line\">protected:</span><br><span class=\"line\">    void keyPressEvent(QKeyEvent *);</span><br><span class=\"line\">    </span><br><span class=\"line\">.cpp 文件</span><br><span class=\"line\">void MainWindow::keyPressEvent(QKeyEvent *e)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t//QKeyEvent 键盘按键事件</span><br><span class=\"line\">    //e-&gt;key() 被下的按键</span><br><span class=\"line\">    //Qt::Key_x   键盘按键的枚举值</span><br><span class=\"line\">    qDebug() &lt;&lt; (char)e-&gt;key();</span><br><span class=\"line\">    if (e-&gt;key() == Qt::Key_A)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        qDebug() &lt;&lt; &quot;Qt::Key_A&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"定时器事件\"><a href=\"#定时器事件\" class=\"headerlink\" title=\"定时器事件\"></a>定时器事件</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.h 文件</span><br><span class=\"line\">protected:</span><br><span class=\"line\">\tvoid timerEvent(QTimerEvent *e);</span><br><span class=\"line\">    </span><br><span class=\"line\">private:</span><br><span class=\"line\">\tint timerID;</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">.cpp 文件</span><br><span class=\"line\">//启动定时器,单位为ms</span><br><span class=\"line\">timerID = this-&gt;startTimer(1000);</span><br><span class=\"line\"></span><br><span class=\"line\">//定时器处理函数，所有定时器事件都通过些函数处理，不像OC的NSTimer单独指定</span><br><span class=\"line\">void MainWindow::timerEvent(QTimerEvent *e)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t//e-&gt;timerId()获取触发事件的定时器</span><br><span class=\"line\">    if (timerID == e-&gt;timerId()) &#123;  </span><br><span class=\"line\">        static int sec = 0;</span><br><span class=\"line\">        sec++;</span><br><span class=\"line\"></span><br><span class=\"line\">        ui-&gt;label-&gt;setText(QString(&quot;&lt;center&gt;&lt;h1&gt;timer out: %1&lt;/h1&gt;&lt;/center&gt;&quot;).arg(sec));</span><br><span class=\"line\"></span><br><span class=\"line\">        if (sec == 5) &#123;</span><br><span class=\"line\">        \t//关闭定时器</span><br><span class=\"line\">            killTimer(timerID);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"事件的接收和忽略\"><a href=\"#事件的接收和忽略\" class=\"headerlink\" title=\"事件的接收和忽略\"></a>事件的接收和忽略</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//e-&gt;accept() 接收事件，即处理事件</span><br><span class=\"line\">//e-&gt;ignore() 忽略事件，不处理</span><br><span class=\"line\">void MainWindow::closeEvent(QCloseEvent *e) &#123;</span><br><span class=\"line\">    int ret = QMessageBox::question(this, &quot;question&quot;, &quot;是否关闭窗口&quot;);</span><br><span class=\"line\">    if(ret == QMessageBox::Yes) &#123;</span><br><span class=\"line\">        //接收事件，执行事件， 事件不再传递，关闭事件-&gt;关闭窗口</span><br><span class=\"line\">        e-&gt;accept();</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        //忽略事件，事件传递给父组件直到找到事件接收者或者无父组件丢弃</span><br><span class=\"line\">        e-&gt;ignore();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"事件分发\"><a href=\"#事件分发\" class=\"headerlink\" title=\"事件分发\"></a>事件分发</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">class MyClass : public QWidget</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Q_OBJECT</span><br><span class=\"line\"></span><br><span class=\"line\">public:</span><br><span class=\"line\">    MyClass(QWidget *parent = 0);</span><br><span class=\"line\">    ~MyClass();</span><br><span class=\"line\"></span><br><span class=\"line\">//事件处理函数 返回true停止事件传递， false 继续事件传递</span><br><span class=\"line\">    bool event(QEvent* ev) override</span><br><span class=\"line\">    &#123;\t</span><br><span class=\"line\">    \t//判断事件类型，分发给相应的处理函数</span><br><span class=\"line\">        if (ev-&gt;type() == QEvent::PolishRequest) &#123;</span><br><span class=\"line\">            // overwrite handling of PolishRequest if any</span><br><span class=\"line\">            doThings();</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        &#125; else  if (ev-&gt;type() == QEvent::Show) &#123;</span><br><span class=\"line\">            // complement handling of Show if any</span><br><span class=\"line\">            doThings2();</span><br><span class=\"line\">            //调用父类处理函数，即进行默认处理</span><br><span class=\"line\">            QWidget::event(ev);</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        // Make sure the rest of events are handled</span><br><span class=\"line\">        //调用父类处理函数，即进行默认处理</span><br><span class=\"line\">        return QWidget::event(ev);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"事件过滤器\"><a href=\"#事件过滤器\" class=\"headerlink\" title=\"事件过滤器\"></a>事件过滤器</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  class MainWindow : public QMainWindow</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">  public:</span><br><span class=\"line\">      MainWindow();</span><br><span class=\"line\"></span><br><span class=\"line\">  protected:</span><br><span class=\"line\">  //1、重写事件过滤函数</span><br><span class=\"line\">      bool eventFilter(QObject *obj, QEvent *ev) override;</span><br><span class=\"line\"></span><br><span class=\"line\">  private:</span><br><span class=\"line\">      QTextEdit *textEdit;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  MainWindow::MainWindow()</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">      textEdit = new QTextEdit;</span><br><span class=\"line\">      setCentralWidget(textEdit);</span><br><span class=\"line\">      </span><br><span class=\"line\">\t//2、控件初始化过滤</span><br><span class=\"line\">      textEdit-&gt;installEventFilter(this);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//3、具体事件处理</span><br><span class=\"line\">  bool MainWindow::eventFilter(QObject *obj, QEvent *event)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">      if (obj == textEdit) &#123;</span><br><span class=\"line\">          if (event-&gt;type() == QEvent::KeyPress) &#123;</span><br><span class=\"line\">              QKeyEvent *keyEvent = static_cast&lt;QKeyEvent*&gt;(event);</span><br><span class=\"line\">              qDebug() &lt;&lt; &quot;Ate key press&quot; &lt;&lt; keyEvent-&gt;key();</span><br><span class=\"line\">              return true;</span><br><span class=\"line\">          &#125; else &#123;</span><br><span class=\"line\">              return false;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125; else &#123;</span><br><span class=\"line\">          // pass the event on to the parent class</span><br><span class=\"line\">          return QMainWindow::eventFilter(obj, event);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>QT的事件是由事件基类QEvent派生出来的，而控件的事件是从QObject和QWidget继续来的虚函数，可以重写实现。</p>\n<h3 id=\"控件事件\"><a href=\"#控件事件\" class=\"headerlink\" title=\"控件事件\"></a>控件事件</h3><p>示例代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//.h文件</span><br><span class=\"line\">#ifndef EVENTLABEL_H</span><br><span class=\"line\">#define EVENTLABEL_H</span><br><span class=\"line\"></span><br><span class=\"line\">#include &lt;QObject&gt;</span><br><span class=\"line\">#include &lt;QLabel&gt;</span><br><span class=\"line\">#include &lt;QWidget&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">class EventLabel : public QLabel</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Q_OBJECT</span><br><span class=\"line\">public:</span><br><span class=\"line\">    explicit EventLabel(QWidget *parent = nullptr);</span><br><span class=\"line\"></span><br><span class=\"line\">protected:</span><br><span class=\"line\">\t//鼠标按下事件</span><br><span class=\"line\">    void mousePressEvent(QMouseEvent *ev);</span><br><span class=\"line\">\t//鼠标移动事件</span><br><span class=\"line\">    void mouseMoveEvent(QMouseEvent *event);</span><br><span class=\"line\">\t//鼠标释放事件</span><br><span class=\"line\">    void mouseReleaseEvent(QMouseEvent *event);</span><br><span class=\"line\">\t//鼠标离开控件事件 virtual关键字可写可不写</span><br><span class=\"line\">    virtual void leaveEvent(QEvent *event);</span><br><span class=\"line\">\t//鼠标进入控件事件</span><br><span class=\"line\">    virtual void enterEvent(QEvent *event);</span><br><span class=\"line\"></span><br><span class=\"line\">signals:</span><br><span class=\"line\"></span><br><span class=\"line\">public slots:</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">#endif // EVENTLABEL_H</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">.cpp 文件</span><br><span class=\"line\">#include &quot;eventlabel.h&quot;</span><br><span class=\"line\">#include &lt;QMouseEvent&gt;</span><br><span class=\"line\">#include &lt;QDebug&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">EventLabel::EventLabel(QWidget *parent) : QLabel(parent)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void EventLabel::mousePressEvent(QMouseEvent *ev)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int i = ev-&gt;x();</span><br><span class=\"line\">    int j = ev-&gt;y();</span><br><span class=\"line\"></span><br><span class=\"line\">    if (ev-&gt;button() == Qt::LeftButton) &#123;</span><br><span class=\"line\">        qDebug() &lt;&lt; &quot;left&quot;;</span><br><span class=\"line\">    &#125; else if (ev-&gt;button() == Qt::RightButton) &#123;</span><br><span class=\"line\">        qDebug() &lt;&lt; &quot;Right&quot;;</span><br><span class=\"line\">    &#125; else if (ev-&gt;button() == Qt::MidButton) &#123;</span><br><span class=\"line\">        qDebug() &lt;&lt; &quot;Mid&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    QString text = QString(&quot;&lt;center&gt;&lt;h1&gt;Mouse Press: (%1, %2)&lt;/h1&gt;&lt;/center&gt;&quot;).arg(i).arg(j);</span><br><span class=\"line\">    this-&gt;setText(text);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void EventLabel::mouseReleaseEvent(QMouseEvent *ev) &#123;</span><br><span class=\"line\">    QString text = QString(&quot;&lt;center&gt;&lt;h1&gt;Mouse Release: (%1, %2)&lt;/h1&gt;&lt;/center&gt;&quot;).arg(ev-&gt;x()).arg(ev-&gt;y());</span><br><span class=\"line\">    this-&gt;setText(text);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void EventLabel::mouseMoveEvent(QMouseEvent *ev)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    QString text = QString(&quot;&lt;center&gt;&lt;h1&gt;Mouse Move: (%1, %2)&lt;/h1&gt;&lt;/center&gt;&quot;).arg(ev-&gt;x()).arg(ev-&gt;y());</span><br><span class=\"line\">    this-&gt;setText(text);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void EventLabel::leaveEvent(QEvent *event)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    QString text = QString(&quot;&lt;center&gt;&lt;h1&gt;leave&lt;/h1&gt;&lt;/center&gt;&quot;);</span><br><span class=\"line\">    this-&gt;setText(text);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void EventLabel::enterEvent(QEvent *event)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    QString text = QString(&quot;&lt;center&gt;&lt;h1&gt;enter&lt;/h1&gt;&lt;/center&gt;&quot;);</span><br><span class=\"line\">    this-&gt;setText(text);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"键盘事件\"><a href=\"#键盘事件\" class=\"headerlink\" title=\"键盘事件\"></a>键盘事件</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.h文件</span><br><span class=\"line\">protected:</span><br><span class=\"line\">    void keyPressEvent(QKeyEvent *);</span><br><span class=\"line\">    </span><br><span class=\"line\">.cpp 文件</span><br><span class=\"line\">void MainWindow::keyPressEvent(QKeyEvent *e)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t//QKeyEvent 键盘按键事件</span><br><span class=\"line\">    //e-&gt;key() 被下的按键</span><br><span class=\"line\">    //Qt::Key_x   键盘按键的枚举值</span><br><span class=\"line\">    qDebug() &lt;&lt; (char)e-&gt;key();</span><br><span class=\"line\">    if (e-&gt;key() == Qt::Key_A)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        qDebug() &lt;&lt; &quot;Qt::Key_A&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"定时器事件\"><a href=\"#定时器事件\" class=\"headerlink\" title=\"定时器事件\"></a>定时器事件</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.h 文件</span><br><span class=\"line\">protected:</span><br><span class=\"line\">\tvoid timerEvent(QTimerEvent *e);</span><br><span class=\"line\">    </span><br><span class=\"line\">private:</span><br><span class=\"line\">\tint timerID;</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">.cpp 文件</span><br><span class=\"line\">//启动定时器,单位为ms</span><br><span class=\"line\">timerID = this-&gt;startTimer(1000);</span><br><span class=\"line\"></span><br><span class=\"line\">//定时器处理函数，所有定时器事件都通过些函数处理，不像OC的NSTimer单独指定</span><br><span class=\"line\">void MainWindow::timerEvent(QTimerEvent *e)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t//e-&gt;timerId()获取触发事件的定时器</span><br><span class=\"line\">    if (timerID == e-&gt;timerId()) &#123;  </span><br><span class=\"line\">        static int sec = 0;</span><br><span class=\"line\">        sec++;</span><br><span class=\"line\"></span><br><span class=\"line\">        ui-&gt;label-&gt;setText(QString(&quot;&lt;center&gt;&lt;h1&gt;timer out: %1&lt;/h1&gt;&lt;/center&gt;&quot;).arg(sec));</span><br><span class=\"line\"></span><br><span class=\"line\">        if (sec == 5) &#123;</span><br><span class=\"line\">        \t//关闭定时器</span><br><span class=\"line\">            killTimer(timerID);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"事件的接收和忽略\"><a href=\"#事件的接收和忽略\" class=\"headerlink\" title=\"事件的接收和忽略\"></a>事件的接收和忽略</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//e-&gt;accept() 接收事件，即处理事件</span><br><span class=\"line\">//e-&gt;ignore() 忽略事件，不处理</span><br><span class=\"line\">void MainWindow::closeEvent(QCloseEvent *e) &#123;</span><br><span class=\"line\">    int ret = QMessageBox::question(this, &quot;question&quot;, &quot;是否关闭窗口&quot;);</span><br><span class=\"line\">    if(ret == QMessageBox::Yes) &#123;</span><br><span class=\"line\">        //接收事件，执行事件， 事件不再传递，关闭事件-&gt;关闭窗口</span><br><span class=\"line\">        e-&gt;accept();</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        //忽略事件，事件传递给父组件直到找到事件接收者或者无父组件丢弃</span><br><span class=\"line\">        e-&gt;ignore();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"事件分发\"><a href=\"#事件分发\" class=\"headerlink\" title=\"事件分发\"></a>事件分发</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">class MyClass : public QWidget</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Q_OBJECT</span><br><span class=\"line\"></span><br><span class=\"line\">public:</span><br><span class=\"line\">    MyClass(QWidget *parent = 0);</span><br><span class=\"line\">    ~MyClass();</span><br><span class=\"line\"></span><br><span class=\"line\">//事件处理函数 返回true停止事件传递， false 继续事件传递</span><br><span class=\"line\">    bool event(QEvent* ev) override</span><br><span class=\"line\">    &#123;\t</span><br><span class=\"line\">    \t//判断事件类型，分发给相应的处理函数</span><br><span class=\"line\">        if (ev-&gt;type() == QEvent::PolishRequest) &#123;</span><br><span class=\"line\">            // overwrite handling of PolishRequest if any</span><br><span class=\"line\">            doThings();</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        &#125; else  if (ev-&gt;type() == QEvent::Show) &#123;</span><br><span class=\"line\">            // complement handling of Show if any</span><br><span class=\"line\">            doThings2();</span><br><span class=\"line\">            //调用父类处理函数，即进行默认处理</span><br><span class=\"line\">            QWidget::event(ev);</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        // Make sure the rest of events are handled</span><br><span class=\"line\">        //调用父类处理函数，即进行默认处理</span><br><span class=\"line\">        return QWidget::event(ev);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"事件过滤器\"><a href=\"#事件过滤器\" class=\"headerlink\" title=\"事件过滤器\"></a>事件过滤器</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  class MainWindow : public QMainWindow</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">  public:</span><br><span class=\"line\">      MainWindow();</span><br><span class=\"line\"></span><br><span class=\"line\">  protected:</span><br><span class=\"line\">  //1、重写事件过滤函数</span><br><span class=\"line\">      bool eventFilter(QObject *obj, QEvent *ev) override;</span><br><span class=\"line\"></span><br><span class=\"line\">  private:</span><br><span class=\"line\">      QTextEdit *textEdit;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  MainWindow::MainWindow()</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">      textEdit = new QTextEdit;</span><br><span class=\"line\">      setCentralWidget(textEdit);</span><br><span class=\"line\">      </span><br><span class=\"line\">\t//2、控件初始化过滤</span><br><span class=\"line\">      textEdit-&gt;installEventFilter(this);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//3、具体事件处理</span><br><span class=\"line\">  bool MainWindow::eventFilter(QObject *obj, QEvent *event)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">      if (obj == textEdit) &#123;</span><br><span class=\"line\">          if (event-&gt;type() == QEvent::KeyPress) &#123;</span><br><span class=\"line\">              QKeyEvent *keyEvent = static_cast&lt;QKeyEvent*&gt;(event);</span><br><span class=\"line\">              qDebug() &lt;&lt; &quot;Ate key press&quot; &lt;&lt; keyEvent-&gt;key();</span><br><span class=\"line\">              return true;</span><br><span class=\"line\">          &#125; else &#123;</span><br><span class=\"line\">              return false;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125; else &#123;</span><br><span class=\"line\">          // pass the event on to the parent class</span><br><span class=\"line\">          return QMainWindow::eventFilter(obj, event);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>"},{"title":"QT基础6——基础绘图","author":"Cyrus","date":"2018-12-29T07:40:00.000Z","_content":"#### 1、重写绘图事件\n```\n.h文件\nprotected:\n    //1、重写绘图事件，虚函数\n    //2、如果在窗口绘图，必须放在绘图事件里实现\n    //3、绘图事件内部自动调用，窗口需要重绘的时候（状态改变，如缩放、鼠标点击之类）\n    void paintEvent(QPaintEvent *);\n```\n\n#### 2、绘图事件中调用相关函数\n绘图功能需要用到QPainter对象，QPainter有两种创建方式\n* QPainter(QPaintDevice *device)，QWidget继承于QObject和QPaintDevice 所以所有视图均为QPaintDevice子类，可以写为QPainter p(this);\n\n* QPainter p1;绘图代码写于p1.begin(this);和p1.end();之间\n\n```\nvoid Widget::paintEvent(QPaintEvent *)\n{\n    //QPaintDevice,widget多继承于QObject和QPaintDevice\n    QPainter p(this);\n\n    //创建画图对象\n    //指定绘图对象的绘图设备\n//    QPainter p1;\n//    p1.begin(this);\n\n\t//画图片\n//    p.drawPixmap(0, 0, width(), height(), QPixmap(\"../Image/bg.png\"));\n\n    //绘笔\n    QPen pen;\n    //设置常用颜色\n//    pen.setColor(Qt::red);\n\t//\t设置线宽\n    pen.setWidth(5);\n    //以rgba设置颜色\n    pen.setColor(QColor(12, 34, 255, 255));\n    //设置绘笔风格\n    pen.setStyle(Qt::DashDotLine);\n\t\n    //将绘笔赋予painter\n    p.setPen(pen);\n    //画线\n    p.drawLine(50, 50, 50, 150);\n    //画矩形\n    p.drawRect(20, 30, 110, 200);\n    //画椭圆\n\tp.drawEllipse(QPoint(150, 150), 60, 100);\n    \n    //笔刷\n    QBrush  brush;\n    //设置常用颜色\n    brush.setColor(Qt::red);\n    //设置笔刷风格\n    brush.setStyle(Qt::Dense4Pattern);\n    //将笔刷赋予painter\n    p.setBrush(brush);\n    p.drawEllipse(QPoint(150, 150), 60, 100);\n\n//    p1.end();\n}\n```","source":"_posts/QT基础6——基础绘图.md","raw":"title: QT基础6——基础绘图\nauthor: Cyrus\ntags: []\ncategories:\n  - QT\ndate: 2018-12-29 15:40:00\n---\n#### 1、重写绘图事件\n```\n.h文件\nprotected:\n    //1、重写绘图事件，虚函数\n    //2、如果在窗口绘图，必须放在绘图事件里实现\n    //3、绘图事件内部自动调用，窗口需要重绘的时候（状态改变，如缩放、鼠标点击之类）\n    void paintEvent(QPaintEvent *);\n```\n\n#### 2、绘图事件中调用相关函数\n绘图功能需要用到QPainter对象，QPainter有两种创建方式\n* QPainter(QPaintDevice *device)，QWidget继承于QObject和QPaintDevice 所以所有视图均为QPaintDevice子类，可以写为QPainter p(this);\n\n* QPainter p1;绘图代码写于p1.begin(this);和p1.end();之间\n\n```\nvoid Widget::paintEvent(QPaintEvent *)\n{\n    //QPaintDevice,widget多继承于QObject和QPaintDevice\n    QPainter p(this);\n\n    //创建画图对象\n    //指定绘图对象的绘图设备\n//    QPainter p1;\n//    p1.begin(this);\n\n\t//画图片\n//    p.drawPixmap(0, 0, width(), height(), QPixmap(\"../Image/bg.png\"));\n\n    //绘笔\n    QPen pen;\n    //设置常用颜色\n//    pen.setColor(Qt::red);\n\t//\t设置线宽\n    pen.setWidth(5);\n    //以rgba设置颜色\n    pen.setColor(QColor(12, 34, 255, 255));\n    //设置绘笔风格\n    pen.setStyle(Qt::DashDotLine);\n\t\n    //将绘笔赋予painter\n    p.setPen(pen);\n    //画线\n    p.drawLine(50, 50, 50, 150);\n    //画矩形\n    p.drawRect(20, 30, 110, 200);\n    //画椭圆\n\tp.drawEllipse(QPoint(150, 150), 60, 100);\n    \n    //笔刷\n    QBrush  brush;\n    //设置常用颜色\n    brush.setColor(Qt::red);\n    //设置笔刷风格\n    brush.setStyle(Qt::Dense4Pattern);\n    //将笔刷赋予painter\n    p.setBrush(brush);\n    p.drawEllipse(QPoint(150, 150), 60, 100);\n\n//    p1.end();\n}\n```","slug":"QT基础6——基础绘图","published":1,"updated":"2019-07-09T08:13:34.942Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyzlbt8k00110j666pwr5l9a","content":"<h4 id=\"1、重写绘图事件\"><a href=\"#1、重写绘图事件\" class=\"headerlink\" title=\"1、重写绘图事件\"></a>1、重写绘图事件</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.h文件</span><br><span class=\"line\">protected:</span><br><span class=\"line\">    //1、重写绘图事件，虚函数</span><br><span class=\"line\">    //2、如果在窗口绘图，必须放在绘图事件里实现</span><br><span class=\"line\">    //3、绘图事件内部自动调用，窗口需要重绘的时候（状态改变，如缩放、鼠标点击之类）</span><br><span class=\"line\">    void paintEvent(QPaintEvent *);</span><br></pre></td></tr></table></figure>\n<h4 id=\"2、绘图事件中调用相关函数\"><a href=\"#2、绘图事件中调用相关函数\" class=\"headerlink\" title=\"2、绘图事件中调用相关函数\"></a>2、绘图事件中调用相关函数</h4><p>绘图功能需要用到QPainter对象，QPainter有两种创建方式</p>\n<ul>\n<li><p>QPainter(QPaintDevice *device)，QWidget继承于QObject和QPaintDevice 所以所有视图均为QPaintDevice子类，可以写为QPainter p(this);</p>\n</li>\n<li><p>QPainter p1;绘图代码写于p1.begin(this);和p1.end();之间</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void Widget::paintEvent(QPaintEvent *)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //QPaintDevice,widget多继承于QObject和QPaintDevice</span><br><span class=\"line\">    QPainter p(this);</span><br><span class=\"line\"></span><br><span class=\"line\">    //创建画图对象</span><br><span class=\"line\">    //指定绘图对象的绘图设备</span><br><span class=\"line\">//    QPainter p1;</span><br><span class=\"line\">//    p1.begin(this);</span><br><span class=\"line\"></span><br><span class=\"line\">\t//画图片</span><br><span class=\"line\">//    p.drawPixmap(0, 0, width(), height(), QPixmap(&quot;../Image/bg.png&quot;));</span><br><span class=\"line\"></span><br><span class=\"line\">    //绘笔</span><br><span class=\"line\">    QPen pen;</span><br><span class=\"line\">    //设置常用颜色</span><br><span class=\"line\">//    pen.setColor(Qt::red);</span><br><span class=\"line\">\t//\t设置线宽</span><br><span class=\"line\">    pen.setWidth(5);</span><br><span class=\"line\">    //以rgba设置颜色</span><br><span class=\"line\">    pen.setColor(QColor(12, 34, 255, 255));</span><br><span class=\"line\">    //设置绘笔风格</span><br><span class=\"line\">    pen.setStyle(Qt::DashDotLine);</span><br><span class=\"line\">\t</span><br><span class=\"line\">    //将绘笔赋予painter</span><br><span class=\"line\">    p.setPen(pen);</span><br><span class=\"line\">    //画线</span><br><span class=\"line\">    p.drawLine(50, 50, 50, 150);</span><br><span class=\"line\">    //画矩形</span><br><span class=\"line\">    p.drawRect(20, 30, 110, 200);</span><br><span class=\"line\">    //画椭圆</span><br><span class=\"line\">\tp.drawEllipse(QPoint(150, 150), 60, 100);</span><br><span class=\"line\">    </span><br><span class=\"line\">    //笔刷</span><br><span class=\"line\">    QBrush  brush;</span><br><span class=\"line\">    //设置常用颜色</span><br><span class=\"line\">    brush.setColor(Qt::red);</span><br><span class=\"line\">    //设置笔刷风格</span><br><span class=\"line\">    brush.setStyle(Qt::Dense4Pattern);</span><br><span class=\"line\">    //将笔刷赋予painter</span><br><span class=\"line\">    p.setBrush(brush);</span><br><span class=\"line\">    p.drawEllipse(QPoint(150, 150), 60, 100);</span><br><span class=\"line\"></span><br><span class=\"line\">//    p1.end();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"1、重写绘图事件\"><a href=\"#1、重写绘图事件\" class=\"headerlink\" title=\"1、重写绘图事件\"></a>1、重写绘图事件</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.h文件</span><br><span class=\"line\">protected:</span><br><span class=\"line\">    //1、重写绘图事件，虚函数</span><br><span class=\"line\">    //2、如果在窗口绘图，必须放在绘图事件里实现</span><br><span class=\"line\">    //3、绘图事件内部自动调用，窗口需要重绘的时候（状态改变，如缩放、鼠标点击之类）</span><br><span class=\"line\">    void paintEvent(QPaintEvent *);</span><br></pre></td></tr></table></figure>\n<h4 id=\"2、绘图事件中调用相关函数\"><a href=\"#2、绘图事件中调用相关函数\" class=\"headerlink\" title=\"2、绘图事件中调用相关函数\"></a>2、绘图事件中调用相关函数</h4><p>绘图功能需要用到QPainter对象，QPainter有两种创建方式</p>\n<ul>\n<li><p>QPainter(QPaintDevice *device)，QWidget继承于QObject和QPaintDevice 所以所有视图均为QPaintDevice子类，可以写为QPainter p(this);</p>\n</li>\n<li><p>QPainter p1;绘图代码写于p1.begin(this);和p1.end();之间</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void Widget::paintEvent(QPaintEvent *)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //QPaintDevice,widget多继承于QObject和QPaintDevice</span><br><span class=\"line\">    QPainter p(this);</span><br><span class=\"line\"></span><br><span class=\"line\">    //创建画图对象</span><br><span class=\"line\">    //指定绘图对象的绘图设备</span><br><span class=\"line\">//    QPainter p1;</span><br><span class=\"line\">//    p1.begin(this);</span><br><span class=\"line\"></span><br><span class=\"line\">\t//画图片</span><br><span class=\"line\">//    p.drawPixmap(0, 0, width(), height(), QPixmap(&quot;../Image/bg.png&quot;));</span><br><span class=\"line\"></span><br><span class=\"line\">    //绘笔</span><br><span class=\"line\">    QPen pen;</span><br><span class=\"line\">    //设置常用颜色</span><br><span class=\"line\">//    pen.setColor(Qt::red);</span><br><span class=\"line\">\t//\t设置线宽</span><br><span class=\"line\">    pen.setWidth(5);</span><br><span class=\"line\">    //以rgba设置颜色</span><br><span class=\"line\">    pen.setColor(QColor(12, 34, 255, 255));</span><br><span class=\"line\">    //设置绘笔风格</span><br><span class=\"line\">    pen.setStyle(Qt::DashDotLine);</span><br><span class=\"line\">\t</span><br><span class=\"line\">    //将绘笔赋予painter</span><br><span class=\"line\">    p.setPen(pen);</span><br><span class=\"line\">    //画线</span><br><span class=\"line\">    p.drawLine(50, 50, 50, 150);</span><br><span class=\"line\">    //画矩形</span><br><span class=\"line\">    p.drawRect(20, 30, 110, 200);</span><br><span class=\"line\">    //画椭圆</span><br><span class=\"line\">\tp.drawEllipse(QPoint(150, 150), 60, 100);</span><br><span class=\"line\">    </span><br><span class=\"line\">    //笔刷</span><br><span class=\"line\">    QBrush  brush;</span><br><span class=\"line\">    //设置常用颜色</span><br><span class=\"line\">    brush.setColor(Qt::red);</span><br><span class=\"line\">    //设置笔刷风格</span><br><span class=\"line\">    brush.setStyle(Qt::Dense4Pattern);</span><br><span class=\"line\">    //将笔刷赋予painter</span><br><span class=\"line\">    p.setBrush(brush);</span><br><span class=\"line\">    p.drawEllipse(QPoint(150, 150), 60, 100);</span><br><span class=\"line\"></span><br><span class=\"line\">//    p1.end();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"QT基础7——图片加载及保存","author":"Cyrus","date":"2018-12-31T06:03:00.000Z","_content":"QT图片主要有QPixmap、QImage和QPicture三个类，他们的父类均为QPaintDevice。\n* QPixmap/QBitmap: 针对屏幕进行了优化， 和平台相关, 不能对图片进行修改\n* QImage: 和平台无关，可以对图片进行修改，可以在线程中绘图\n* QPicture: 保存绘图的状态（二进制文件)\n\n#### QPixmap/QBitmap\nQBitmap 是QPixmap的子类，图片类型是黑白图片，可以减少图片的大小。\n\n```\n \tQPainter p(this);\n\t\n    //把图片画到当前窗口上\n    //方法一\n    p.drawPixmap(0, 0, QPixmap(\"../Image/bg.png\"));\n    p.drawPixmap(300, 0, QBitmap(\"../Image/bg.png\"));\n\t\n    //方法二，先load加载，再drawPixmap\n    QPixmap pixmap;\n    pixmap.load(\"../Image/bg.png\");\n    p.drawPixmap(0, 200, pixmap);\n\n    QBitmap bitmap;\n    bitmap.load(\"../Image/bg.png\");\n    p.drawPixmap(300, 200, bitmap);\n    \n    \n    //内存加载图片并保存（不显示到窗口上）\n        QPixmap pixmap(400, 300);\n    QPainter p(&pixmap);\n    //通过画刷填充颜色\n    p.fillRect(0, 0, 400, 300, QBrush(Qt::white));\n    //直接用绘图设置填充颜色\n    pixmap.fill(Qt::white);\n    p.drawPixmap(0, 0, 80, 80, QPixmap(\"../Image/bg.png\"));\n    pixmap.save(\"../pixmap.jpg\");\n```\n\n\n#### QImage\nQImage与QPixmap使用方法基本相同，不同的地方在于可以获取和修改指定位置相素点的值\n```\n\t//指定图片大小和像素格式\n\tQImage image(400, 300, QImage::Format_ARGB32);\n    //加载图片\n    image.load(\"../Image/bg.png\");\n    QPainter p;\n    p.begin(&image);\n    p.drawImage(0, 0, image);\n\n    for(int i = 0; i <  50; i++)\n    {\n        for(int j = 0; j < 50; j++) {\n        //将前50*50的像素点改为绿色\n            image.setPixel(QPoint(i, j), qRgb(0, 255, 0));\n        }\n    }\n\t//保存图片\n    image.save(\"../image.jpg\");\n    p.end();\n```\n\n#### QPicture\nQPicture可以将图片保存为二进制文件（系统无法识别），可以通过QT加载打开。\n```\n  QPicture picture;\n    QPainter p;\n    p.begin(&picture);\n\n    p.drawPixmap(0, 0, QPixmap(\"../Image/bg.png\"));\n    p.drawLine(50, 50, 150, 50);\n    p.end();\n    \n    //必须p.end()之后才能调用save()函数\n    picture.save(\"../pictuer.png\");\n    \n    \n    //加载保存在本地的picture文件\n    QPicture pic;\n    pic.load(\"../pictuer.png\");\n    QPainter p(this);\n    p.drawPicture(0, 0, pic);\n```\n\n\n#### QImage 与 QPixmap相互转换\n```\nQPainter p(this);\n    QPixmap pixmap;\n    pixmap.load(\"../Image/bg.png\");\n\t\n    //pixmap转image\n    QImage tempImage = pixmap.toImage();\n\t//image 转 pixmap\n    QPixmap tempPixmap = QPixmap::fromImage(tempImage);\n\n    p.drawPixmap(0, 0, tempPixmap);\n    p.drawImage(300, 0, tempImage);\n```","source":"_posts/QT基础7——图片加载及保存.md","raw":"title: QT基础7——图片加载及保存\nauthor: Cyrus\ntags: []\ncategories:\n  - QT\ndate: 2018-12-31 14:03:00\n---\nQT图片主要有QPixmap、QImage和QPicture三个类，他们的父类均为QPaintDevice。\n* QPixmap/QBitmap: 针对屏幕进行了优化， 和平台相关, 不能对图片进行修改\n* QImage: 和平台无关，可以对图片进行修改，可以在线程中绘图\n* QPicture: 保存绘图的状态（二进制文件)\n\n#### QPixmap/QBitmap\nQBitmap 是QPixmap的子类，图片类型是黑白图片，可以减少图片的大小。\n\n```\n \tQPainter p(this);\n\t\n    //把图片画到当前窗口上\n    //方法一\n    p.drawPixmap(0, 0, QPixmap(\"../Image/bg.png\"));\n    p.drawPixmap(300, 0, QBitmap(\"../Image/bg.png\"));\n\t\n    //方法二，先load加载，再drawPixmap\n    QPixmap pixmap;\n    pixmap.load(\"../Image/bg.png\");\n    p.drawPixmap(0, 200, pixmap);\n\n    QBitmap bitmap;\n    bitmap.load(\"../Image/bg.png\");\n    p.drawPixmap(300, 200, bitmap);\n    \n    \n    //内存加载图片并保存（不显示到窗口上）\n        QPixmap pixmap(400, 300);\n    QPainter p(&pixmap);\n    //通过画刷填充颜色\n    p.fillRect(0, 0, 400, 300, QBrush(Qt::white));\n    //直接用绘图设置填充颜色\n    pixmap.fill(Qt::white);\n    p.drawPixmap(0, 0, 80, 80, QPixmap(\"../Image/bg.png\"));\n    pixmap.save(\"../pixmap.jpg\");\n```\n\n\n#### QImage\nQImage与QPixmap使用方法基本相同，不同的地方在于可以获取和修改指定位置相素点的值\n```\n\t//指定图片大小和像素格式\n\tQImage image(400, 300, QImage::Format_ARGB32);\n    //加载图片\n    image.load(\"../Image/bg.png\");\n    QPainter p;\n    p.begin(&image);\n    p.drawImage(0, 0, image);\n\n    for(int i = 0; i <  50; i++)\n    {\n        for(int j = 0; j < 50; j++) {\n        //将前50*50的像素点改为绿色\n            image.setPixel(QPoint(i, j), qRgb(0, 255, 0));\n        }\n    }\n\t//保存图片\n    image.save(\"../image.jpg\");\n    p.end();\n```\n\n#### QPicture\nQPicture可以将图片保存为二进制文件（系统无法识别），可以通过QT加载打开。\n```\n  QPicture picture;\n    QPainter p;\n    p.begin(&picture);\n\n    p.drawPixmap(0, 0, QPixmap(\"../Image/bg.png\"));\n    p.drawLine(50, 50, 150, 50);\n    p.end();\n    \n    //必须p.end()之后才能调用save()函数\n    picture.save(\"../pictuer.png\");\n    \n    \n    //加载保存在本地的picture文件\n    QPicture pic;\n    pic.load(\"../pictuer.png\");\n    QPainter p(this);\n    p.drawPicture(0, 0, pic);\n```\n\n\n#### QImage 与 QPixmap相互转换\n```\nQPainter p(this);\n    QPixmap pixmap;\n    pixmap.load(\"../Image/bg.png\");\n\t\n    //pixmap转image\n    QImage tempImage = pixmap.toImage();\n\t//image 转 pixmap\n    QPixmap tempPixmap = QPixmap::fromImage(tempImage);\n\n    p.drawPixmap(0, 0, tempPixmap);\n    p.drawImage(300, 0, tempImage);\n```","slug":"QT基础7——图片加载及保存","published":1,"updated":"2019-07-09T08:13:34.943Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyzlbt8n00140j66pgr6guiu","content":"<p>QT图片主要有QPixmap、QImage和QPicture三个类，他们的父类均为QPaintDevice。</p>\n<ul>\n<li>QPixmap/QBitmap: 针对屏幕进行了优化， 和平台相关, 不能对图片进行修改</li>\n<li>QImage: 和平台无关，可以对图片进行修改，可以在线程中绘图</li>\n<li>QPicture: 保存绘图的状态（二进制文件)</li>\n</ul>\n<h4 id=\"QPixmap-QBitmap\"><a href=\"#QPixmap-QBitmap\" class=\"headerlink\" title=\"QPixmap/QBitmap\"></a>QPixmap/QBitmap</h4><p>QBitmap 是QPixmap的子类，图片类型是黑白图片，可以减少图片的大小。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">QPainter p(this);</span><br><span class=\"line\">\t</span><br><span class=\"line\">  //把图片画到当前窗口上</span><br><span class=\"line\">  //方法一</span><br><span class=\"line\">  p.drawPixmap(0, 0, QPixmap(&quot;../Image/bg.png&quot;));</span><br><span class=\"line\">  p.drawPixmap(300, 0, QBitmap(&quot;../Image/bg.png&quot;));</span><br><span class=\"line\">\t</span><br><span class=\"line\">  //方法二，先load加载，再drawPixmap</span><br><span class=\"line\">  QPixmap pixmap;</span><br><span class=\"line\">  pixmap.load(&quot;../Image/bg.png&quot;);</span><br><span class=\"line\">  p.drawPixmap(0, 200, pixmap);</span><br><span class=\"line\"></span><br><span class=\"line\">  QBitmap bitmap;</span><br><span class=\"line\">  bitmap.load(&quot;../Image/bg.png&quot;);</span><br><span class=\"line\">  p.drawPixmap(300, 200, bitmap);</span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">  //内存加载图片并保存（不显示到窗口上）</span><br><span class=\"line\">      QPixmap pixmap(400, 300);</span><br><span class=\"line\">  QPainter p(&amp;pixmap);</span><br><span class=\"line\">  //通过画刷填充颜色</span><br><span class=\"line\">  p.fillRect(0, 0, 400, 300, QBrush(Qt::white));</span><br><span class=\"line\">  //直接用绘图设置填充颜色</span><br><span class=\"line\">  pixmap.fill(Qt::white);</span><br><span class=\"line\">  p.drawPixmap(0, 0, 80, 80, QPixmap(&quot;../Image/bg.png&quot;));</span><br><span class=\"line\">  pixmap.save(&quot;../pixmap.jpg&quot;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"QImage\"><a href=\"#QImage\" class=\"headerlink\" title=\"QImage\"></a>QImage</h4><p>QImage与QPixmap使用方法基本相同，不同的地方在于可以获取和修改指定位置相素点的值<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//指定图片大小和像素格式</span><br><span class=\"line\">QImage image(400, 300, QImage::Format_ARGB32);</span><br><span class=\"line\">   //加载图片</span><br><span class=\"line\">   image.load(&quot;../Image/bg.png&quot;);</span><br><span class=\"line\">   QPainter p;</span><br><span class=\"line\">   p.begin(&amp;image);</span><br><span class=\"line\">   p.drawImage(0, 0, image);</span><br><span class=\"line\"></span><br><span class=\"line\">   for(int i = 0; i &lt;  50; i++)</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">       for(int j = 0; j &lt; 50; j++) &#123;</span><br><span class=\"line\">       //将前50*50的像素点改为绿色</span><br><span class=\"line\">           image.setPixel(QPoint(i, j), qRgb(0, 255, 0));</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">//保存图片</span><br><span class=\"line\">   image.save(&quot;../image.jpg&quot;);</span><br><span class=\"line\">   p.end();</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"QPicture\"><a href=\"#QPicture\" class=\"headerlink\" title=\"QPicture\"></a>QPicture</h4><p>QPicture可以将图片保存为二进制文件（系统无法识别），可以通过QT加载打开。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">QPicture picture;</span><br><span class=\"line\">  QPainter p;</span><br><span class=\"line\">  p.begin(&amp;picture);</span><br><span class=\"line\"></span><br><span class=\"line\">  p.drawPixmap(0, 0, QPixmap(&quot;../Image/bg.png&quot;));</span><br><span class=\"line\">  p.drawLine(50, 50, 150, 50);</span><br><span class=\"line\">  p.end();</span><br><span class=\"line\">  </span><br><span class=\"line\">  //必须p.end()之后才能调用save()函数</span><br><span class=\"line\">  picture.save(&quot;../pictuer.png&quot;);</span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">  //加载保存在本地的picture文件</span><br><span class=\"line\">  QPicture pic;</span><br><span class=\"line\">  pic.load(&quot;../pictuer.png&quot;);</span><br><span class=\"line\">  QPainter p(this);</span><br><span class=\"line\">  p.drawPicture(0, 0, pic);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"QImage-与-QPixmap相互转换\"><a href=\"#QImage-与-QPixmap相互转换\" class=\"headerlink\" title=\"QImage 与 QPixmap相互转换\"></a>QImage 与 QPixmap相互转换</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">QPainter p(this);</span><br><span class=\"line\">    QPixmap pixmap;</span><br><span class=\"line\">    pixmap.load(&quot;../Image/bg.png&quot;);</span><br><span class=\"line\">\t</span><br><span class=\"line\">    //pixmap转image</span><br><span class=\"line\">    QImage tempImage = pixmap.toImage();</span><br><span class=\"line\">\t//image 转 pixmap</span><br><span class=\"line\">    QPixmap tempPixmap = QPixmap::fromImage(tempImage);</span><br><span class=\"line\"></span><br><span class=\"line\">    p.drawPixmap(0, 0, tempPixmap);</span><br><span class=\"line\">    p.drawImage(300, 0, tempImage);</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>QT图片主要有QPixmap、QImage和QPicture三个类，他们的父类均为QPaintDevice。</p>\n<ul>\n<li>QPixmap/QBitmap: 针对屏幕进行了优化， 和平台相关, 不能对图片进行修改</li>\n<li>QImage: 和平台无关，可以对图片进行修改，可以在线程中绘图</li>\n<li>QPicture: 保存绘图的状态（二进制文件)</li>\n</ul>\n<h4 id=\"QPixmap-QBitmap\"><a href=\"#QPixmap-QBitmap\" class=\"headerlink\" title=\"QPixmap/QBitmap\"></a>QPixmap/QBitmap</h4><p>QBitmap 是QPixmap的子类，图片类型是黑白图片，可以减少图片的大小。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">QPainter p(this);</span><br><span class=\"line\">\t</span><br><span class=\"line\">  //把图片画到当前窗口上</span><br><span class=\"line\">  //方法一</span><br><span class=\"line\">  p.drawPixmap(0, 0, QPixmap(&quot;../Image/bg.png&quot;));</span><br><span class=\"line\">  p.drawPixmap(300, 0, QBitmap(&quot;../Image/bg.png&quot;));</span><br><span class=\"line\">\t</span><br><span class=\"line\">  //方法二，先load加载，再drawPixmap</span><br><span class=\"line\">  QPixmap pixmap;</span><br><span class=\"line\">  pixmap.load(&quot;../Image/bg.png&quot;);</span><br><span class=\"line\">  p.drawPixmap(0, 200, pixmap);</span><br><span class=\"line\"></span><br><span class=\"line\">  QBitmap bitmap;</span><br><span class=\"line\">  bitmap.load(&quot;../Image/bg.png&quot;);</span><br><span class=\"line\">  p.drawPixmap(300, 200, bitmap);</span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">  //内存加载图片并保存（不显示到窗口上）</span><br><span class=\"line\">      QPixmap pixmap(400, 300);</span><br><span class=\"line\">  QPainter p(&amp;pixmap);</span><br><span class=\"line\">  //通过画刷填充颜色</span><br><span class=\"line\">  p.fillRect(0, 0, 400, 300, QBrush(Qt::white));</span><br><span class=\"line\">  //直接用绘图设置填充颜色</span><br><span class=\"line\">  pixmap.fill(Qt::white);</span><br><span class=\"line\">  p.drawPixmap(0, 0, 80, 80, QPixmap(&quot;../Image/bg.png&quot;));</span><br><span class=\"line\">  pixmap.save(&quot;../pixmap.jpg&quot;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"QImage\"><a href=\"#QImage\" class=\"headerlink\" title=\"QImage\"></a>QImage</h4><p>QImage与QPixmap使用方法基本相同，不同的地方在于可以获取和修改指定位置相素点的值<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//指定图片大小和像素格式</span><br><span class=\"line\">QImage image(400, 300, QImage::Format_ARGB32);</span><br><span class=\"line\">   //加载图片</span><br><span class=\"line\">   image.load(&quot;../Image/bg.png&quot;);</span><br><span class=\"line\">   QPainter p;</span><br><span class=\"line\">   p.begin(&amp;image);</span><br><span class=\"line\">   p.drawImage(0, 0, image);</span><br><span class=\"line\"></span><br><span class=\"line\">   for(int i = 0; i &lt;  50; i++)</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">       for(int j = 0; j &lt; 50; j++) &#123;</span><br><span class=\"line\">       //将前50*50的像素点改为绿色</span><br><span class=\"line\">           image.setPixel(QPoint(i, j), qRgb(0, 255, 0));</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">//保存图片</span><br><span class=\"line\">   image.save(&quot;../image.jpg&quot;);</span><br><span class=\"line\">   p.end();</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"QPicture\"><a href=\"#QPicture\" class=\"headerlink\" title=\"QPicture\"></a>QPicture</h4><p>QPicture可以将图片保存为二进制文件（系统无法识别），可以通过QT加载打开。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">QPicture picture;</span><br><span class=\"line\">  QPainter p;</span><br><span class=\"line\">  p.begin(&amp;picture);</span><br><span class=\"line\"></span><br><span class=\"line\">  p.drawPixmap(0, 0, QPixmap(&quot;../Image/bg.png&quot;));</span><br><span class=\"line\">  p.drawLine(50, 50, 150, 50);</span><br><span class=\"line\">  p.end();</span><br><span class=\"line\">  </span><br><span class=\"line\">  //必须p.end()之后才能调用save()函数</span><br><span class=\"line\">  picture.save(&quot;../pictuer.png&quot;);</span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">  //加载保存在本地的picture文件</span><br><span class=\"line\">  QPicture pic;</span><br><span class=\"line\">  pic.load(&quot;../pictuer.png&quot;);</span><br><span class=\"line\">  QPainter p(this);</span><br><span class=\"line\">  p.drawPicture(0, 0, pic);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"QImage-与-QPixmap相互转换\"><a href=\"#QImage-与-QPixmap相互转换\" class=\"headerlink\" title=\"QImage 与 QPixmap相互转换\"></a>QImage 与 QPixmap相互转换</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">QPainter p(this);</span><br><span class=\"line\">    QPixmap pixmap;</span><br><span class=\"line\">    pixmap.load(&quot;../Image/bg.png&quot;);</span><br><span class=\"line\">\t</span><br><span class=\"line\">    //pixmap转image</span><br><span class=\"line\">    QImage tempImage = pixmap.toImage();</span><br><span class=\"line\">\t//image 转 pixmap</span><br><span class=\"line\">    QPixmap tempPixmap = QPixmap::fromImage(tempImage);</span><br><span class=\"line\"></span><br><span class=\"line\">    p.drawPixmap(0, 0, tempPixmap);</span><br><span class=\"line\">    p.drawImage(300, 0, tempImage);</span><br></pre></td></tr></table></figure>"},{"title":"QT基础8——文件读写","author":"Cyrus","date":"2019-01-01T12:42:00.000Z","_content":"#### 读文件\n```\n//弹窗选择文件\n\tQString path = QFileDialog::getOpenFileName(this, \"open\", \"../\", \"TXT(*.txt)\");\n\n    if(path.isEmpty() == true) {\n        return;\n    }\n    //打开文件\n    bool success = file.open(QIODevice::ReadOnly);\n        if(success == true) {\n//        //读文件,默认只识别utf-8编码\n\t      //小文件的话可以一次读完\t\t\n//        QByteArray array =  file.readAll();\n//        ui->textEdit->setText(array);\n\t\t\n        //大文件的话一次读一行\n        QByteArray array;\n        while (file.atEnd() == false) {\n            array += file.readLine();\n        }\n        ui->textEdit->setText(array);\n    }\n    file.close();\n```\n\n#### 写文件\n```\n//弹框选择保存文件的路径\n\t\tQString path = QFileDialog::getSaveFileName(this, \"save\", \"../\", \"TXT(*.txt)\");\n    if (path.isEmpty() == true) {\n        return;\n    }\n\n    QFile file;\n    file.setFileName(path);\n    bool success = file.open(QIODevice::WriteOnly);\n\n    if (success) {\n        QString str = ui->textEdit->toPlainText();\n\n        // str.toUtf8() -->QString->QByteArray\n//        file.write(str.toUtf8());\n\n        //QString->C++ String -> char *\n        file.write(str.toStdString().data());\n    }\n    file.close();\n```\n\n#### 文件信息\n```\n\tQFileInfo info(path);\n     qDebug() << \"文件名字：\" << info.fileName();\n     qDebug() << \"文件后缀\" << info.suffix();\n     qDebug() << \"文件大小\" << info.size();\n     qDebug() << \"创建时间\" << info.birthTime().toString(\"yyyy-MM-dd hh:mm:ss\");\n```\n\n#### 二进制读写文件\n```\n  \t//写文件\n\tQFile file(\"../123.txt\");\n    if (file.open(QIODevice::WriteOnly) == false) {\n        qDebug() << \"Open failure\";\n        return;\n    }\n\n    QDataStream stream(&file);\n    stream << QString(\"试一试\") << 123;\n    file.close();\n    \n    \n    //读文件\n    QFile file(\"../123.txt\");\n    if (file.open(QIODevice::ReadOnly) == false) {\n        qDebug() << \"Open failure\";\n        return;\n    }\n\n    QDataStream stream(&file);\n    QString str;\n    int a;\n    stream >> str >> a;\n    qDebug() << str.toUtf8().data() << a;\n    file.close();\n    \n    //文本格式读写文件,用法与QDataStream类似，区别是可以设置编码类型\n     QTextStream textStream;\n     textStream.setCodec(\"UTF-8\");\n```","source":"_posts/QT基础8——文件读写.md","raw":"title: QT基础8——文件读写\nauthor: Cyrus\ntags: []\ncategories:\n  - QT\ndate: 2019-01-01 20:42:00\n---\n#### 读文件\n```\n//弹窗选择文件\n\tQString path = QFileDialog::getOpenFileName(this, \"open\", \"../\", \"TXT(*.txt)\");\n\n    if(path.isEmpty() == true) {\n        return;\n    }\n    //打开文件\n    bool success = file.open(QIODevice::ReadOnly);\n        if(success == true) {\n//        //读文件,默认只识别utf-8编码\n\t      //小文件的话可以一次读完\t\t\n//        QByteArray array =  file.readAll();\n//        ui->textEdit->setText(array);\n\t\t\n        //大文件的话一次读一行\n        QByteArray array;\n        while (file.atEnd() == false) {\n            array += file.readLine();\n        }\n        ui->textEdit->setText(array);\n    }\n    file.close();\n```\n\n#### 写文件\n```\n//弹框选择保存文件的路径\n\t\tQString path = QFileDialog::getSaveFileName(this, \"save\", \"../\", \"TXT(*.txt)\");\n    if (path.isEmpty() == true) {\n        return;\n    }\n\n    QFile file;\n    file.setFileName(path);\n    bool success = file.open(QIODevice::WriteOnly);\n\n    if (success) {\n        QString str = ui->textEdit->toPlainText();\n\n        // str.toUtf8() -->QString->QByteArray\n//        file.write(str.toUtf8());\n\n        //QString->C++ String -> char *\n        file.write(str.toStdString().data());\n    }\n    file.close();\n```\n\n#### 文件信息\n```\n\tQFileInfo info(path);\n     qDebug() << \"文件名字：\" << info.fileName();\n     qDebug() << \"文件后缀\" << info.suffix();\n     qDebug() << \"文件大小\" << info.size();\n     qDebug() << \"创建时间\" << info.birthTime().toString(\"yyyy-MM-dd hh:mm:ss\");\n```\n\n#### 二进制读写文件\n```\n  \t//写文件\n\tQFile file(\"../123.txt\");\n    if (file.open(QIODevice::WriteOnly) == false) {\n        qDebug() << \"Open failure\";\n        return;\n    }\n\n    QDataStream stream(&file);\n    stream << QString(\"试一试\") << 123;\n    file.close();\n    \n    \n    //读文件\n    QFile file(\"../123.txt\");\n    if (file.open(QIODevice::ReadOnly) == false) {\n        qDebug() << \"Open failure\";\n        return;\n    }\n\n    QDataStream stream(&file);\n    QString str;\n    int a;\n    stream >> str >> a;\n    qDebug() << str.toUtf8().data() << a;\n    file.close();\n    \n    //文本格式读写文件,用法与QDataStream类似，区别是可以设置编码类型\n     QTextStream textStream;\n     textStream.setCodec(\"UTF-8\");\n```","slug":"QT基础8——文件读写","published":1,"updated":"2019-07-09T08:13:34.943Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyzlbt8o00160j66oye6ja14","content":"<h4 id=\"读文件\"><a href=\"#读文件\" class=\"headerlink\" title=\"读文件\"></a>读文件</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//弹窗选择文件</span><br><span class=\"line\">\tQString path = QFileDialog::getOpenFileName(this, &quot;open&quot;, &quot;../&quot;, &quot;TXT(*.txt)&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    if(path.isEmpty() == true) &#123;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //打开文件</span><br><span class=\"line\">    bool success = file.open(QIODevice::ReadOnly);</span><br><span class=\"line\">        if(success == true) &#123;</span><br><span class=\"line\">//        //读文件,默认只识别utf-8编码</span><br><span class=\"line\">\t      //小文件的话可以一次读完\t\t</span><br><span class=\"line\">//        QByteArray array =  file.readAll();</span><br><span class=\"line\">//        ui-&gt;textEdit-&gt;setText(array);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">        //大文件的话一次读一行</span><br><span class=\"line\">        QByteArray array;</span><br><span class=\"line\">        while (file.atEnd() == false) &#123;</span><br><span class=\"line\">            array += file.readLine();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ui-&gt;textEdit-&gt;setText(array);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    file.close();</span><br></pre></td></tr></table></figure>\n<h4 id=\"写文件\"><a href=\"#写文件\" class=\"headerlink\" title=\"写文件\"></a>写文件</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//弹框选择保存文件的路径</span><br><span class=\"line\">\t\tQString path = QFileDialog::getSaveFileName(this, &quot;save&quot;, &quot;../&quot;, &quot;TXT(*.txt)&quot;);</span><br><span class=\"line\">    if (path.isEmpty() == true) &#123;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    QFile file;</span><br><span class=\"line\">    file.setFileName(path);</span><br><span class=\"line\">    bool success = file.open(QIODevice::WriteOnly);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (success) &#123;</span><br><span class=\"line\">        QString str = ui-&gt;textEdit-&gt;toPlainText();</span><br><span class=\"line\"></span><br><span class=\"line\">        // str.toUtf8() --&gt;QString-&gt;QByteArray</span><br><span class=\"line\">//        file.write(str.toUtf8());</span><br><span class=\"line\"></span><br><span class=\"line\">        //QString-&gt;C++ String -&gt; char *</span><br><span class=\"line\">        file.write(str.toStdString().data());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    file.close();</span><br></pre></td></tr></table></figure>\n<h4 id=\"文件信息\"><a href=\"#文件信息\" class=\"headerlink\" title=\"文件信息\"></a>文件信息</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">QFileInfo info(path);</span><br><span class=\"line\">    qDebug() &lt;&lt; &quot;文件名字：&quot; &lt;&lt; info.fileName();</span><br><span class=\"line\">    qDebug() &lt;&lt; &quot;文件后缀&quot; &lt;&lt; info.suffix();</span><br><span class=\"line\">    qDebug() &lt;&lt; &quot;文件大小&quot; &lt;&lt; info.size();</span><br><span class=\"line\">    qDebug() &lt;&lt; &quot;创建时间&quot; &lt;&lt; info.birthTime().toString(&quot;yyyy-MM-dd hh:mm:ss&quot;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"二进制读写文件\"><a href=\"#二进制读写文件\" class=\"headerlink\" title=\"二进制读写文件\"></a>二进制读写文件</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> \t//写文件</span><br><span class=\"line\">QFile file(&quot;../123.txt&quot;);</span><br><span class=\"line\">   if (file.open(QIODevice::WriteOnly) == false) &#123;</span><br><span class=\"line\">       qDebug() &lt;&lt; &quot;Open failure&quot;;</span><br><span class=\"line\">       return;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   QDataStream stream(&amp;file);</span><br><span class=\"line\">   stream &lt;&lt; QString(&quot;试一试&quot;) &lt;&lt; 123;</span><br><span class=\"line\">   file.close();</span><br><span class=\"line\">   </span><br><span class=\"line\">   </span><br><span class=\"line\">   //读文件</span><br><span class=\"line\">   QFile file(&quot;../123.txt&quot;);</span><br><span class=\"line\">   if (file.open(QIODevice::ReadOnly) == false) &#123;</span><br><span class=\"line\">       qDebug() &lt;&lt; &quot;Open failure&quot;;</span><br><span class=\"line\">       return;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   QDataStream stream(&amp;file);</span><br><span class=\"line\">   QString str;</span><br><span class=\"line\">   int a;</span><br><span class=\"line\">   stream &gt;&gt; str &gt;&gt; a;</span><br><span class=\"line\">   qDebug() &lt;&lt; str.toUtf8().data() &lt;&lt; a;</span><br><span class=\"line\">   file.close();</span><br><span class=\"line\">   </span><br><span class=\"line\">   //文本格式读写文件,用法与QDataStream类似，区别是可以设置编码类型</span><br><span class=\"line\">    QTextStream textStream;</span><br><span class=\"line\">    textStream.setCodec(&quot;UTF-8&quot;);</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"读文件\"><a href=\"#读文件\" class=\"headerlink\" title=\"读文件\"></a>读文件</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//弹窗选择文件</span><br><span class=\"line\">\tQString path = QFileDialog::getOpenFileName(this, &quot;open&quot;, &quot;../&quot;, &quot;TXT(*.txt)&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    if(path.isEmpty() == true) &#123;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //打开文件</span><br><span class=\"line\">    bool success = file.open(QIODevice::ReadOnly);</span><br><span class=\"line\">        if(success == true) &#123;</span><br><span class=\"line\">//        //读文件,默认只识别utf-8编码</span><br><span class=\"line\">\t      //小文件的话可以一次读完\t\t</span><br><span class=\"line\">//        QByteArray array =  file.readAll();</span><br><span class=\"line\">//        ui-&gt;textEdit-&gt;setText(array);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">        //大文件的话一次读一行</span><br><span class=\"line\">        QByteArray array;</span><br><span class=\"line\">        while (file.atEnd() == false) &#123;</span><br><span class=\"line\">            array += file.readLine();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ui-&gt;textEdit-&gt;setText(array);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    file.close();</span><br></pre></td></tr></table></figure>\n<h4 id=\"写文件\"><a href=\"#写文件\" class=\"headerlink\" title=\"写文件\"></a>写文件</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//弹框选择保存文件的路径</span><br><span class=\"line\">\t\tQString path = QFileDialog::getSaveFileName(this, &quot;save&quot;, &quot;../&quot;, &quot;TXT(*.txt)&quot;);</span><br><span class=\"line\">    if (path.isEmpty() == true) &#123;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    QFile file;</span><br><span class=\"line\">    file.setFileName(path);</span><br><span class=\"line\">    bool success = file.open(QIODevice::WriteOnly);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (success) &#123;</span><br><span class=\"line\">        QString str = ui-&gt;textEdit-&gt;toPlainText();</span><br><span class=\"line\"></span><br><span class=\"line\">        // str.toUtf8() --&gt;QString-&gt;QByteArray</span><br><span class=\"line\">//        file.write(str.toUtf8());</span><br><span class=\"line\"></span><br><span class=\"line\">        //QString-&gt;C++ String -&gt; char *</span><br><span class=\"line\">        file.write(str.toStdString().data());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    file.close();</span><br></pre></td></tr></table></figure>\n<h4 id=\"文件信息\"><a href=\"#文件信息\" class=\"headerlink\" title=\"文件信息\"></a>文件信息</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">QFileInfo info(path);</span><br><span class=\"line\">    qDebug() &lt;&lt; &quot;文件名字：&quot; &lt;&lt; info.fileName();</span><br><span class=\"line\">    qDebug() &lt;&lt; &quot;文件后缀&quot; &lt;&lt; info.suffix();</span><br><span class=\"line\">    qDebug() &lt;&lt; &quot;文件大小&quot; &lt;&lt; info.size();</span><br><span class=\"line\">    qDebug() &lt;&lt; &quot;创建时间&quot; &lt;&lt; info.birthTime().toString(&quot;yyyy-MM-dd hh:mm:ss&quot;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"二进制读写文件\"><a href=\"#二进制读写文件\" class=\"headerlink\" title=\"二进制读写文件\"></a>二进制读写文件</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> \t//写文件</span><br><span class=\"line\">QFile file(&quot;../123.txt&quot;);</span><br><span class=\"line\">   if (file.open(QIODevice::WriteOnly) == false) &#123;</span><br><span class=\"line\">       qDebug() &lt;&lt; &quot;Open failure&quot;;</span><br><span class=\"line\">       return;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   QDataStream stream(&amp;file);</span><br><span class=\"line\">   stream &lt;&lt; QString(&quot;试一试&quot;) &lt;&lt; 123;</span><br><span class=\"line\">   file.close();</span><br><span class=\"line\">   </span><br><span class=\"line\">   </span><br><span class=\"line\">   //读文件</span><br><span class=\"line\">   QFile file(&quot;../123.txt&quot;);</span><br><span class=\"line\">   if (file.open(QIODevice::ReadOnly) == false) &#123;</span><br><span class=\"line\">       qDebug() &lt;&lt; &quot;Open failure&quot;;</span><br><span class=\"line\">       return;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   QDataStream stream(&amp;file);</span><br><span class=\"line\">   QString str;</span><br><span class=\"line\">   int a;</span><br><span class=\"line\">   stream &gt;&gt; str &gt;&gt; a;</span><br><span class=\"line\">   qDebug() &lt;&lt; str.toUtf8().data() &lt;&lt; a;</span><br><span class=\"line\">   file.close();</span><br><span class=\"line\">   </span><br><span class=\"line\">   //文本格式读写文件,用法与QDataStream类似，区别是可以设置编码类型</span><br><span class=\"line\">    QTextStream textStream;</span><br><span class=\"line\">    textStream.setCodec(&quot;UTF-8&quot;);</span><br></pre></td></tr></table></figure>"},{"title":"QT基础9——TCP","author":"Cyrus","date":"2019-01-01T12:56:00.000Z","_content":"#### 服务端\n常用的tcp服务端会有两个套接字，一个监听套接字和三次握手之后正常通讯 的套接字。QT的tcp服务端把这两个套接字设计成两个类：QTcpServer（监听套接字）和QTcpSocket（通讯套接字，客户端只用通讯套接字）。\n```\n//1、创建监听套接字\nserver = new QTcpServer(this);\n\n//2、监听地址和端口，相当于socket的 bind+listen\nserver->listen(QHostAddress::Any, 10000);\n\n//3、当有客户端连接时，会发出newConnection信号\nconnect(server, &QTcpServer::newConnection,\n            [=] () {\n            \n        //4、获取三次握手成功的客户端链接，相当于accept\n        tcpSocket = server->nextPendingConnection();\n\t\t\n        //获取客户端IP\n        QString ip = tcpSocket->peerAddress().toString();\n        //获取客户端商品\n        quint16 port = tcpSocket->peerPort();\n        QString temp = QString(\"[%1:%2]: 连接成功\").arg(ip).arg(port);\n        qDebug() << ip << port;\n        ui->textRead->setText(temp);\n\t\t\n        //5、当接收到客户端数据时，会发出readyRead信号\n        connect(tcpSocket, &QTcpSocket::readyRead,\n                [=]() {\n             //读数据，获有接口文档的，可以读定长数据\n            QByteArray array = tcpSocket->readAll();\n            ui->textRead->append(array);\n        });\n\t\t\n        //6、客户端断开时，会发出disconnected信号，处理断开事件\n        connect(tcpSocket, &QTcpSocket::disconnected,\n                [=]() {\n            tcpSocket->disconnectFromHost();\n            tcpSocket->close();\n        });\n\n    });\n    \n    //写数据到客户端\n    QString str = @\"Hello world\";\n    tcpSocket->write(str.toUtf8().data());\n    \n    //主动断开连接\n    tcpSocket->disconnectFromHost();\n    tcpSocket->close();\n    tcpSocket = NULL;\n```\n\n#### 客户端\n```\n//1、创建socket\nclient = new QTcpSocket(this);\n\n//2、连接服务端\nclient->connectToHost(\"127.0.0.1\", 8888, QIODevice::ReadWrite);\n\n//3、处理连接成功信号\nconnect(client, &QTcpSocket::connected,\n            [=](){\n        QString ip = client->peerAddress().toString();\n        quint16 port = client->peerPort();\n        QString temp = QString(\"[%1 : %2]\").arg(ip).arg(port);\n        ui->editRead->setText(temp);\n    });\n    \n//4、处理收到数据信号\nconnect(client, &QTcpSocket::readyRead,\n            [=](){\n        QByteArray array = client->readAll();\n        ui->editRead->append(array);\n });\n \n 5、处理断开连接信号\n connect(client, &QTcpSocket::disconnected, \n            [=](){\n        //服务端断开连接\n    });\n    \n    \n//写数据\nQString str = @\"Hello world\";\nclient->write(str.toUtf8().data());\n\n//断开连接\nclient->disconnectFromHost();\nclient->close();\nui->editRead->setText(\"disconnected\");\nclient = NULL;\n```","source":"_posts/QT基础9——TCP.md","raw":"title: QT基础9——TCP\nauthor: Cyrus\ntags: []\ncategories:\n  - QT\ndate: 2019-01-01 20:56:00\n---\n#### 服务端\n常用的tcp服务端会有两个套接字，一个监听套接字和三次握手之后正常通讯 的套接字。QT的tcp服务端把这两个套接字设计成两个类：QTcpServer（监听套接字）和QTcpSocket（通讯套接字，客户端只用通讯套接字）。\n```\n//1、创建监听套接字\nserver = new QTcpServer(this);\n\n//2、监听地址和端口，相当于socket的 bind+listen\nserver->listen(QHostAddress::Any, 10000);\n\n//3、当有客户端连接时，会发出newConnection信号\nconnect(server, &QTcpServer::newConnection,\n            [=] () {\n            \n        //4、获取三次握手成功的客户端链接，相当于accept\n        tcpSocket = server->nextPendingConnection();\n\t\t\n        //获取客户端IP\n        QString ip = tcpSocket->peerAddress().toString();\n        //获取客户端商品\n        quint16 port = tcpSocket->peerPort();\n        QString temp = QString(\"[%1:%2]: 连接成功\").arg(ip).arg(port);\n        qDebug() << ip << port;\n        ui->textRead->setText(temp);\n\t\t\n        //5、当接收到客户端数据时，会发出readyRead信号\n        connect(tcpSocket, &QTcpSocket::readyRead,\n                [=]() {\n             //读数据，获有接口文档的，可以读定长数据\n            QByteArray array = tcpSocket->readAll();\n            ui->textRead->append(array);\n        });\n\t\t\n        //6、客户端断开时，会发出disconnected信号，处理断开事件\n        connect(tcpSocket, &QTcpSocket::disconnected,\n                [=]() {\n            tcpSocket->disconnectFromHost();\n            tcpSocket->close();\n        });\n\n    });\n    \n    //写数据到客户端\n    QString str = @\"Hello world\";\n    tcpSocket->write(str.toUtf8().data());\n    \n    //主动断开连接\n    tcpSocket->disconnectFromHost();\n    tcpSocket->close();\n    tcpSocket = NULL;\n```\n\n#### 客户端\n```\n//1、创建socket\nclient = new QTcpSocket(this);\n\n//2、连接服务端\nclient->connectToHost(\"127.0.0.1\", 8888, QIODevice::ReadWrite);\n\n//3、处理连接成功信号\nconnect(client, &QTcpSocket::connected,\n            [=](){\n        QString ip = client->peerAddress().toString();\n        quint16 port = client->peerPort();\n        QString temp = QString(\"[%1 : %2]\").arg(ip).arg(port);\n        ui->editRead->setText(temp);\n    });\n    \n//4、处理收到数据信号\nconnect(client, &QTcpSocket::readyRead,\n            [=](){\n        QByteArray array = client->readAll();\n        ui->editRead->append(array);\n });\n \n 5、处理断开连接信号\n connect(client, &QTcpSocket::disconnected, \n            [=](){\n        //服务端断开连接\n    });\n    \n    \n//写数据\nQString str = @\"Hello world\";\nclient->write(str.toUtf8().data());\n\n//断开连接\nclient->disconnectFromHost();\nclient->close();\nui->editRead->setText(\"disconnected\");\nclient = NULL;\n```","slug":"QT基础9——TCP","published":1,"updated":"2019-07-09T08:13:34.943Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyzlbt8q00190j66pwo536aa","content":"<h4 id=\"服务端\"><a href=\"#服务端\" class=\"headerlink\" title=\"服务端\"></a>服务端</h4><p>常用的tcp服务端会有两个套接字，一个监听套接字和三次握手之后正常通讯 的套接字。QT的tcp服务端把这两个套接字设计成两个类：QTcpServer（监听套接字）和QTcpSocket（通讯套接字，客户端只用通讯套接字）。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//1、创建监听套接字</span><br><span class=\"line\">server = new QTcpServer(this);</span><br><span class=\"line\"></span><br><span class=\"line\">//2、监听地址和端口，相当于socket的 bind+listen</span><br><span class=\"line\">server-&gt;listen(QHostAddress::Any, 10000);</span><br><span class=\"line\"></span><br><span class=\"line\">//3、当有客户端连接时，会发出newConnection信号</span><br><span class=\"line\">connect(server, &amp;QTcpServer::newConnection,</span><br><span class=\"line\">            [=] () &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">        //4、获取三次握手成功的客户端链接，相当于accept</span><br><span class=\"line\">        tcpSocket = server-&gt;nextPendingConnection();</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">        //获取客户端IP</span><br><span class=\"line\">        QString ip = tcpSocket-&gt;peerAddress().toString();</span><br><span class=\"line\">        //获取客户端商品</span><br><span class=\"line\">        quint16 port = tcpSocket-&gt;peerPort();</span><br><span class=\"line\">        QString temp = QString(&quot;[%1:%2]: 连接成功&quot;).arg(ip).arg(port);</span><br><span class=\"line\">        qDebug() &lt;&lt; ip &lt;&lt; port;</span><br><span class=\"line\">        ui-&gt;textRead-&gt;setText(temp);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">        //5、当接收到客户端数据时，会发出readyRead信号</span><br><span class=\"line\">        connect(tcpSocket, &amp;QTcpSocket::readyRead,</span><br><span class=\"line\">                [=]() &#123;</span><br><span class=\"line\">             //读数据，获有接口文档的，可以读定长数据</span><br><span class=\"line\">            QByteArray array = tcpSocket-&gt;readAll();</span><br><span class=\"line\">            ui-&gt;textRead-&gt;append(array);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">        //6、客户端断开时，会发出disconnected信号，处理断开事件</span><br><span class=\"line\">        connect(tcpSocket, &amp;QTcpSocket::disconnected,</span><br><span class=\"line\">                [=]() &#123;</span><br><span class=\"line\">            tcpSocket-&gt;disconnectFromHost();</span><br><span class=\"line\">            tcpSocket-&gt;close();</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    //写数据到客户端</span><br><span class=\"line\">    QString str = @&quot;Hello world&quot;;</span><br><span class=\"line\">    tcpSocket-&gt;write(str.toUtf8().data());</span><br><span class=\"line\">    </span><br><span class=\"line\">    //主动断开连接</span><br><span class=\"line\">    tcpSocket-&gt;disconnectFromHost();</span><br><span class=\"line\">    tcpSocket-&gt;close();</span><br><span class=\"line\">    tcpSocket = NULL;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//1、创建socket</span><br><span class=\"line\">client = new QTcpSocket(this);</span><br><span class=\"line\"></span><br><span class=\"line\">//2、连接服务端</span><br><span class=\"line\">client-&gt;connectToHost(&quot;127.0.0.1&quot;, 8888, QIODevice::ReadWrite);</span><br><span class=\"line\"></span><br><span class=\"line\">//3、处理连接成功信号</span><br><span class=\"line\">connect(client, &amp;QTcpSocket::connected,</span><br><span class=\"line\">            [=]()&#123;</span><br><span class=\"line\">        QString ip = client-&gt;peerAddress().toString();</span><br><span class=\"line\">        quint16 port = client-&gt;peerPort();</span><br><span class=\"line\">        QString temp = QString(&quot;[%1 : %2]&quot;).arg(ip).arg(port);</span><br><span class=\"line\">        ui-&gt;editRead-&gt;setText(temp);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">//4、处理收到数据信号</span><br><span class=\"line\">connect(client, &amp;QTcpSocket::readyRead,</span><br><span class=\"line\">            [=]()&#123;</span><br><span class=\"line\">        QByteArray array = client-&gt;readAll();</span><br><span class=\"line\">        ui-&gt;editRead-&gt;append(array);</span><br><span class=\"line\"> &#125;);</span><br><span class=\"line\"> </span><br><span class=\"line\"> 5、处理断开连接信号</span><br><span class=\"line\"> connect(client, &amp;QTcpSocket::disconnected, </span><br><span class=\"line\">            [=]()&#123;</span><br><span class=\"line\">        //服务端断开连接</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">//写数据</span><br><span class=\"line\">QString str = @&quot;Hello world&quot;;</span><br><span class=\"line\">client-&gt;write(str.toUtf8().data());</span><br><span class=\"line\"></span><br><span class=\"line\">//断开连接</span><br><span class=\"line\">client-&gt;disconnectFromHost();</span><br><span class=\"line\">client-&gt;close();</span><br><span class=\"line\">ui-&gt;editRead-&gt;setText(&quot;disconnected&quot;);</span><br><span class=\"line\">client = NULL;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"服务端\"><a href=\"#服务端\" class=\"headerlink\" title=\"服务端\"></a>服务端</h4><p>常用的tcp服务端会有两个套接字，一个监听套接字和三次握手之后正常通讯 的套接字。QT的tcp服务端把这两个套接字设计成两个类：QTcpServer（监听套接字）和QTcpSocket（通讯套接字，客户端只用通讯套接字）。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//1、创建监听套接字</span><br><span class=\"line\">server = new QTcpServer(this);</span><br><span class=\"line\"></span><br><span class=\"line\">//2、监听地址和端口，相当于socket的 bind+listen</span><br><span class=\"line\">server-&gt;listen(QHostAddress::Any, 10000);</span><br><span class=\"line\"></span><br><span class=\"line\">//3、当有客户端连接时，会发出newConnection信号</span><br><span class=\"line\">connect(server, &amp;QTcpServer::newConnection,</span><br><span class=\"line\">            [=] () &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">        //4、获取三次握手成功的客户端链接，相当于accept</span><br><span class=\"line\">        tcpSocket = server-&gt;nextPendingConnection();</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">        //获取客户端IP</span><br><span class=\"line\">        QString ip = tcpSocket-&gt;peerAddress().toString();</span><br><span class=\"line\">        //获取客户端商品</span><br><span class=\"line\">        quint16 port = tcpSocket-&gt;peerPort();</span><br><span class=\"line\">        QString temp = QString(&quot;[%1:%2]: 连接成功&quot;).arg(ip).arg(port);</span><br><span class=\"line\">        qDebug() &lt;&lt; ip &lt;&lt; port;</span><br><span class=\"line\">        ui-&gt;textRead-&gt;setText(temp);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">        //5、当接收到客户端数据时，会发出readyRead信号</span><br><span class=\"line\">        connect(tcpSocket, &amp;QTcpSocket::readyRead,</span><br><span class=\"line\">                [=]() &#123;</span><br><span class=\"line\">             //读数据，获有接口文档的，可以读定长数据</span><br><span class=\"line\">            QByteArray array = tcpSocket-&gt;readAll();</span><br><span class=\"line\">            ui-&gt;textRead-&gt;append(array);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">        //6、客户端断开时，会发出disconnected信号，处理断开事件</span><br><span class=\"line\">        connect(tcpSocket, &amp;QTcpSocket::disconnected,</span><br><span class=\"line\">                [=]() &#123;</span><br><span class=\"line\">            tcpSocket-&gt;disconnectFromHost();</span><br><span class=\"line\">            tcpSocket-&gt;close();</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    //写数据到客户端</span><br><span class=\"line\">    QString str = @&quot;Hello world&quot;;</span><br><span class=\"line\">    tcpSocket-&gt;write(str.toUtf8().data());</span><br><span class=\"line\">    </span><br><span class=\"line\">    //主动断开连接</span><br><span class=\"line\">    tcpSocket-&gt;disconnectFromHost();</span><br><span class=\"line\">    tcpSocket-&gt;close();</span><br><span class=\"line\">    tcpSocket = NULL;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//1、创建socket</span><br><span class=\"line\">client = new QTcpSocket(this);</span><br><span class=\"line\"></span><br><span class=\"line\">//2、连接服务端</span><br><span class=\"line\">client-&gt;connectToHost(&quot;127.0.0.1&quot;, 8888, QIODevice::ReadWrite);</span><br><span class=\"line\"></span><br><span class=\"line\">//3、处理连接成功信号</span><br><span class=\"line\">connect(client, &amp;QTcpSocket::connected,</span><br><span class=\"line\">            [=]()&#123;</span><br><span class=\"line\">        QString ip = client-&gt;peerAddress().toString();</span><br><span class=\"line\">        quint16 port = client-&gt;peerPort();</span><br><span class=\"line\">        QString temp = QString(&quot;[%1 : %2]&quot;).arg(ip).arg(port);</span><br><span class=\"line\">        ui-&gt;editRead-&gt;setText(temp);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">//4、处理收到数据信号</span><br><span class=\"line\">connect(client, &amp;QTcpSocket::readyRead,</span><br><span class=\"line\">            [=]()&#123;</span><br><span class=\"line\">        QByteArray array = client-&gt;readAll();</span><br><span class=\"line\">        ui-&gt;editRead-&gt;append(array);</span><br><span class=\"line\"> &#125;);</span><br><span class=\"line\"> </span><br><span class=\"line\"> 5、处理断开连接信号</span><br><span class=\"line\"> connect(client, &amp;QTcpSocket::disconnected, </span><br><span class=\"line\">            [=]()&#123;</span><br><span class=\"line\">        //服务端断开连接</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">//写数据</span><br><span class=\"line\">QString str = @&quot;Hello world&quot;;</span><br><span class=\"line\">client-&gt;write(str.toUtf8().data());</span><br><span class=\"line\"></span><br><span class=\"line\">//断开连接</span><br><span class=\"line\">client-&gt;disconnectFromHost();</span><br><span class=\"line\">client-&gt;close();</span><br><span class=\"line\">ui-&gt;editRead-&gt;setText(&quot;disconnected&quot;);</span><br><span class=\"line\">client = NULL;</span><br></pre></td></tr></table></figure>"},{"title":"SRS服务器 二 保存及拉取文件数据","author":"Cyrus","date":"2018-10-31T14:35:00.000Z","_content":"在SRS服务器一中讲到了SRS服务器的搭建，现在讲一下SRS服务器保存推流文件的设置。\n\n### 一、SRS服务器保存推流文件的设置\n\n1、找到srs.conf文件配置\n```\ncd srs/trunk/\nvi conf/srs.conf\n```\n\n2、修改如下：\n```\n# main config for srs.\n# @see full.conf for detail config.\n\nlisten              1935;\nmax_connections     1000;\nsrs_log_tank        file;\nsrs_log_file        ./objs/srs.log;\nhttp_api {\n    enabled         on;\n    listen          1985;\n}\nhttp_server {\n    enabled         on;\n    listen          8080;\n    dir             ./objs/nginx/html;\n}\nstats {\n    network         0;\n    disk            sda sdb xvda xvdb;\n}\nvhost __defaultVhost__ {\n    dvr {\t\t//dvr保存数据的配置\n        enabled    on;\n#        dvr_path    ./objs/nginx/html/[app]/[stream].[timestamp].flv;\n        dvr_path    ./objs/nginx/html/[app]-[stream].flv\n        dvr_plan    session;\n        dvr_duration    30;\n        dvr_wait_keyframe    on;\n        time_jitter    full;\n    }\n}\n```\n其中dvr_path就是文件保存地址,保存文件必须为flv格式。在推流过程中，文件会保存为xxx.flv.tmp，停止推流后自动修改为xxx.flv。\nobs推流：\n![](obs_set.png)\nvlc播放：\n![](vlc_play.png)\n推流时：\n![](pushing.png)\n推流后：\n![](pushed.png)\n\n直接播放保存的flv文件(点播)：\n![](play_file.png)\n注：只有存放在***/objs/nginx/html***目录下的***flv格式文件***才能播放。另推流时暂存的xxx.flv.tmp文件也可以用这种方式播放，即<font color=ff0000>播放的文件，只跟文件存放数据的格式有关，跟文件名无关</font>。\n\n\n\n","source":"_posts/SRS服务器-二-保存及拉取数据.md","raw":"title: SRS服务器 二 保存及拉取文件数据\nauthor: Cyrus\ntags:\n  - SRS\ncategories:\n  - rtmp\ndate: 2018-10-31 22:35:00\n---\n在SRS服务器一中讲到了SRS服务器的搭建，现在讲一下SRS服务器保存推流文件的设置。\n\n### 一、SRS服务器保存推流文件的设置\n\n1、找到srs.conf文件配置\n```\ncd srs/trunk/\nvi conf/srs.conf\n```\n\n2、修改如下：\n```\n# main config for srs.\n# @see full.conf for detail config.\n\nlisten              1935;\nmax_connections     1000;\nsrs_log_tank        file;\nsrs_log_file        ./objs/srs.log;\nhttp_api {\n    enabled         on;\n    listen          1985;\n}\nhttp_server {\n    enabled         on;\n    listen          8080;\n    dir             ./objs/nginx/html;\n}\nstats {\n    network         0;\n    disk            sda sdb xvda xvdb;\n}\nvhost __defaultVhost__ {\n    dvr {\t\t//dvr保存数据的配置\n        enabled    on;\n#        dvr_path    ./objs/nginx/html/[app]/[stream].[timestamp].flv;\n        dvr_path    ./objs/nginx/html/[app]-[stream].flv\n        dvr_plan    session;\n        dvr_duration    30;\n        dvr_wait_keyframe    on;\n        time_jitter    full;\n    }\n}\n```\n其中dvr_path就是文件保存地址,保存文件必须为flv格式。在推流过程中，文件会保存为xxx.flv.tmp，停止推流后自动修改为xxx.flv。\nobs推流：\n![](obs_set.png)\nvlc播放：\n![](vlc_play.png)\n推流时：\n![](pushing.png)\n推流后：\n![](pushed.png)\n\n直接播放保存的flv文件(点播)：\n![](play_file.png)\n注：只有存放在***/objs/nginx/html***目录下的***flv格式文件***才能播放。另推流时暂存的xxx.flv.tmp文件也可以用这种方式播放，即<font color=ff0000>播放的文件，只跟文件存放数据的格式有关，跟文件名无关</font>。\n\n\n\n","slug":"SRS服务器-二-保存及拉取数据","published":1,"updated":"2019-07-09T08:13:34.944Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyzlbt8t001b0j66eof4p3uc","content":"<p>在SRS服务器一中讲到了SRS服务器的搭建，现在讲一下SRS服务器保存推流文件的设置。</p>\n<h3 id=\"一、SRS服务器保存推流文件的设置\"><a href=\"#一、SRS服务器保存推流文件的设置\" class=\"headerlink\" title=\"一、SRS服务器保存推流文件的设置\"></a>一、SRS服务器保存推流文件的设置</h3><p>1、找到srs.conf文件配置<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd srs/trunk/</span><br><span class=\"line\">vi conf/srs.conf</span><br></pre></td></tr></table></figure></p>\n<p>2、修改如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># main config for srs.</span><br><span class=\"line\"># @see full.conf for detail config.</span><br><span class=\"line\"></span><br><span class=\"line\">listen              1935;</span><br><span class=\"line\">max_connections     1000;</span><br><span class=\"line\">srs_log_tank        file;</span><br><span class=\"line\">srs_log_file        ./objs/srs.log;</span><br><span class=\"line\">http_api &#123;</span><br><span class=\"line\">    enabled         on;</span><br><span class=\"line\">    listen          1985;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">http_server &#123;</span><br><span class=\"line\">    enabled         on;</span><br><span class=\"line\">    listen          8080;</span><br><span class=\"line\">    dir             ./objs/nginx/html;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">stats &#123;</span><br><span class=\"line\">    network         0;</span><br><span class=\"line\">    disk            sda sdb xvda xvdb;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">vhost __defaultVhost__ &#123;</span><br><span class=\"line\">    dvr &#123;\t\t//dvr保存数据的配置</span><br><span class=\"line\">        enabled    on;</span><br><span class=\"line\">#        dvr_path    ./objs/nginx/html/[app]/[stream].[timestamp].flv;</span><br><span class=\"line\">        dvr_path    ./objs/nginx/html/[app]-[stream].flv</span><br><span class=\"line\">        dvr_plan    session;</span><br><span class=\"line\">        dvr_duration    30;</span><br><span class=\"line\">        dvr_wait_keyframe    on;</span><br><span class=\"line\">        time_jitter    full;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>其中dvr_path就是文件保存地址,保存文件必须为flv格式。在推流过程中，文件会保存为xxx.flv.tmp，停止推流后自动修改为xxx.flv。<br>obs推流：<br><img src=\"//www.cyrus.fun/2018/10/31/SRS服务器-二-保存及拉取数据/obs_set.png\" alt=\"\"><br>vlc播放：<br><img src=\"//www.cyrus.fun/2018/10/31/SRS服务器-二-保存及拉取数据/vlc_play.png\" alt=\"\"><br>推流时：<br><img src=\"//www.cyrus.fun/2018/10/31/SRS服务器-二-保存及拉取数据/pushing.png\" alt=\"\"><br>推流后：<br><img src=\"//www.cyrus.fun/2018/10/31/SRS服务器-二-保存及拉取数据/pushed.png\" alt=\"\"></p>\n<p>直接播放保存的flv文件(点播)：<br><img src=\"//www.cyrus.fun/2018/10/31/SRS服务器-二-保存及拉取数据/play_file.png\" alt=\"\"><br>注：只有存放在<strong><em>/objs/nginx/html</em></strong>目录下的<strong><em>flv格式文件</em></strong>才能播放。另推流时暂存的xxx.flv.tmp文件也可以用这种方式播放，即<font color=\"ff0000\">播放的文件，只跟文件存放数据的格式有关，跟文件名无关</font>。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在SRS服务器一中讲到了SRS服务器的搭建，现在讲一下SRS服务器保存推流文件的设置。</p>\n<h3 id=\"一、SRS服务器保存推流文件的设置\"><a href=\"#一、SRS服务器保存推流文件的设置\" class=\"headerlink\" title=\"一、SRS服务器保存推流文件的设置\"></a>一、SRS服务器保存推流文件的设置</h3><p>1、找到srs.conf文件配置<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd srs/trunk/</span><br><span class=\"line\">vi conf/srs.conf</span><br></pre></td></tr></table></figure></p>\n<p>2、修改如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># main config for srs.</span><br><span class=\"line\"># @see full.conf for detail config.</span><br><span class=\"line\"></span><br><span class=\"line\">listen              1935;</span><br><span class=\"line\">max_connections     1000;</span><br><span class=\"line\">srs_log_tank        file;</span><br><span class=\"line\">srs_log_file        ./objs/srs.log;</span><br><span class=\"line\">http_api &#123;</span><br><span class=\"line\">    enabled         on;</span><br><span class=\"line\">    listen          1985;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">http_server &#123;</span><br><span class=\"line\">    enabled         on;</span><br><span class=\"line\">    listen          8080;</span><br><span class=\"line\">    dir             ./objs/nginx/html;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">stats &#123;</span><br><span class=\"line\">    network         0;</span><br><span class=\"line\">    disk            sda sdb xvda xvdb;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">vhost __defaultVhost__ &#123;</span><br><span class=\"line\">    dvr &#123;\t\t//dvr保存数据的配置</span><br><span class=\"line\">        enabled    on;</span><br><span class=\"line\">#        dvr_path    ./objs/nginx/html/[app]/[stream].[timestamp].flv;</span><br><span class=\"line\">        dvr_path    ./objs/nginx/html/[app]-[stream].flv</span><br><span class=\"line\">        dvr_plan    session;</span><br><span class=\"line\">        dvr_duration    30;</span><br><span class=\"line\">        dvr_wait_keyframe    on;</span><br><span class=\"line\">        time_jitter    full;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>其中dvr_path就是文件保存地址,保存文件必须为flv格式。在推流过程中，文件会保存为xxx.flv.tmp，停止推流后自动修改为xxx.flv。<br>obs推流：<br><img src=\"//www.cyrus.fun/2018/10/31/SRS服务器-二-保存及拉取数据/obs_set.png\" alt=\"\"><br>vlc播放：<br><img src=\"//www.cyrus.fun/2018/10/31/SRS服务器-二-保存及拉取数据/vlc_play.png\" alt=\"\"><br>推流时：<br><img src=\"//www.cyrus.fun/2018/10/31/SRS服务器-二-保存及拉取数据/pushing.png\" alt=\"\"><br>推流后：<br><img src=\"//www.cyrus.fun/2018/10/31/SRS服务器-二-保存及拉取数据/pushed.png\" alt=\"\"></p>\n<p>直接播放保存的flv文件(点播)：<br><img src=\"//www.cyrus.fun/2018/10/31/SRS服务器-二-保存及拉取数据/play_file.png\" alt=\"\"><br>注：只有存放在<strong><em>/objs/nginx/html</em></strong>目录下的<strong><em>flv格式文件</em></strong>才能播放。另推流时暂存的xxx.flv.tmp文件也可以用这种方式播放，即<font color=\"ff0000\">播放的文件，只跟文件存放数据的格式有关，跟文件名无关</font>。</p>\n"},{"title":"SRS服务器一 搭建","author":"Cyrus","date":"2018-10-23T15:33:00.000Z","_content":"### 一、什么是srs服务器\n\n按照项目github上的说法：SRS定位是运营级的互联网直播服务器集群，追求更好的概念完整性和最简单实现的代码。也就是说srs服务器是一个功能强大，容易实现的直播服务器。\n\n除了srs，直播服务器还有下面这些选择：\n\nFMS — Adobe公司出品的服务器，价格昂贵，当然是最正宗的，因为RTMP就是Adobe公司的私有协议；\n\nWowza — 需要授权费，效率和稳定性都还不错；\n\nRed5 — 一个开源实现， 效率和稳定性都稍微差些，由于它是Java实现的，所以天生支持跨平台运行；\n\nNignx-rtmp-module – -nginx的一个第三方模块，如果你熟悉nginx那是不错的选择，当然它也是免费的，不过功能就没有其他几个丰富了\n\n### 二、srs服务器的搭建（Ubuntu或Centos）\n\n#### 1、下载\n```\ngit clone https://github.com/ossrs/srs\n```\n#### 2、编译\n```\ncd srs/trunk\n./configure && make\n```\n服务器配置相对好点的，可以尝试 make -jn(n为线程数)加快编辑速度\n\n#### 3、编辑conf/rtmp.conf文件，配置内容：\n```\nlisten              1935;\npid                 ./objs/srs.pid;\nchunk_size          60000;\nff_log_dir          ./objs;\nsrs_log_tank        file;  \n#配置日志答应到文件，需要和srs_log_level配合使用\nsrs_log_level       trace;\n#制定配置文件的级别，默认级别是trace\nsrs_log_file        ./objs/srs.log;  \n#制定日志文件的位置。\nmax_connections     1000;\n#最大连接数\ndaemon              on;\n#以daemon的方式启动，如果要启动在console，那么需要配置daemon off;并且，需要配置srs_log_tank console;\nutc_time            off;\n#是否使用utc时间。如果该值为off则使用本地时间，如果开始使用utc时间。\nvhost __defaultVhost__ {   \n#默认的vhost，在没有指明vhost的情况，默认使用这个vhost。\n}\n```\n\n#### 4、启动服务\n在trunk目录下\n```\n ./objs/srs -c conf/srs.conf\n```\n*其他操作相关指令\n```\n停止 ./etc/init.d/srs stop\n重启 ./etc/init.d/srs restart\n```\n\n#### 5、其他注意事项\n*如果是阿里云服务器，需要设置端口映射。\n安全规则->添加安全规则\n![](SRS服务器搭建/rtmp映射.png)\n\n### 三、rtmp推流与播放\n\n#### 1、使用obs推流\nobs是一款免费且开源的用于视频录制以及直播串流的软件。在Windows, Mac以及Linux下均有客户端。obs设置如下:\n![](SRS服务器搭建/obs.png)\n\n#### 2、使用vlc播放\nVLC 是一款自由、开源的跨平台多媒体播放器及框架，可播放大多数多媒体文件，以及 DVD、音频 CD、VCD 及各类流媒体协议。vcl播放链接是obs的URL/流密钥，如下图：\n![](SRS服务器搭建/vlc.png)\n\n#### 3、最终效果如下图\n![](SRS服务器搭建/result_rtmp.png)","source":"_posts/SRS服务器搭建.md","raw":"title: SRS服务器一 搭建\nauthor: Cyrus\ntags:\n  - SRS\ncategories:\n  - rtmp\ndate: 2018-10-23 23:33:00\n---\n### 一、什么是srs服务器\n\n按照项目github上的说法：SRS定位是运营级的互联网直播服务器集群，追求更好的概念完整性和最简单实现的代码。也就是说srs服务器是一个功能强大，容易实现的直播服务器。\n\n除了srs，直播服务器还有下面这些选择：\n\nFMS — Adobe公司出品的服务器，价格昂贵，当然是最正宗的，因为RTMP就是Adobe公司的私有协议；\n\nWowza — 需要授权费，效率和稳定性都还不错；\n\nRed5 — 一个开源实现， 效率和稳定性都稍微差些，由于它是Java实现的，所以天生支持跨平台运行；\n\nNignx-rtmp-module – -nginx的一个第三方模块，如果你熟悉nginx那是不错的选择，当然它也是免费的，不过功能就没有其他几个丰富了\n\n### 二、srs服务器的搭建（Ubuntu或Centos）\n\n#### 1、下载\n```\ngit clone https://github.com/ossrs/srs\n```\n#### 2、编译\n```\ncd srs/trunk\n./configure && make\n```\n服务器配置相对好点的，可以尝试 make -jn(n为线程数)加快编辑速度\n\n#### 3、编辑conf/rtmp.conf文件，配置内容：\n```\nlisten              1935;\npid                 ./objs/srs.pid;\nchunk_size          60000;\nff_log_dir          ./objs;\nsrs_log_tank        file;  \n#配置日志答应到文件，需要和srs_log_level配合使用\nsrs_log_level       trace;\n#制定配置文件的级别，默认级别是trace\nsrs_log_file        ./objs/srs.log;  \n#制定日志文件的位置。\nmax_connections     1000;\n#最大连接数\ndaemon              on;\n#以daemon的方式启动，如果要启动在console，那么需要配置daemon off;并且，需要配置srs_log_tank console;\nutc_time            off;\n#是否使用utc时间。如果该值为off则使用本地时间，如果开始使用utc时间。\nvhost __defaultVhost__ {   \n#默认的vhost，在没有指明vhost的情况，默认使用这个vhost。\n}\n```\n\n#### 4、启动服务\n在trunk目录下\n```\n ./objs/srs -c conf/srs.conf\n```\n*其他操作相关指令\n```\n停止 ./etc/init.d/srs stop\n重启 ./etc/init.d/srs restart\n```\n\n#### 5、其他注意事项\n*如果是阿里云服务器，需要设置端口映射。\n安全规则->添加安全规则\n![](SRS服务器搭建/rtmp映射.png)\n\n### 三、rtmp推流与播放\n\n#### 1、使用obs推流\nobs是一款免费且开源的用于视频录制以及直播串流的软件。在Windows, Mac以及Linux下均有客户端。obs设置如下:\n![](SRS服务器搭建/obs.png)\n\n#### 2、使用vlc播放\nVLC 是一款自由、开源的跨平台多媒体播放器及框架，可播放大多数多媒体文件，以及 DVD、音频 CD、VCD 及各类流媒体协议。vcl播放链接是obs的URL/流密钥，如下图：\n![](SRS服务器搭建/vlc.png)\n\n#### 3、最终效果如下图\n![](SRS服务器搭建/result_rtmp.png)","slug":"SRS服务器搭建","published":1,"updated":"2019-07-09T08:13:34.955Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyzlbt8v001d0j6641zxftfh","content":"<h3 id=\"一、什么是srs服务器\"><a href=\"#一、什么是srs服务器\" class=\"headerlink\" title=\"一、什么是srs服务器\"></a>一、什么是srs服务器</h3><p>按照项目github上的说法：SRS定位是运营级的互联网直播服务器集群，追求更好的概念完整性和最简单实现的代码。也就是说srs服务器是一个功能强大，容易实现的直播服务器。</p>\n<p>除了srs，直播服务器还有下面这些选择：</p>\n<p>FMS — Adobe公司出品的服务器，价格昂贵，当然是最正宗的，因为RTMP就是Adobe公司的私有协议；</p>\n<p>Wowza — 需要授权费，效率和稳定性都还不错；</p>\n<p>Red5 — 一个开源实现， 效率和稳定性都稍微差些，由于它是Java实现的，所以天生支持跨平台运行；</p>\n<p>Nignx-rtmp-module – -nginx的一个第三方模块，如果你熟悉nginx那是不错的选择，当然它也是免费的，不过功能就没有其他几个丰富了</p>\n<h3 id=\"二、srs服务器的搭建（Ubuntu或Centos）\"><a href=\"#二、srs服务器的搭建（Ubuntu或Centos）\" class=\"headerlink\" title=\"二、srs服务器的搭建（Ubuntu或Centos）\"></a>二、srs服务器的搭建（Ubuntu或Centos）</h3><h4 id=\"1、下载\"><a href=\"#1、下载\" class=\"headerlink\" title=\"1、下载\"></a>1、下载</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/ossrs/srs</span><br></pre></td></tr></table></figure>\n<h4 id=\"2、编译\"><a href=\"#2、编译\" class=\"headerlink\" title=\"2、编译\"></a>2、编译</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd srs/trunk</span><br><span class=\"line\">./configure &amp;&amp; make</span><br></pre></td></tr></table></figure>\n<p>服务器配置相对好点的，可以尝试 make -jn(n为线程数)加快编辑速度</p>\n<h4 id=\"3、编辑conf-rtmp-conf文件，配置内容：\"><a href=\"#3、编辑conf-rtmp-conf文件，配置内容：\" class=\"headerlink\" title=\"3、编辑conf/rtmp.conf文件，配置内容：\"></a>3、编辑conf/rtmp.conf文件，配置内容：</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">listen              1935;</span><br><span class=\"line\">pid                 ./objs/srs.pid;</span><br><span class=\"line\">chunk_size          60000;</span><br><span class=\"line\">ff_log_dir          ./objs;</span><br><span class=\"line\">srs_log_tank        file;  </span><br><span class=\"line\">#配置日志答应到文件，需要和srs_log_level配合使用</span><br><span class=\"line\">srs_log_level       trace;</span><br><span class=\"line\">#制定配置文件的级别，默认级别是trace</span><br><span class=\"line\">srs_log_file        ./objs/srs.log;  </span><br><span class=\"line\">#制定日志文件的位置。</span><br><span class=\"line\">max_connections     1000;</span><br><span class=\"line\">#最大连接数</span><br><span class=\"line\">daemon              on;</span><br><span class=\"line\">#以daemon的方式启动，如果要启动在console，那么需要配置daemon off;并且，需要配置srs_log_tank console;</span><br><span class=\"line\">utc_time            off;</span><br><span class=\"line\">#是否使用utc时间。如果该值为off则使用本地时间，如果开始使用utc时间。</span><br><span class=\"line\">vhost __defaultVhost__ &#123;   </span><br><span class=\"line\">#默认的vhost，在没有指明vhost的情况，默认使用这个vhost。</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"4、启动服务\"><a href=\"#4、启动服务\" class=\"headerlink\" title=\"4、启动服务\"></a>4、启动服务</h4><p>在trunk目录下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./objs/srs -c conf/srs.conf</span><br></pre></td></tr></table></figure></p>\n<p>*其他操作相关指令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">停止 ./etc/init.d/srs stop</span><br><span class=\"line\">重启 ./etc/init.d/srs restart</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"5、其他注意事项\"><a href=\"#5、其他注意事项\" class=\"headerlink\" title=\"5、其他注意事项\"></a>5、其他注意事项</h4><p>*如果是阿里云服务器，需要设置端口映射。<br>安全规则-&gt;添加安全规则<br><img src=\"//www.cyrus.fun/2018/10/23/SRS服务器搭建/rtmp映射.png\" alt=\"\"></p>\n<h3 id=\"三、rtmp推流与播放\"><a href=\"#三、rtmp推流与播放\" class=\"headerlink\" title=\"三、rtmp推流与播放\"></a>三、rtmp推流与播放</h3><h4 id=\"1、使用obs推流\"><a href=\"#1、使用obs推流\" class=\"headerlink\" title=\"1、使用obs推流\"></a>1、使用obs推流</h4><p>obs是一款免费且开源的用于视频录制以及直播串流的软件。在Windows, Mac以及Linux下均有客户端。obs设置如下:<br><img src=\"//www.cyrus.fun/2018/10/23/SRS服务器搭建/obs.png\" alt=\"\"></p>\n<h4 id=\"2、使用vlc播放\"><a href=\"#2、使用vlc播放\" class=\"headerlink\" title=\"2、使用vlc播放\"></a>2、使用vlc播放</h4><p>VLC 是一款自由、开源的跨平台多媒体播放器及框架，可播放大多数多媒体文件，以及 DVD、音频 CD、VCD 及各类流媒体协议。vcl播放链接是obs的URL/流密钥，如下图：<br><img src=\"//www.cyrus.fun/2018/10/23/SRS服务器搭建/vlc.png\" alt=\"\"></p>\n<h4 id=\"3、最终效果如下图\"><a href=\"#3、最终效果如下图\" class=\"headerlink\" title=\"3、最终效果如下图\"></a>3、最终效果如下图</h4><p><img src=\"//www.cyrus.fun/2018/10/23/SRS服务器搭建/result_rtmp.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"一、什么是srs服务器\"><a href=\"#一、什么是srs服务器\" class=\"headerlink\" title=\"一、什么是srs服务器\"></a>一、什么是srs服务器</h3><p>按照项目github上的说法：SRS定位是运营级的互联网直播服务器集群，追求更好的概念完整性和最简单实现的代码。也就是说srs服务器是一个功能强大，容易实现的直播服务器。</p>\n<p>除了srs，直播服务器还有下面这些选择：</p>\n<p>FMS — Adobe公司出品的服务器，价格昂贵，当然是最正宗的，因为RTMP就是Adobe公司的私有协议；</p>\n<p>Wowza — 需要授权费，效率和稳定性都还不错；</p>\n<p>Red5 — 一个开源实现， 效率和稳定性都稍微差些，由于它是Java实现的，所以天生支持跨平台运行；</p>\n<p>Nignx-rtmp-module – -nginx的一个第三方模块，如果你熟悉nginx那是不错的选择，当然它也是免费的，不过功能就没有其他几个丰富了</p>\n<h3 id=\"二、srs服务器的搭建（Ubuntu或Centos）\"><a href=\"#二、srs服务器的搭建（Ubuntu或Centos）\" class=\"headerlink\" title=\"二、srs服务器的搭建（Ubuntu或Centos）\"></a>二、srs服务器的搭建（Ubuntu或Centos）</h3><h4 id=\"1、下载\"><a href=\"#1、下载\" class=\"headerlink\" title=\"1、下载\"></a>1、下载</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/ossrs/srs</span><br></pre></td></tr></table></figure>\n<h4 id=\"2、编译\"><a href=\"#2、编译\" class=\"headerlink\" title=\"2、编译\"></a>2、编译</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd srs/trunk</span><br><span class=\"line\">./configure &amp;&amp; make</span><br></pre></td></tr></table></figure>\n<p>服务器配置相对好点的，可以尝试 make -jn(n为线程数)加快编辑速度</p>\n<h4 id=\"3、编辑conf-rtmp-conf文件，配置内容：\"><a href=\"#3、编辑conf-rtmp-conf文件，配置内容：\" class=\"headerlink\" title=\"3、编辑conf/rtmp.conf文件，配置内容：\"></a>3、编辑conf/rtmp.conf文件，配置内容：</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">listen              1935;</span><br><span class=\"line\">pid                 ./objs/srs.pid;</span><br><span class=\"line\">chunk_size          60000;</span><br><span class=\"line\">ff_log_dir          ./objs;</span><br><span class=\"line\">srs_log_tank        file;  </span><br><span class=\"line\">#配置日志答应到文件，需要和srs_log_level配合使用</span><br><span class=\"line\">srs_log_level       trace;</span><br><span class=\"line\">#制定配置文件的级别，默认级别是trace</span><br><span class=\"line\">srs_log_file        ./objs/srs.log;  </span><br><span class=\"line\">#制定日志文件的位置。</span><br><span class=\"line\">max_connections     1000;</span><br><span class=\"line\">#最大连接数</span><br><span class=\"line\">daemon              on;</span><br><span class=\"line\">#以daemon的方式启动，如果要启动在console，那么需要配置daemon off;并且，需要配置srs_log_tank console;</span><br><span class=\"line\">utc_time            off;</span><br><span class=\"line\">#是否使用utc时间。如果该值为off则使用本地时间，如果开始使用utc时间。</span><br><span class=\"line\">vhost __defaultVhost__ &#123;   </span><br><span class=\"line\">#默认的vhost，在没有指明vhost的情况，默认使用这个vhost。</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"4、启动服务\"><a href=\"#4、启动服务\" class=\"headerlink\" title=\"4、启动服务\"></a>4、启动服务</h4><p>在trunk目录下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./objs/srs -c conf/srs.conf</span><br></pre></td></tr></table></figure></p>\n<p>*其他操作相关指令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">停止 ./etc/init.d/srs stop</span><br><span class=\"line\">重启 ./etc/init.d/srs restart</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"5、其他注意事项\"><a href=\"#5、其他注意事项\" class=\"headerlink\" title=\"5、其他注意事项\"></a>5、其他注意事项</h4><p>*如果是阿里云服务器，需要设置端口映射。<br>安全规则-&gt;添加安全规则<br><img src=\"//www.cyrus.fun/2018/10/23/SRS服务器搭建/rtmp映射.png\" alt=\"\"></p>\n<h3 id=\"三、rtmp推流与播放\"><a href=\"#三、rtmp推流与播放\" class=\"headerlink\" title=\"三、rtmp推流与播放\"></a>三、rtmp推流与播放</h3><h4 id=\"1、使用obs推流\"><a href=\"#1、使用obs推流\" class=\"headerlink\" title=\"1、使用obs推流\"></a>1、使用obs推流</h4><p>obs是一款免费且开源的用于视频录制以及直播串流的软件。在Windows, Mac以及Linux下均有客户端。obs设置如下:<br><img src=\"//www.cyrus.fun/2018/10/23/SRS服务器搭建/obs.png\" alt=\"\"></p>\n<h4 id=\"2、使用vlc播放\"><a href=\"#2、使用vlc播放\" class=\"headerlink\" title=\"2、使用vlc播放\"></a>2、使用vlc播放</h4><p>VLC 是一款自由、开源的跨平台多媒体播放器及框架，可播放大多数多媒体文件，以及 DVD、音频 CD、VCD 及各类流媒体协议。vcl播放链接是obs的URL/流密钥，如下图：<br><img src=\"//www.cyrus.fun/2018/10/23/SRS服务器搭建/vlc.png\" alt=\"\"></p>\n<h4 id=\"3、最终效果如下图\"><a href=\"#3、最终效果如下图\" class=\"headerlink\" title=\"3、最终效果如下图\"></a>3、最终效果如下图</h4><p><img src=\"//www.cyrus.fun/2018/10/23/SRS服务器搭建/result_rtmp.png\" alt=\"\"></p>\n"},{"title":"TCP/IP学习笔记一","author":"Cyrus","date":"2018-10-23T14:55:00.000Z","_content":"\t近期看了挺长一段时间的TCP/IP相关的知识，主要有UNIX网络编程、极客时间上的趣谈网络协议（推荐）和一些相关视频、博客，打算抽空整理一下，主要围绕一个完整的网络请求，从发出到返回数据的过程是怎样的？大致分为以下几个方面：\n    1、TCP/IP协议分为哪几层，各层的作用及相应的协议；\n    2、一个请求怎么找到服务器的；\n    3、三次握手和四次挥手的细节。\n    ","source":"_posts/TCP-IP学习笔记一.md","raw":"title: TCP/IP学习笔记一\nauthor: Cyrus\ntags:\n  - TCP/IP\ncategories:\n  - 网络协议\ndate: 2018-10-23 22:55:00\n---\n\t近期看了挺长一段时间的TCP/IP相关的知识，主要有UNIX网络编程、极客时间上的趣谈网络协议（推荐）和一些相关视频、博客，打算抽空整理一下，主要围绕一个完整的网络请求，从发出到返回数据的过程是怎样的？大致分为以下几个方面：\n    1、TCP/IP协议分为哪几层，各层的作用及相应的协议；\n    2、一个请求怎么找到服务器的；\n    3、三次握手和四次挥手的细节。\n    ","slug":"TCP-IP学习笔记一","published":1,"updated":"2019-07-09T08:13:34.966Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyzlbt8x001h0j66bo2hto2b","content":"<pre><code>近期看了挺长一段时间的TCP/IP相关的知识，主要有UNIX网络编程、极客时间上的趣谈网络协议（推荐）和一些相关视频、博客，打算抽空整理一下，主要围绕一个完整的网络请求，从发出到返回数据的过程是怎样的？大致分为以下几个方面：\n1、TCP/IP协议分为哪几层，各层的作用及相应的协议；\n2、一个请求怎么找到服务器的；\n3、三次握手和四次挥手的细节。\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<pre><code>近期看了挺长一段时间的TCP/IP相关的知识，主要有UNIX网络编程、极客时间上的趣谈网络协议（推荐）和一些相关视频、博客，打算抽空整理一下，主要围绕一个完整的网络请求，从发出到返回数据的过程是怎样的？大致分为以下几个方面：\n1、TCP/IP协议分为哪几层，各层的作用及相应的协议；\n2、一个请求怎么找到服务器的；\n3、三次握手和四次挥手的细节。\n</code></pre>"},{"title":"Xcode编译错误:This application does not support this device's CPU type","author":"Cyrus","date":"2018-10-31T14:24:00.000Z","_content":"最近运行一个旧项目代码，出现错误提示：This application does not support this device's CPU type\n原因：Xcode设置了32-bit architecture，而手机是64-bit的CPU。\n解决方法：修改build Setting->Architectures 为 **architectrues - $(ARCHS_STANDARD)**\n![](buildSetting.png)","source":"_posts/Xcode编译错误-This-application-does-not-support-this-device-s-CPU-type.md","raw":"title: 'Xcode编译错误:This application does not support this device''s CPU type'\nauthor: Cyrus\ntags:\n  - Xcode问题\ncategories:\n  - iOS\ndate: 2018-10-31 22:24:00\n---\n最近运行一个旧项目代码，出现错误提示：This application does not support this device's CPU type\n原因：Xcode设置了32-bit architecture，而手机是64-bit的CPU。\n解决方法：修改build Setting->Architectures 为 **architectrues - $(ARCHS_STANDARD)**\n![](buildSetting.png)","slug":"Xcode编译错误-This-application-does-not-support-this-device-s-CPU-type","published":1,"updated":"2019-07-09T08:13:34.968Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyzlbt8y001j0j665gs0ucd1","content":"<p>最近运行一个旧项目代码，出现错误提示：This application does not support this device’s CPU type<br>原因：Xcode设置了32-bit architecture，而手机是64-bit的CPU。<br>解决方法：修改build Setting-&gt;Architectures 为 <strong>architectrues - $(ARCHS_STANDARD)</strong><br><img src=\"//www.cyrus.fun/2018/10/31/Xcode编译错误-This-application-does-not-support-this-device-s-CPU-type/buildSetting.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>最近运行一个旧项目代码，出现错误提示：This application does not support this device’s CPU type<br>原因：Xcode设置了32-bit architecture，而手机是64-bit的CPU。<br>解决方法：修改build Setting-&gt;Architectures 为 <strong>architectrues - $(ARCHS_STANDARD)</strong><br><img src=\"//www.cyrus.fun/2018/10/31/Xcode编译错误-This-application-does-not-support-this-device-s-CPU-type/buildSetting.png\" alt=\"\"></p>\n"},{"title":"mac 编译FFmpeg iOS库","author":"Cyrus","date":"2018-11-12T14:46:00.000Z","_content":"\n新装了主机，编译FFmpeg的iOS库，记录一下：\n### 一、准备部分\n1、去FFmpeg官网下载所需要的版本的源码：官网源码下载地址（若没下载，编译脚本也可以指定版本自动下载）\n\n2、安装Homebrew：\n```\nruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n```\n\n3、安装yasm：\n```\nbrew install yasm\n```\n\n4、下载：[https://github.com/libav/gas-preprocessor](https://github.com/libav/gas-preprocessor) ，复制gas-preprocessor.pl到/usr/local/bin下，若需要修改文件权限 ：\n```\nchmod 777 /usr/local/bin/gas-preprocessor.pl\n```\n\n### 二、编译ffmpeg\n1、下载脚本：[https://github.com/kewlbear/FFmpeg-iOS-build-script](https://github.com/kewlbear/FFmpeg-iOS-build-script)\n\n2、解压后执行build-ffmpeg.sh即可。如果同级目录ffmpeg文件夹不存在，格式如“ffmpeg-3.4.5”，则自动从官网下载后再编译；\n```\n...\n# directories\nFF_VERSION=\"3.4.5\" //与你下载的版本一致，或者没下载，等脚本自动下载\n...\n```\n\n3、合并成一个.a文件\n```\n./build-ffmpeg.sh lipo\n```\n\n### 出现的问题：\n提示：<font color=ff0000>xcrun -sdk iphoneos clang is unable to create an executable file.</font>\n原因：新安装xcode,命令行工具没有联系起来。\n解决：终端输入：\n```\nsudo xcode-select --switch /Applications/Xcode.app/Contents/Developer/\n```\n\n","source":"_posts/mac-编译FFmpeg-iOS库.md","raw":"title: mac 编译FFmpeg iOS库\nauthor: Cyrus\ntags: []\ncategories:\n  - 音视频\ndate: 2018-11-12 22:46:00\n---\n\n新装了主机，编译FFmpeg的iOS库，记录一下：\n### 一、准备部分\n1、去FFmpeg官网下载所需要的版本的源码：官网源码下载地址（若没下载，编译脚本也可以指定版本自动下载）\n\n2、安装Homebrew：\n```\nruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n```\n\n3、安装yasm：\n```\nbrew install yasm\n```\n\n4、下载：[https://github.com/libav/gas-preprocessor](https://github.com/libav/gas-preprocessor) ，复制gas-preprocessor.pl到/usr/local/bin下，若需要修改文件权限 ：\n```\nchmod 777 /usr/local/bin/gas-preprocessor.pl\n```\n\n### 二、编译ffmpeg\n1、下载脚本：[https://github.com/kewlbear/FFmpeg-iOS-build-script](https://github.com/kewlbear/FFmpeg-iOS-build-script)\n\n2、解压后执行build-ffmpeg.sh即可。如果同级目录ffmpeg文件夹不存在，格式如“ffmpeg-3.4.5”，则自动从官网下载后再编译；\n```\n...\n# directories\nFF_VERSION=\"3.4.5\" //与你下载的版本一致，或者没下载，等脚本自动下载\n...\n```\n\n3、合并成一个.a文件\n```\n./build-ffmpeg.sh lipo\n```\n\n### 出现的问题：\n提示：<font color=ff0000>xcrun -sdk iphoneos clang is unable to create an executable file.</font>\n原因：新安装xcode,命令行工具没有联系起来。\n解决：终端输入：\n```\nsudo xcode-select --switch /Applications/Xcode.app/Contents/Developer/\n```\n\n","slug":"mac-编译FFmpeg-iOS库","published":1,"updated":"2019-07-09T08:13:34.969Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyzlbt8z001l0j6660kmmj3y","content":"<p>新装了主机，编译FFmpeg的iOS库，记录一下：</p>\n<h3 id=\"一、准备部分\"><a href=\"#一、准备部分\" class=\"headerlink\" title=\"一、准备部分\"></a>一、准备部分</h3><p>1、去FFmpeg官网下载所需要的版本的源码：官网源码下载地址（若没下载，编译脚本也可以指定版本自动下载）</p>\n<p>2、安装Homebrew：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure></p>\n<p>3、安装yasm：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install yasm</span><br></pre></td></tr></table></figure></p>\n<p>4、下载：<a href=\"https://github.com/libav/gas-preprocessor\" target=\"_blank\" rel=\"noopener\">https://github.com/libav/gas-preprocessor</a> ，复制gas-preprocessor.pl到/usr/local/bin下，若需要修改文件权限 ：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod 777 /usr/local/bin/gas-preprocessor.pl</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"二、编译ffmpeg\"><a href=\"#二、编译ffmpeg\" class=\"headerlink\" title=\"二、编译ffmpeg\"></a>二、编译ffmpeg</h3><p>1、下载脚本：<a href=\"https://github.com/kewlbear/FFmpeg-iOS-build-script\" target=\"_blank\" rel=\"noopener\">https://github.com/kewlbear/FFmpeg-iOS-build-script</a></p>\n<p>2、解压后执行build-ffmpeg.sh即可。如果同级目录ffmpeg文件夹不存在，格式如“ffmpeg-3.4.5”，则自动从官网下载后再编译；<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"># directories</span><br><span class=\"line\">FF_VERSION=&quot;3.4.5&quot; //与你下载的版本一致，或者没下载，等脚本自动下载</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n<p>3、合并成一个.a文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./build-ffmpeg.sh lipo</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"出现的问题：\"><a href=\"#出现的问题：\" class=\"headerlink\" title=\"出现的问题：\"></a>出现的问题：</h3><p>提示：<font color=\"ff0000\">xcrun -sdk iphoneos clang is unable to create an executable file.</font><br>原因：新安装xcode,命令行工具没有联系起来。<br>解决：终端输入：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo xcode-select --switch /Applications/Xcode.app/Contents/Developer/</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>新装了主机，编译FFmpeg的iOS库，记录一下：</p>\n<h3 id=\"一、准备部分\"><a href=\"#一、准备部分\" class=\"headerlink\" title=\"一、准备部分\"></a>一、准备部分</h3><p>1、去FFmpeg官网下载所需要的版本的源码：官网源码下载地址（若没下载，编译脚本也可以指定版本自动下载）</p>\n<p>2、安装Homebrew：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure></p>\n<p>3、安装yasm：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install yasm</span><br></pre></td></tr></table></figure></p>\n<p>4、下载：<a href=\"https://github.com/libav/gas-preprocessor\" target=\"_blank\" rel=\"noopener\">https://github.com/libav/gas-preprocessor</a> ，复制gas-preprocessor.pl到/usr/local/bin下，若需要修改文件权限 ：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod 777 /usr/local/bin/gas-preprocessor.pl</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"二、编译ffmpeg\"><a href=\"#二、编译ffmpeg\" class=\"headerlink\" title=\"二、编译ffmpeg\"></a>二、编译ffmpeg</h3><p>1、下载脚本：<a href=\"https://github.com/kewlbear/FFmpeg-iOS-build-script\" target=\"_blank\" rel=\"noopener\">https://github.com/kewlbear/FFmpeg-iOS-build-script</a></p>\n<p>2、解压后执行build-ffmpeg.sh即可。如果同级目录ffmpeg文件夹不存在，格式如“ffmpeg-3.4.5”，则自动从官网下载后再编译；<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"># directories</span><br><span class=\"line\">FF_VERSION=&quot;3.4.5&quot; //与你下载的版本一致，或者没下载，等脚本自动下载</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n<p>3、合并成一个.a文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./build-ffmpeg.sh lipo</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"出现的问题：\"><a href=\"#出现的问题：\" class=\"headerlink\" title=\"出现的问题：\"></a>出现的问题：</h3><p>提示：<font color=\"ff0000\">xcrun -sdk iphoneos clang is unable to create an executable file.</font><br>原因：新安装xcode,命令行工具没有联系起来。<br>解决：终端输入：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo xcode-select --switch /Applications/Xcode.app/Contents/Developer/</span><br></pre></td></tr></table></figure></p>\n"},{"title":"ssh反向代理操作内网设备","author":"Cyrus","date":"2019-04-09T13:37:00.000Z","_content":"本文基本参照：https://www.cnblogs.com/kwongtai/p/6903420.html  对原文作者表示感谢\n\n之前上写了个树莓派摄像头采集及传输的程序，有时在外网想调试，出租房没有公网IP，操作不了，所以就上网查了下资料，找到了两种解决方案：\n\n### 一、gotohttp\n首先就是gotohttp，在官网http://www.tohttp.com 下载相应系统的程序，执行得到一个id和控制码，回到官网输入就可以控制了。\n![gotohtt命令行界面效果](gotohttp.png)\n\n优点：不需要vps，操作简单\n缺点：窗口模式下，字体太小，不全屏看着难受\n\n### 二、SSh反向代理\n#### 1、描述一下目前的机器状况，梳理梳理：\n|      机器      | IP            | 用户名  |   备注        |\n| ------------- |:-------------:| :-----:|--------------:|\n| 树莓派         | 10.21.32.106   | gdut728|目标设备，处于内网\n| 阿里云服务器    | 123.123.123.123| root  |外网服务器，相当于桥梁的作用|\n<font color=ff0000>PS：123.123.123.123是瞎起的</font>\n\n#### 2、解决方法\n通俗地说：就是在树莓派上做到阿里云服务器的反向代理；然后在阿里云服务器上做正向的代理实现本地端口的转发\n\n##### 2.1 实现前的准备\n\n每台都要安装ssh的客户端。\n服务器和树莓派都装的ubuntu，都自带ssh。如果是使用其他版本Linux，请手动Google一下咯。\n\n##### 2.2 介绍一下使用到的ssh参数：\n\n反向代理\n~~~\nssh -fCNR\n~~~\n\n正向代理\n~~~\nssh -fCNL\n~~~\n\n~~~\n-f 后台执行ssh指令\n-C 允许压缩数据\n-N 不执行远程指令\n-R 将远程主机(服务器)的某个端口转发到本地端指定机器的指定端口\n-L 将本地机(客户机)的某个端口转发到远端指定机器的指定端口\n-p 指定远程主机的端口\n\n******************区分大小写啊各位亲******************\n~~~\n\n#### 3. 首先在树莓派上面操作：\n建立树莓派到服务器的反向代理，具体指令为\n~~~\nssh -fCNR [B机器IP或省略]:[B机器端口]:[A机器的IP]:[A机器端口] [登陆B机器的用户名@服务器IP]\n~~~\n在这里我使用了B机器的7280端口，以及A机器的22端口，按照上面的指令就是这样子的操作\n~~~\nssh -fCNR 7280:localhost:22 root@123.123.123.123\n~~~\n检验是否已经启动了可以使用ps aux | grep ssh指令来查看：\n![](ssh_r.png)\n\n\n##### 4. 接着在服务器上面操作:\n建立服务器的正向代理，用来做转发，具体指令为\n~~~\nssh -fCNL [A机器IP或省略]:[A机器端口]:[B机器的IP]:[B机器端口] [登陆B机器的用户名@B机器的IP]\n~~~\n\n按照第3那里输入的指令，这里的B机器的端口和上面的B机器的端口是一致的，端口1234的也是服务器的。\n~~~\nssh -fCNL *:1234:localhost:7280 localhost\n~~~\n检验是否已经启动了可以使用ps aux | grep ssh指令来查看：\n![](ssh_l.png)\n<font color=ff0000>在此1234端口为本地转发端口，负责和外网进行通信，并将数据转发的7280这个端口，实现了可以从其他机器访问的功能。同时，*号表示可以接受任何IP的访问。</font>\n\n\n#### 5. 展现奇迹的时候到了\n至此我们都配置好了树莓派和服务器，那么我们就可以从一部外网的电脑登陆到内网里面去啦。鉴于我目前的电脑在内网，而服务器都是外网的，所以可以通过服务器连接到我内网的树莓派，具体指令为：\n~~~\nssh -p1234 gdut728@123.123.123.123\n~~~\n在此-p参数为指定登陆的IP，我们在上面指定了1234端口为转发端口，故用1234端口登陆，然后gdut728是内网树莓派的用户名，123.123.123.123为外网服务器的IP地址。\n![](connect.png)\n\n#### 6.设置免密码登陆到内网\n在内网的树莓派上面执行：\n~~~\nssh-copy-id 外网用户名@外网IP \n~~~\n按照之前我设定的端口，这个指令就是如下\n~~~\nssh-copy-id root@123.123.123.123\n~~~\n![](免密.png)\n那以后这台内网的树莓派ssh登陆我外网的B机器就可以免密码登陆啦~\n检验是否已经可以使用免密码登陆可以使用如下指令来检验：\n~~~\nssh root@123.123.123.123\n~~~\n![](检验免密.png)\n\n#### 7.设备开机自动启动反向代理\n在树莓派的/etc/systemd/system路径下建立一个名为myssh.service的文件，并在其中输入以下内容。\n~~~\n[Unit]\nDescription=My Reverse SSH Service\nConditionPathExists=|/usr/bin\nAfter=network.target\n\n[Service]\nUser=root\nExecStart=/usr/bin/ssh  -NTC -o ServerAliveInterval=60 -o ExitOnForwardFailure=yes -o StrictHostKeyChecking=no -i /home/cyrus/.ssh/id_rsa  -R 7280:localhost:22 root@123.123.123\t//端口及IP改为自己设置的\n\nRestartSec=3\nRestart=always\n\n[Install]\nWantedBy=multi-user.target\n~~~\n\n开机开启服务\n~~~\nsystemctl enable myssh.service\n~~~","source":"_posts/ssh反向代理操作内网设备.md","raw":"title: ssh反向代理操作内网设备\nauthor: Cyrus\ntags: []\ncategories: []\ndate: 2019-04-09 21:37:00\n---\n本文基本参照：https://www.cnblogs.com/kwongtai/p/6903420.html  对原文作者表示感谢\n\n之前上写了个树莓派摄像头采集及传输的程序，有时在外网想调试，出租房没有公网IP，操作不了，所以就上网查了下资料，找到了两种解决方案：\n\n### 一、gotohttp\n首先就是gotohttp，在官网http://www.tohttp.com 下载相应系统的程序，执行得到一个id和控制码，回到官网输入就可以控制了。\n![gotohtt命令行界面效果](gotohttp.png)\n\n优点：不需要vps，操作简单\n缺点：窗口模式下，字体太小，不全屏看着难受\n\n### 二、SSh反向代理\n#### 1、描述一下目前的机器状况，梳理梳理：\n|      机器      | IP            | 用户名  |   备注        |\n| ------------- |:-------------:| :-----:|--------------:|\n| 树莓派         | 10.21.32.106   | gdut728|目标设备，处于内网\n| 阿里云服务器    | 123.123.123.123| root  |外网服务器，相当于桥梁的作用|\n<font color=ff0000>PS：123.123.123.123是瞎起的</font>\n\n#### 2、解决方法\n通俗地说：就是在树莓派上做到阿里云服务器的反向代理；然后在阿里云服务器上做正向的代理实现本地端口的转发\n\n##### 2.1 实现前的准备\n\n每台都要安装ssh的客户端。\n服务器和树莓派都装的ubuntu，都自带ssh。如果是使用其他版本Linux，请手动Google一下咯。\n\n##### 2.2 介绍一下使用到的ssh参数：\n\n反向代理\n~~~\nssh -fCNR\n~~~\n\n正向代理\n~~~\nssh -fCNL\n~~~\n\n~~~\n-f 后台执行ssh指令\n-C 允许压缩数据\n-N 不执行远程指令\n-R 将远程主机(服务器)的某个端口转发到本地端指定机器的指定端口\n-L 将本地机(客户机)的某个端口转发到远端指定机器的指定端口\n-p 指定远程主机的端口\n\n******************区分大小写啊各位亲******************\n~~~\n\n#### 3. 首先在树莓派上面操作：\n建立树莓派到服务器的反向代理，具体指令为\n~~~\nssh -fCNR [B机器IP或省略]:[B机器端口]:[A机器的IP]:[A机器端口] [登陆B机器的用户名@服务器IP]\n~~~\n在这里我使用了B机器的7280端口，以及A机器的22端口，按照上面的指令就是这样子的操作\n~~~\nssh -fCNR 7280:localhost:22 root@123.123.123.123\n~~~\n检验是否已经启动了可以使用ps aux | grep ssh指令来查看：\n![](ssh_r.png)\n\n\n##### 4. 接着在服务器上面操作:\n建立服务器的正向代理，用来做转发，具体指令为\n~~~\nssh -fCNL [A机器IP或省略]:[A机器端口]:[B机器的IP]:[B机器端口] [登陆B机器的用户名@B机器的IP]\n~~~\n\n按照第3那里输入的指令，这里的B机器的端口和上面的B机器的端口是一致的，端口1234的也是服务器的。\n~~~\nssh -fCNL *:1234:localhost:7280 localhost\n~~~\n检验是否已经启动了可以使用ps aux | grep ssh指令来查看：\n![](ssh_l.png)\n<font color=ff0000>在此1234端口为本地转发端口，负责和外网进行通信，并将数据转发的7280这个端口，实现了可以从其他机器访问的功能。同时，*号表示可以接受任何IP的访问。</font>\n\n\n#### 5. 展现奇迹的时候到了\n至此我们都配置好了树莓派和服务器，那么我们就可以从一部外网的电脑登陆到内网里面去啦。鉴于我目前的电脑在内网，而服务器都是外网的，所以可以通过服务器连接到我内网的树莓派，具体指令为：\n~~~\nssh -p1234 gdut728@123.123.123.123\n~~~\n在此-p参数为指定登陆的IP，我们在上面指定了1234端口为转发端口，故用1234端口登陆，然后gdut728是内网树莓派的用户名，123.123.123.123为外网服务器的IP地址。\n![](connect.png)\n\n#### 6.设置免密码登陆到内网\n在内网的树莓派上面执行：\n~~~\nssh-copy-id 外网用户名@外网IP \n~~~\n按照之前我设定的端口，这个指令就是如下\n~~~\nssh-copy-id root@123.123.123.123\n~~~\n![](免密.png)\n那以后这台内网的树莓派ssh登陆我外网的B机器就可以免密码登陆啦~\n检验是否已经可以使用免密码登陆可以使用如下指令来检验：\n~~~\nssh root@123.123.123.123\n~~~\n![](检验免密.png)\n\n#### 7.设备开机自动启动反向代理\n在树莓派的/etc/systemd/system路径下建立一个名为myssh.service的文件，并在其中输入以下内容。\n~~~\n[Unit]\nDescription=My Reverse SSH Service\nConditionPathExists=|/usr/bin\nAfter=network.target\n\n[Service]\nUser=root\nExecStart=/usr/bin/ssh  -NTC -o ServerAliveInterval=60 -o ExitOnForwardFailure=yes -o StrictHostKeyChecking=no -i /home/cyrus/.ssh/id_rsa  -R 7280:localhost:22 root@123.123.123\t//端口及IP改为自己设置的\n\nRestartSec=3\nRestart=always\n\n[Install]\nWantedBy=multi-user.target\n~~~\n\n开机开启服务\n~~~\nsystemctl enable myssh.service\n~~~","slug":"ssh反向代理操作内网设备","published":1,"updated":"2019-07-09T08:13:34.969Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyzlbt91001q0j668xnqy6jh","content":"<p>本文基本参照：<a href=\"https://www.cnblogs.com/kwongtai/p/6903420.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/kwongtai/p/6903420.html</a>  对原文作者表示感谢</p>\n<p>之前上写了个树莓派摄像头采集及传输的程序，有时在外网想调试，出租房没有公网IP，操作不了，所以就上网查了下资料，找到了两种解决方案：</p>\n<h3 id=\"一、gotohttp\"><a href=\"#一、gotohttp\" class=\"headerlink\" title=\"一、gotohttp\"></a>一、gotohttp</h3><p>首先就是gotohttp，在官网<a href=\"http://www.tohttp.com\" target=\"_blank\" rel=\"noopener\">http://www.tohttp.com</a> 下载相应系统的程序，执行得到一个id和控制码，回到官网输入就可以控制了。<br><img src=\"gotohttp.png\" alt=\"gotohtt命令行界面效果\"></p>\n<p>优点：不需要vps，操作简单<br>缺点：窗口模式下，字体太小，不全屏看着难受</p>\n<h3 id=\"二、SSh反向代理\"><a href=\"#二、SSh反向代理\" class=\"headerlink\" title=\"二、SSh反向代理\"></a>二、SSh反向代理</h3><h4 id=\"1、描述一下目前的机器状况，梳理梳理：\"><a href=\"#1、描述一下目前的机器状况，梳理梳理：\" class=\"headerlink\" title=\"1、描述一下目前的机器状况，梳理梳理：\"></a>1、描述一下目前的机器状况，梳理梳理：</h4><table>\n<thead>\n<tr>\n<th>机器</th>\n<th style=\"text-align:center\">IP</th>\n<th style=\"text-align:center\">用户名</th>\n<th style=\"text-align:right\">备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>树莓派</td>\n<td style=\"text-align:center\">10.21.32.106</td>\n<td style=\"text-align:center\">gdut728</td>\n<td style=\"text-align:right\">目标设备，处于内网</td>\n</tr>\n<tr>\n<td>阿里云服务器</td>\n<td style=\"text-align:center\">123.123.123.123</td>\n<td style=\"text-align:center\">root</td>\n<td style=\"text-align:right\">外网服务器，相当于桥梁的作用</td>\n</tr>\n</tbody>\n</table>\n<font color=\"ff0000\">PS：123.123.123.123是瞎起的</font>\n\n<h4 id=\"2、解决方法\"><a href=\"#2、解决方法\" class=\"headerlink\" title=\"2、解决方法\"></a>2、解决方法</h4><p>通俗地说：就是在树莓派上做到阿里云服务器的反向代理；然后在阿里云服务器上做正向的代理实现本地端口的转发</p>\n<h5 id=\"2-1-实现前的准备\"><a href=\"#2-1-实现前的准备\" class=\"headerlink\" title=\"2.1 实现前的准备\"></a>2.1 实现前的准备</h5><p>每台都要安装ssh的客户端。<br>服务器和树莓派都装的ubuntu，都自带ssh。如果是使用其他版本Linux，请手动Google一下咯。</p>\n<h5 id=\"2-2-介绍一下使用到的ssh参数：\"><a href=\"#2-2-介绍一下使用到的ssh参数：\" class=\"headerlink\" title=\"2.2 介绍一下使用到的ssh参数：\"></a>2.2 介绍一下使用到的ssh参数：</h5><p>反向代理<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -fCNR</span><br></pre></td></tr></table></figure></p>\n<p>正向代理<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -fCNL</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-f 后台执行ssh指令</span><br><span class=\"line\">-C 允许压缩数据</span><br><span class=\"line\">-N 不执行远程指令</span><br><span class=\"line\">-R 将远程主机(服务器)的某个端口转发到本地端指定机器的指定端口</span><br><span class=\"line\">-L 将本地机(客户机)的某个端口转发到远端指定机器的指定端口</span><br><span class=\"line\">-p 指定远程主机的端口</span><br><span class=\"line\"></span><br><span class=\"line\">******************区分大小写啊各位亲******************</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-首先在树莓派上面操作：\"><a href=\"#3-首先在树莓派上面操作：\" class=\"headerlink\" title=\"3. 首先在树莓派上面操作：\"></a>3. 首先在树莓派上面操作：</h4><p>建立树莓派到服务器的反向代理，具体指令为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -fCNR [B机器IP或省略]:[B机器端口]:[A机器的IP]:[A机器端口] [登陆B机器的用户名@服务器IP]</span><br></pre></td></tr></table></figure></p>\n<p>在这里我使用了B机器的7280端口，以及A机器的22端口，按照上面的指令就是这样子的操作<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -fCNR 7280:localhost:22 root@123.123.123.123</span><br></pre></td></tr></table></figure></p>\n<p>检验是否已经启动了可以使用ps aux | grep ssh指令来查看：<br><img src=\"//www.cyrus.fun/2019/04/09/ssh反向代理操作内网设备/ssh_r.png\" alt=\"\"></p>\n<h5 id=\"4-接着在服务器上面操作\"><a href=\"#4-接着在服务器上面操作\" class=\"headerlink\" title=\"4. 接着在服务器上面操作:\"></a>4. 接着在服务器上面操作:</h5><p>建立服务器的正向代理，用来做转发，具体指令为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -fCNL [A机器IP或省略]:[A机器端口]:[B机器的IP]:[B机器端口] [登陆B机器的用户名@B机器的IP]</span><br></pre></td></tr></table></figure></p>\n<p>按照第3那里输入的指令，这里的B机器的端口和上面的B机器的端口是一致的，端口1234的也是服务器的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -fCNL *:1234:localhost:7280 localhost</span><br></pre></td></tr></table></figure></p>\n<p>检验是否已经启动了可以使用ps aux | grep ssh指令来查看：<br><img src=\"//www.cyrus.fun/2019/04/09/ssh反向代理操作内网设备/ssh_l.png\" alt=\"\"></p>\n<font color=\"ff0000\">在此1234端口为本地转发端口，负责和外网进行通信，并将数据转发的7280这个端口，实现了可以从其他机器访问的功能。同时，*号表示可以接受任何IP的访问。</font>\n\n\n<h4 id=\"5-展现奇迹的时候到了\"><a href=\"#5-展现奇迹的时候到了\" class=\"headerlink\" title=\"5. 展现奇迹的时候到了\"></a>5. 展现奇迹的时候到了</h4><p>至此我们都配置好了树莓派和服务器，那么我们就可以从一部外网的电脑登陆到内网里面去啦。鉴于我目前的电脑在内网，而服务器都是外网的，所以可以通过服务器连接到我内网的树莓派，具体指令为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -p1234 gdut728@123.123.123.123</span><br></pre></td></tr></table></figure></p>\n<p>在此-p参数为指定登陆的IP，我们在上面指定了1234端口为转发端口，故用1234端口登陆，然后gdut728是内网树莓派的用户名，123.123.123.123为外网服务器的IP地址。<br><img src=\"//www.cyrus.fun/2019/04/09/ssh反向代理操作内网设备/connect.png\" alt=\"\"></p>\n<h4 id=\"6-设置免密码登陆到内网\"><a href=\"#6-设置免密码登陆到内网\" class=\"headerlink\" title=\"6.设置免密码登陆到内网\"></a>6.设置免密码登陆到内网</h4><p>在内网的树莓派上面执行：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-copy-id 外网用户名@外网IP</span><br></pre></td></tr></table></figure></p>\n<p>按照之前我设定的端口，这个指令就是如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-copy-id root@123.123.123.123</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"//www.cyrus.fun/2019/04/09/ssh反向代理操作内网设备/免密.png\" alt=\"\"><br>那以后这台内网的树莓派ssh登陆我外网的B机器就可以免密码登陆啦~<br>检验是否已经可以使用免密码登陆可以使用如下指令来检验：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh root@123.123.123.123</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"//www.cyrus.fun/2019/04/09/ssh反向代理操作内网设备/检验免密.png\" alt=\"\"></p>\n<h4 id=\"7-设备开机自动启动反向代理\"><a href=\"#7-设备开机自动启动反向代理\" class=\"headerlink\" title=\"7.设备开机自动启动反向代理\"></a>7.设备开机自动启动反向代理</h4><p>在树莓派的/etc/systemd/system路径下建立一个名为myssh.service的文件，并在其中输入以下内容。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Unit]</span><br><span class=\"line\">Description=My Reverse SSH Service</span><br><span class=\"line\">ConditionPathExists=|/usr/bin</span><br><span class=\"line\">After=network.target</span><br><span class=\"line\"></span><br><span class=\"line\">[Service]</span><br><span class=\"line\">User=root</span><br><span class=\"line\">ExecStart=/usr/bin/ssh  -NTC -o ServerAliveInterval=60 -o ExitOnForwardFailure=yes -o StrictHostKeyChecking=no -i /home/cyrus/.ssh/id_rsa  -R 7280:localhost:22 root@123.123.123\t//端口及IP改为自己设置的</span><br><span class=\"line\"></span><br><span class=\"line\">RestartSec=3</span><br><span class=\"line\">Restart=always</span><br><span class=\"line\"></span><br><span class=\"line\">[Install]</span><br><span class=\"line\">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure></p>\n<p>开机开启服务<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl enable myssh.service</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文基本参照：<a href=\"https://www.cnblogs.com/kwongtai/p/6903420.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/kwongtai/p/6903420.html</a>  对原文作者表示感谢</p>\n<p>之前上写了个树莓派摄像头采集及传输的程序，有时在外网想调试，出租房没有公网IP，操作不了，所以就上网查了下资料，找到了两种解决方案：</p>\n<h3 id=\"一、gotohttp\"><a href=\"#一、gotohttp\" class=\"headerlink\" title=\"一、gotohttp\"></a>一、gotohttp</h3><p>首先就是gotohttp，在官网<a href=\"http://www.tohttp.com\" target=\"_blank\" rel=\"noopener\">http://www.tohttp.com</a> 下载相应系统的程序，执行得到一个id和控制码，回到官网输入就可以控制了。<br><img src=\"gotohttp.png\" alt=\"gotohtt命令行界面效果\"></p>\n<p>优点：不需要vps，操作简单<br>缺点：窗口模式下，字体太小，不全屏看着难受</p>\n<h3 id=\"二、SSh反向代理\"><a href=\"#二、SSh反向代理\" class=\"headerlink\" title=\"二、SSh反向代理\"></a>二、SSh反向代理</h3><h4 id=\"1、描述一下目前的机器状况，梳理梳理：\"><a href=\"#1、描述一下目前的机器状况，梳理梳理：\" class=\"headerlink\" title=\"1、描述一下目前的机器状况，梳理梳理：\"></a>1、描述一下目前的机器状况，梳理梳理：</h4><table>\n<thead>\n<tr>\n<th>机器</th>\n<th style=\"text-align:center\">IP</th>\n<th style=\"text-align:center\">用户名</th>\n<th style=\"text-align:right\">备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>树莓派</td>\n<td style=\"text-align:center\">10.21.32.106</td>\n<td style=\"text-align:center\">gdut728</td>\n<td style=\"text-align:right\">目标设备，处于内网</td>\n</tr>\n<tr>\n<td>阿里云服务器</td>\n<td style=\"text-align:center\">123.123.123.123</td>\n<td style=\"text-align:center\">root</td>\n<td style=\"text-align:right\">外网服务器，相当于桥梁的作用</td>\n</tr>\n</tbody>\n</table>\n<font color=\"ff0000\">PS：123.123.123.123是瞎起的</font>\n\n<h4 id=\"2、解决方法\"><a href=\"#2、解决方法\" class=\"headerlink\" title=\"2、解决方法\"></a>2、解决方法</h4><p>通俗地说：就是在树莓派上做到阿里云服务器的反向代理；然后在阿里云服务器上做正向的代理实现本地端口的转发</p>\n<h5 id=\"2-1-实现前的准备\"><a href=\"#2-1-实现前的准备\" class=\"headerlink\" title=\"2.1 实现前的准备\"></a>2.1 实现前的准备</h5><p>每台都要安装ssh的客户端。<br>服务器和树莓派都装的ubuntu，都自带ssh。如果是使用其他版本Linux，请手动Google一下咯。</p>\n<h5 id=\"2-2-介绍一下使用到的ssh参数：\"><a href=\"#2-2-介绍一下使用到的ssh参数：\" class=\"headerlink\" title=\"2.2 介绍一下使用到的ssh参数：\"></a>2.2 介绍一下使用到的ssh参数：</h5><p>反向代理<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -fCNR</span><br></pre></td></tr></table></figure></p>\n<p>正向代理<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -fCNL</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-f 后台执行ssh指令</span><br><span class=\"line\">-C 允许压缩数据</span><br><span class=\"line\">-N 不执行远程指令</span><br><span class=\"line\">-R 将远程主机(服务器)的某个端口转发到本地端指定机器的指定端口</span><br><span class=\"line\">-L 将本地机(客户机)的某个端口转发到远端指定机器的指定端口</span><br><span class=\"line\">-p 指定远程主机的端口</span><br><span class=\"line\"></span><br><span class=\"line\">******************区分大小写啊各位亲******************</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-首先在树莓派上面操作：\"><a href=\"#3-首先在树莓派上面操作：\" class=\"headerlink\" title=\"3. 首先在树莓派上面操作：\"></a>3. 首先在树莓派上面操作：</h4><p>建立树莓派到服务器的反向代理，具体指令为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -fCNR [B机器IP或省略]:[B机器端口]:[A机器的IP]:[A机器端口] [登陆B机器的用户名@服务器IP]</span><br></pre></td></tr></table></figure></p>\n<p>在这里我使用了B机器的7280端口，以及A机器的22端口，按照上面的指令就是这样子的操作<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -fCNR 7280:localhost:22 root@123.123.123.123</span><br></pre></td></tr></table></figure></p>\n<p>检验是否已经启动了可以使用ps aux | grep ssh指令来查看：<br><img src=\"//www.cyrus.fun/2019/04/09/ssh反向代理操作内网设备/ssh_r.png\" alt=\"\"></p>\n<h5 id=\"4-接着在服务器上面操作\"><a href=\"#4-接着在服务器上面操作\" class=\"headerlink\" title=\"4. 接着在服务器上面操作:\"></a>4. 接着在服务器上面操作:</h5><p>建立服务器的正向代理，用来做转发，具体指令为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -fCNL [A机器IP或省略]:[A机器端口]:[B机器的IP]:[B机器端口] [登陆B机器的用户名@B机器的IP]</span><br></pre></td></tr></table></figure></p>\n<p>按照第3那里输入的指令，这里的B机器的端口和上面的B机器的端口是一致的，端口1234的也是服务器的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -fCNL *:1234:localhost:7280 localhost</span><br></pre></td></tr></table></figure></p>\n<p>检验是否已经启动了可以使用ps aux | grep ssh指令来查看：<br><img src=\"//www.cyrus.fun/2019/04/09/ssh反向代理操作内网设备/ssh_l.png\" alt=\"\"></p>\n<font color=\"ff0000\">在此1234端口为本地转发端口，负责和外网进行通信，并将数据转发的7280这个端口，实现了可以从其他机器访问的功能。同时，*号表示可以接受任何IP的访问。</font>\n\n\n<h4 id=\"5-展现奇迹的时候到了\"><a href=\"#5-展现奇迹的时候到了\" class=\"headerlink\" title=\"5. 展现奇迹的时候到了\"></a>5. 展现奇迹的时候到了</h4><p>至此我们都配置好了树莓派和服务器，那么我们就可以从一部外网的电脑登陆到内网里面去啦。鉴于我目前的电脑在内网，而服务器都是外网的，所以可以通过服务器连接到我内网的树莓派，具体指令为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -p1234 gdut728@123.123.123.123</span><br></pre></td></tr></table></figure></p>\n<p>在此-p参数为指定登陆的IP，我们在上面指定了1234端口为转发端口，故用1234端口登陆，然后gdut728是内网树莓派的用户名，123.123.123.123为外网服务器的IP地址。<br><img src=\"//www.cyrus.fun/2019/04/09/ssh反向代理操作内网设备/connect.png\" alt=\"\"></p>\n<h4 id=\"6-设置免密码登陆到内网\"><a href=\"#6-设置免密码登陆到内网\" class=\"headerlink\" title=\"6.设置免密码登陆到内网\"></a>6.设置免密码登陆到内网</h4><p>在内网的树莓派上面执行：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-copy-id 外网用户名@外网IP</span><br></pre></td></tr></table></figure></p>\n<p>按照之前我设定的端口，这个指令就是如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-copy-id root@123.123.123.123</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"//www.cyrus.fun/2019/04/09/ssh反向代理操作内网设备/免密.png\" alt=\"\"><br>那以后这台内网的树莓派ssh登陆我外网的B机器就可以免密码登陆啦~<br>检验是否已经可以使用免密码登陆可以使用如下指令来检验：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh root@123.123.123.123</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"//www.cyrus.fun/2019/04/09/ssh反向代理操作内网设备/检验免密.png\" alt=\"\"></p>\n<h4 id=\"7-设备开机自动启动反向代理\"><a href=\"#7-设备开机自动启动反向代理\" class=\"headerlink\" title=\"7.设备开机自动启动反向代理\"></a>7.设备开机自动启动反向代理</h4><p>在树莓派的/etc/systemd/system路径下建立一个名为myssh.service的文件，并在其中输入以下内容。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Unit]</span><br><span class=\"line\">Description=My Reverse SSH Service</span><br><span class=\"line\">ConditionPathExists=|/usr/bin</span><br><span class=\"line\">After=network.target</span><br><span class=\"line\"></span><br><span class=\"line\">[Service]</span><br><span class=\"line\">User=root</span><br><span class=\"line\">ExecStart=/usr/bin/ssh  -NTC -o ServerAliveInterval=60 -o ExitOnForwardFailure=yes -o StrictHostKeyChecking=no -i /home/cyrus/.ssh/id_rsa  -R 7280:localhost:22 root@123.123.123\t//端口及IP改为自己设置的</span><br><span class=\"line\"></span><br><span class=\"line\">RestartSec=3</span><br><span class=\"line\">Restart=always</span><br><span class=\"line\"></span><br><span class=\"line\">[Install]</span><br><span class=\"line\">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure></p>\n<p>开机开启服务<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl enable myssh.service</span><br></pre></td></tr></table></figure></p>\n"},{"title":"主机+win10+黑苹果+ubuntu","author":"Cyrus","date":"2018-11-08T13:53:00.000Z","_content":"双11还没到，就剁手配了台主机，z390+8700k+1080Ti。折腾了好几天，才把win10、黑苹果、ubuntu都给装上去了。先来个开机图：\n![](主机.png)\n\n### 装机\n机箱是安钛克P110搭配ATX主板，本以为跟之前看到的主机差不多大小，结果到手一看，整整大了好几圈，囧。。。第一次组装，从8多点装到半夜2、3点才装好，装上win10,一次点亮没毛病。这里啥专业几个点：\n1、大霜塔散热真心大，也真心不好装。。。\n2、主板固定后，CPU电源、主板电源线真心难插，建议插上后再固定主板，然后再插到电源上。。。\n3、机箱+CPU散热共6个风扇，一开机呼呼的，有点吵。。。\n\n### 装系统\n一个英特尔P760 500G的m.2，速度快，用来装黑苹果（主用系统）\n一个三星860 evo 500的sata，用来装win10和ubuntu\n一个希捷1T的机械硬盘，用来放视频资料什么的。\n\n#### win10\nwin10的安装没什么好说的，装就对了。装完之后发现上不了网，只能拿出主板附带的光盘，再找出以前笔记本换固态拆下来的古董级光驱（都8102年了，就不能给个U盘？显卡驱动也是），装了驱动，立马显示可以上网了。（因为板载网卡I219V比较新？后面Ubuntu也遇到了装完系统上不了网的情况，汗。。。）再放显卡附带光盘安装，毫无悬念，win10收工。\n\n#### 黑苹果\n黑苹果装的是10.13.6，10.14刚出来，bug多，而且没有显卡驱动。\n如果舍得花点钱，建议20块注册下黑苹果乐园，镜像驱动相关应用找起来容易点。有钱又懒得折腾的，x宝百来块，不到两个钟解决问题。\n生命在于折腾，说说折腾过程中遇到的几个问题：\n\n1、最好用usb2.0的U盘安装，别问我为什么？想着3.0的U盘速度快，结果跑码10s卡死，前前后后下了3、4个镜像，20来个G，呵呵。。。如果只有3.0U盘，插到主板2.0的USB口也可以，貌似。。。\n\n2、关于用MultiBeast安装驱动的问题，我网卡、USB都用这个装的，没问题，但是，声卡建议还是用其他方法，一开始不懂，一直没声音，直接用这个装了万能声卡、alc和Realtek 1220,直接进不了系统，gg…clover安全模式下删掉驱动也没解决，再次重装。\n\n3、识别不了USB3.0。可以参考下 https://hackintosher.com/guides/hackintosh-high-sierra-10-13-6-update-guide/\n\n4、进入win10、ubuntu之类的非OS X系统，关机时，务必先“关机”，不要选“重启”，有些驱动会掉，像万能声卡就掉了。。。\n\n#### Ubuntu16.04\nubuntu安装也没太多说的，win10盘分了200多G出来，照下面分区：\n\n1.大小：500MB；\n   新分区类型：主分区\n   新分区位置：空间起始位置\n   用于：EFI\n   \n2.大小：500MB；\n   新分区类型：主分区\n   新分区位置：空间起始位置\n   用于：Ext4\n   挂载点：/Boot\n   \n3.大小：18000MB；\n   新分区类型：主分区\n   新分区位置：空间起始位置\n   用于：交换空间（swap area）（=物理内存*2,8GB也够用）\n   \n4.大小：***MB；\n   新分区类型：主分区\n   新分区位置：空间起始位置\n   用于：Ext4\n   挂载点：/\n\n问题是安装好后EFI分区似乎没用到。开机，渣画面+没网络，需要网卡驱动和显卡驱动。\n\n网卡驱动：http://www.mamicode.com/info-detail-1710888.html\n\n显卡驱动：https://blog.csdn.net/weixin_40294256/article/details/79157838\n\n### 结论\n花了几天时间，自己组了台电脑，装了三个系统并成功运行，还是挺有成就感的。\n\n1、黑苹果声卡驱动为万能声卡，美中不足，但是平时也就戴耳机看看教学视频之类的，感觉还行，不强求了，以后有兴致了再研究研究重新整；\n\n2、ubuntu的引导没有添加到clover里面，需要切换开机启动项，比较麻烦，后面有时间再看；\n\n3、装了三个系统，隔了很多分区，有点乱。。。","source":"_posts/主机-三系统.md","raw":"title: 主机+win10+黑苹果+ubuntu\nauthor: Cyrus\ntags: []\ncategories:\n  - 杂记\ndate: 2018-11-08 21:53:00\n---\n双11还没到，就剁手配了台主机，z390+8700k+1080Ti。折腾了好几天，才把win10、黑苹果、ubuntu都给装上去了。先来个开机图：\n![](主机.png)\n\n### 装机\n机箱是安钛克P110搭配ATX主板，本以为跟之前看到的主机差不多大小，结果到手一看，整整大了好几圈，囧。。。第一次组装，从8多点装到半夜2、3点才装好，装上win10,一次点亮没毛病。这里啥专业几个点：\n1、大霜塔散热真心大，也真心不好装。。。\n2、主板固定后，CPU电源、主板电源线真心难插，建议插上后再固定主板，然后再插到电源上。。。\n3、机箱+CPU散热共6个风扇，一开机呼呼的，有点吵。。。\n\n### 装系统\n一个英特尔P760 500G的m.2，速度快，用来装黑苹果（主用系统）\n一个三星860 evo 500的sata，用来装win10和ubuntu\n一个希捷1T的机械硬盘，用来放视频资料什么的。\n\n#### win10\nwin10的安装没什么好说的，装就对了。装完之后发现上不了网，只能拿出主板附带的光盘，再找出以前笔记本换固态拆下来的古董级光驱（都8102年了，就不能给个U盘？显卡驱动也是），装了驱动，立马显示可以上网了。（因为板载网卡I219V比较新？后面Ubuntu也遇到了装完系统上不了网的情况，汗。。。）再放显卡附带光盘安装，毫无悬念，win10收工。\n\n#### 黑苹果\n黑苹果装的是10.13.6，10.14刚出来，bug多，而且没有显卡驱动。\n如果舍得花点钱，建议20块注册下黑苹果乐园，镜像驱动相关应用找起来容易点。有钱又懒得折腾的，x宝百来块，不到两个钟解决问题。\n生命在于折腾，说说折腾过程中遇到的几个问题：\n\n1、最好用usb2.0的U盘安装，别问我为什么？想着3.0的U盘速度快，结果跑码10s卡死，前前后后下了3、4个镜像，20来个G，呵呵。。。如果只有3.0U盘，插到主板2.0的USB口也可以，貌似。。。\n\n2、关于用MultiBeast安装驱动的问题，我网卡、USB都用这个装的，没问题，但是，声卡建议还是用其他方法，一开始不懂，一直没声音，直接用这个装了万能声卡、alc和Realtek 1220,直接进不了系统，gg…clover安全模式下删掉驱动也没解决，再次重装。\n\n3、识别不了USB3.0。可以参考下 https://hackintosher.com/guides/hackintosh-high-sierra-10-13-6-update-guide/\n\n4、进入win10、ubuntu之类的非OS X系统，关机时，务必先“关机”，不要选“重启”，有些驱动会掉，像万能声卡就掉了。。。\n\n#### Ubuntu16.04\nubuntu安装也没太多说的，win10盘分了200多G出来，照下面分区：\n\n1.大小：500MB；\n   新分区类型：主分区\n   新分区位置：空间起始位置\n   用于：EFI\n   \n2.大小：500MB；\n   新分区类型：主分区\n   新分区位置：空间起始位置\n   用于：Ext4\n   挂载点：/Boot\n   \n3.大小：18000MB；\n   新分区类型：主分区\n   新分区位置：空间起始位置\n   用于：交换空间（swap area）（=物理内存*2,8GB也够用）\n   \n4.大小：***MB；\n   新分区类型：主分区\n   新分区位置：空间起始位置\n   用于：Ext4\n   挂载点：/\n\n问题是安装好后EFI分区似乎没用到。开机，渣画面+没网络，需要网卡驱动和显卡驱动。\n\n网卡驱动：http://www.mamicode.com/info-detail-1710888.html\n\n显卡驱动：https://blog.csdn.net/weixin_40294256/article/details/79157838\n\n### 结论\n花了几天时间，自己组了台电脑，装了三个系统并成功运行，还是挺有成就感的。\n\n1、黑苹果声卡驱动为万能声卡，美中不足，但是平时也就戴耳机看看教学视频之类的，感觉还行，不强求了，以后有兴致了再研究研究重新整；\n\n2、ubuntu的引导没有添加到clover里面，需要切换开机启动项，比较麻烦，后面有时间再看；\n\n3、装了三个系统，隔了很多分区，有点乱。。。","slug":"主机-三系统","published":1,"updated":"2019-07-09T08:13:34.973Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyzlbt92001s0j66rnm3o7od","content":"<p>双11还没到，就剁手配了台主机，z390+8700k+1080Ti。折腾了好几天，才把win10、黑苹果、ubuntu都给装上去了。先来个开机图：<br><img src=\"//www.cyrus.fun/2018/11/08/主机-三系统/主机.png\" alt=\"\"></p>\n<h3 id=\"装机\"><a href=\"#装机\" class=\"headerlink\" title=\"装机\"></a>装机</h3><p>机箱是安钛克P110搭配ATX主板，本以为跟之前看到的主机差不多大小，结果到手一看，整整大了好几圈，囧。。。第一次组装，从8多点装到半夜2、3点才装好，装上win10,一次点亮没毛病。这里啥专业几个点：<br>1、大霜塔散热真心大，也真心不好装。。。<br>2、主板固定后，CPU电源、主板电源线真心难插，建议插上后再固定主板，然后再插到电源上。。。<br>3、机箱+CPU散热共6个风扇，一开机呼呼的，有点吵。。。</p>\n<h3 id=\"装系统\"><a href=\"#装系统\" class=\"headerlink\" title=\"装系统\"></a>装系统</h3><p>一个英特尔P760 500G的m.2，速度快，用来装黑苹果（主用系统）<br>一个三星860 evo 500的sata，用来装win10和ubuntu<br>一个希捷1T的机械硬盘，用来放视频资料什么的。</p>\n<h4 id=\"win10\"><a href=\"#win10\" class=\"headerlink\" title=\"win10\"></a>win10</h4><p>win10的安装没什么好说的，装就对了。装完之后发现上不了网，只能拿出主板附带的光盘，再找出以前笔记本换固态拆下来的古董级光驱（都8102年了，就不能给个U盘？显卡驱动也是），装了驱动，立马显示可以上网了。（因为板载网卡I219V比较新？后面Ubuntu也遇到了装完系统上不了网的情况，汗。。。）再放显卡附带光盘安装，毫无悬念，win10收工。</p>\n<h4 id=\"黑苹果\"><a href=\"#黑苹果\" class=\"headerlink\" title=\"黑苹果\"></a>黑苹果</h4><p>黑苹果装的是10.13.6，10.14刚出来，bug多，而且没有显卡驱动。<br>如果舍得花点钱，建议20块注册下黑苹果乐园，镜像驱动相关应用找起来容易点。有钱又懒得折腾的，x宝百来块，不到两个钟解决问题。<br>生命在于折腾，说说折腾过程中遇到的几个问题：</p>\n<p>1、最好用usb2.0的U盘安装，别问我为什么？想着3.0的U盘速度快，结果跑码10s卡死，前前后后下了3、4个镜像，20来个G，呵呵。。。如果只有3.0U盘，插到主板2.0的USB口也可以，貌似。。。</p>\n<p>2、关于用MultiBeast安装驱动的问题，我网卡、USB都用这个装的，没问题，但是，声卡建议还是用其他方法，一开始不懂，一直没声音，直接用这个装了万能声卡、alc和Realtek 1220,直接进不了系统，gg…clover安全模式下删掉驱动也没解决，再次重装。</p>\n<p>3、识别不了USB3.0。可以参考下 <a href=\"https://hackintosher.com/guides/hackintosh-high-sierra-10-13-6-update-guide/\" target=\"_blank\" rel=\"noopener\">https://hackintosher.com/guides/hackintosh-high-sierra-10-13-6-update-guide/</a></p>\n<p>4、进入win10、ubuntu之类的非OS X系统，关机时，务必先“关机”，不要选“重启”，有些驱动会掉，像万能声卡就掉了。。。</p>\n<h4 id=\"Ubuntu16-04\"><a href=\"#Ubuntu16-04\" class=\"headerlink\" title=\"Ubuntu16.04\"></a>Ubuntu16.04</h4><p>ubuntu安装也没太多说的，win10盘分了200多G出来，照下面分区：</p>\n<p>1.大小：500MB；<br>   新分区类型：主分区<br>   新分区位置：空间起始位置<br>   用于：EFI</p>\n<p>2.大小：500MB；<br>   新分区类型：主分区<br>   新分区位置：空间起始位置<br>   用于：Ext4<br>   挂载点：/Boot</p>\n<p>3.大小：18000MB；<br>   新分区类型：主分区<br>   新分区位置：空间起始位置<br>   用于：交换空间（swap area）（=物理内存*2,8GB也够用）</p>\n<p>4.大小：***MB；<br>   新分区类型：主分区<br>   新分区位置：空间起始位置<br>   用于：Ext4<br>   挂载点：/</p>\n<p>问题是安装好后EFI分区似乎没用到。开机，渣画面+没网络，需要网卡驱动和显卡驱动。</p>\n<p>网卡驱动：<a href=\"http://www.mamicode.com/info-detail-1710888.html\" target=\"_blank\" rel=\"noopener\">http://www.mamicode.com/info-detail-1710888.html</a></p>\n<p>显卡驱动：<a href=\"https://blog.csdn.net/weixin_40294256/article/details/79157838\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/weixin_40294256/article/details/79157838</a></p>\n<h3 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h3><p>花了几天时间，自己组了台电脑，装了三个系统并成功运行，还是挺有成就感的。</p>\n<p>1、黑苹果声卡驱动为万能声卡，美中不足，但是平时也就戴耳机看看教学视频之类的，感觉还行，不强求了，以后有兴致了再研究研究重新整；</p>\n<p>2、ubuntu的引导没有添加到clover里面，需要切换开机启动项，比较麻烦，后面有时间再看；</p>\n<p>3、装了三个系统，隔了很多分区，有点乱。。。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>双11还没到，就剁手配了台主机，z390+8700k+1080Ti。折腾了好几天，才把win10、黑苹果、ubuntu都给装上去了。先来个开机图：<br><img src=\"//www.cyrus.fun/2018/11/08/主机-三系统/主机.png\" alt=\"\"></p>\n<h3 id=\"装机\"><a href=\"#装机\" class=\"headerlink\" title=\"装机\"></a>装机</h3><p>机箱是安钛克P110搭配ATX主板，本以为跟之前看到的主机差不多大小，结果到手一看，整整大了好几圈，囧。。。第一次组装，从8多点装到半夜2、3点才装好，装上win10,一次点亮没毛病。这里啥专业几个点：<br>1、大霜塔散热真心大，也真心不好装。。。<br>2、主板固定后，CPU电源、主板电源线真心难插，建议插上后再固定主板，然后再插到电源上。。。<br>3、机箱+CPU散热共6个风扇，一开机呼呼的，有点吵。。。</p>\n<h3 id=\"装系统\"><a href=\"#装系统\" class=\"headerlink\" title=\"装系统\"></a>装系统</h3><p>一个英特尔P760 500G的m.2，速度快，用来装黑苹果（主用系统）<br>一个三星860 evo 500的sata，用来装win10和ubuntu<br>一个希捷1T的机械硬盘，用来放视频资料什么的。</p>\n<h4 id=\"win10\"><a href=\"#win10\" class=\"headerlink\" title=\"win10\"></a>win10</h4><p>win10的安装没什么好说的，装就对了。装完之后发现上不了网，只能拿出主板附带的光盘，再找出以前笔记本换固态拆下来的古董级光驱（都8102年了，就不能给个U盘？显卡驱动也是），装了驱动，立马显示可以上网了。（因为板载网卡I219V比较新？后面Ubuntu也遇到了装完系统上不了网的情况，汗。。。）再放显卡附带光盘安装，毫无悬念，win10收工。</p>\n<h4 id=\"黑苹果\"><a href=\"#黑苹果\" class=\"headerlink\" title=\"黑苹果\"></a>黑苹果</h4><p>黑苹果装的是10.13.6，10.14刚出来，bug多，而且没有显卡驱动。<br>如果舍得花点钱，建议20块注册下黑苹果乐园，镜像驱动相关应用找起来容易点。有钱又懒得折腾的，x宝百来块，不到两个钟解决问题。<br>生命在于折腾，说说折腾过程中遇到的几个问题：</p>\n<p>1、最好用usb2.0的U盘安装，别问我为什么？想着3.0的U盘速度快，结果跑码10s卡死，前前后后下了3、4个镜像，20来个G，呵呵。。。如果只有3.0U盘，插到主板2.0的USB口也可以，貌似。。。</p>\n<p>2、关于用MultiBeast安装驱动的问题，我网卡、USB都用这个装的，没问题，但是，声卡建议还是用其他方法，一开始不懂，一直没声音，直接用这个装了万能声卡、alc和Realtek 1220,直接进不了系统，gg…clover安全模式下删掉驱动也没解决，再次重装。</p>\n<p>3、识别不了USB3.0。可以参考下 <a href=\"https://hackintosher.com/guides/hackintosh-high-sierra-10-13-6-update-guide/\" target=\"_blank\" rel=\"noopener\">https://hackintosher.com/guides/hackintosh-high-sierra-10-13-6-update-guide/</a></p>\n<p>4、进入win10、ubuntu之类的非OS X系统，关机时，务必先“关机”，不要选“重启”，有些驱动会掉，像万能声卡就掉了。。。</p>\n<h4 id=\"Ubuntu16-04\"><a href=\"#Ubuntu16-04\" class=\"headerlink\" title=\"Ubuntu16.04\"></a>Ubuntu16.04</h4><p>ubuntu安装也没太多说的，win10盘分了200多G出来，照下面分区：</p>\n<p>1.大小：500MB；<br>   新分区类型：主分区<br>   新分区位置：空间起始位置<br>   用于：EFI</p>\n<p>2.大小：500MB；<br>   新分区类型：主分区<br>   新分区位置：空间起始位置<br>   用于：Ext4<br>   挂载点：/Boot</p>\n<p>3.大小：18000MB；<br>   新分区类型：主分区<br>   新分区位置：空间起始位置<br>   用于：交换空间（swap area）（=物理内存*2,8GB也够用）</p>\n<p>4.大小：***MB；<br>   新分区类型：主分区<br>   新分区位置：空间起始位置<br>   用于：Ext4<br>   挂载点：/</p>\n<p>问题是安装好后EFI分区似乎没用到。开机，渣画面+没网络，需要网卡驱动和显卡驱动。</p>\n<p>网卡驱动：<a href=\"http://www.mamicode.com/info-detail-1710888.html\" target=\"_blank\" rel=\"noopener\">http://www.mamicode.com/info-detail-1710888.html</a></p>\n<p>显卡驱动：<a href=\"https://blog.csdn.net/weixin_40294256/article/details/79157838\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/weixin_40294256/article/details/79157838</a></p>\n<h3 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h3><p>花了几天时间，自己组了台电脑，装了三个系统并成功运行，还是挺有成就感的。</p>\n<p>1、黑苹果声卡驱动为万能声卡，美中不足，但是平时也就戴耳机看看教学视频之类的，感觉还行，不强求了，以后有兴致了再研究研究重新整；</p>\n<p>2、ubuntu的引导没有添加到clover里面，需要切换开机启动项，比较麻烦，后面有时间再看；</p>\n<p>3、装了三个系统，隔了很多分区，有点乱。。。</p>\n"},{"title":"冒泡排序","author":"Cyrus","date":"2018-10-23T15:16:00.000Z","_content":"冒泡排序，百度百科是这么介绍的：\n\n冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法。\n它重复地走访过要排序的元素列，依次比较两个相邻的元素，如果他们的顺序（如从大到小、首字母从A到Z）错误就把他们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素已经排序完成。\n这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列），就如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样，故名“冒泡排序”。\n“冒泡” 这个词总让我感觉有点奇怪，因为根据这个排序方法，最先确定下来的数是数组尾端的数，根据循环由后往前一个一个的确定位置，这不是 <font color=#A52A2A size=4 >“沉底”</font>吗？\n\n——以数组尾端作为水面的吧，好吧，没毛病~~\n\n图示如下：\n![](冒泡.png)\n\nC代码算法：\n```\n#include <stdio.h>\n#define SIZE 8\nvoid bubble_sort(int a[], int n);\nvoid bubble_sort(int a[], int n)\n{\n    int i, j, temp;\n    for (j = 0; j < n - 1; j++)\n        for (i = 0; i < n - 1 - j; i++)\n        {\n            if(a[i] > a[i + 1])\n            {\n                temp = a[i];\n                a[i] = a[i + 1];\n                a[i + 1] = temp;\n            }\n        }\n}\nint main()\n{\n    int number[SIZE] = {95, 45, 15, 78, 84, 51, 24, 12};\n    int i;\n    bubble_sort(number, SIZE);\n    for (i = 0; i < SIZE; i++)\n    {\n        printf(\"%d\\n\", number[i]);\n    }\n}\n```\n\n时间复杂度O(N^2)，额外空间复杂度O(1)","source":"_posts/冒泡排序.md","raw":"title: 冒泡排序\nauthor: Cyrus\ntags:\n  - 八大排序\ncategories:\n  - 算法\ndate: 2018-10-23 23:16:00\n---\n冒泡排序，百度百科是这么介绍的：\n\n冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法。\n它重复地走访过要排序的元素列，依次比较两个相邻的元素，如果他们的顺序（如从大到小、首字母从A到Z）错误就把他们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素已经排序完成。\n这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列），就如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样，故名“冒泡排序”。\n“冒泡” 这个词总让我感觉有点奇怪，因为根据这个排序方法，最先确定下来的数是数组尾端的数，根据循环由后往前一个一个的确定位置，这不是 <font color=#A52A2A size=4 >“沉底”</font>吗？\n\n——以数组尾端作为水面的吧，好吧，没毛病~~\n\n图示如下：\n![](冒泡.png)\n\nC代码算法：\n```\n#include <stdio.h>\n#define SIZE 8\nvoid bubble_sort(int a[], int n);\nvoid bubble_sort(int a[], int n)\n{\n    int i, j, temp;\n    for (j = 0; j < n - 1; j++)\n        for (i = 0; i < n - 1 - j; i++)\n        {\n            if(a[i] > a[i + 1])\n            {\n                temp = a[i];\n                a[i] = a[i + 1];\n                a[i + 1] = temp;\n            }\n        }\n}\nint main()\n{\n    int number[SIZE] = {95, 45, 15, 78, 84, 51, 24, 12};\n    int i;\n    bubble_sort(number, SIZE);\n    for (i = 0; i < SIZE; i++)\n    {\n        printf(\"%d\\n\", number[i]);\n    }\n}\n```\n\n时间复杂度O(N^2)，额外空间复杂度O(1)","slug":"冒泡排序","published":1,"updated":"2019-07-09T08:13:34.976Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyzlbt94001x0j66qfwjxm16","content":"<p>冒泡排序，百度百科是这么介绍的：</p>\n<p>冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法。<br>它重复地走访过要排序的元素列，依次比较两个相邻的元素，如果他们的顺序（如从大到小、首字母从A到Z）错误就把他们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素已经排序完成。<br>这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列），就如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样，故名“冒泡排序”。<br>“冒泡” 这个词总让我感觉有点奇怪，因为根据这个排序方法，最先确定下来的数是数组尾端的数，根据循环由后往前一个一个的确定位置，这不是 <font color=\"#A52A2A\" size=\"4\">“沉底”</font>吗？</p>\n<p>——以数组尾端作为水面的吧，好吧，没毛病~~</p>\n<p>图示如下：<br><img src=\"//www.cyrus.fun/2018/10/23/冒泡排序/冒泡.png\" alt=\"\"></p>\n<p>C代码算法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">#define SIZE 8</span><br><span class=\"line\">void bubble_sort(int a[], int n);</span><br><span class=\"line\">void bubble_sort(int a[], int n)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int i, j, temp;</span><br><span class=\"line\">    for (j = 0; j &lt; n - 1; j++)</span><br><span class=\"line\">        for (i = 0; i &lt; n - 1 - j; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            if(a[i] &gt; a[i + 1])</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                temp = a[i];</span><br><span class=\"line\">                a[i] = a[i + 1];</span><br><span class=\"line\">                a[i + 1] = temp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int number[SIZE] = &#123;95, 45, 15, 78, 84, 51, 24, 12&#125;;</span><br><span class=\"line\">    int i;</span><br><span class=\"line\">    bubble_sort(number, SIZE);</span><br><span class=\"line\">    for (i = 0; i &lt; SIZE; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        printf(&quot;%d\\n&quot;, number[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>时间复杂度O(N^2)，额外空间复杂度O(1)</p>\n","site":{"data":{}},"excerpt":"","more":"<p>冒泡排序，百度百科是这么介绍的：</p>\n<p>冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法。<br>它重复地走访过要排序的元素列，依次比较两个相邻的元素，如果他们的顺序（如从大到小、首字母从A到Z）错误就把他们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素已经排序完成。<br>这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列），就如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样，故名“冒泡排序”。<br>“冒泡” 这个词总让我感觉有点奇怪，因为根据这个排序方法，最先确定下来的数是数组尾端的数，根据循环由后往前一个一个的确定位置，这不是 <font color=\"#A52A2A\" size=\"4\">“沉底”</font>吗？</p>\n<p>——以数组尾端作为水面的吧，好吧，没毛病~~</p>\n<p>图示如下：<br><img src=\"//www.cyrus.fun/2018/10/23/冒泡排序/冒泡.png\" alt=\"\"></p>\n<p>C代码算法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">#define SIZE 8</span><br><span class=\"line\">void bubble_sort(int a[], int n);</span><br><span class=\"line\">void bubble_sort(int a[], int n)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int i, j, temp;</span><br><span class=\"line\">    for (j = 0; j &lt; n - 1; j++)</span><br><span class=\"line\">        for (i = 0; i &lt; n - 1 - j; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            if(a[i] &gt; a[i + 1])</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                temp = a[i];</span><br><span class=\"line\">                a[i] = a[i + 1];</span><br><span class=\"line\">                a[i + 1] = temp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int number[SIZE] = &#123;95, 45, 15, 78, 84, 51, 24, 12&#125;;</span><br><span class=\"line\">    int i;</span><br><span class=\"line\">    bubble_sort(number, SIZE);</span><br><span class=\"line\">    for (i = 0; i &lt; SIZE; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        printf(&quot;%d\\n&quot;, number[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>时间复杂度O(N^2)，额外空间复杂度O(1)</p>\n"},{"title":"AVFoundation学习笔记九 AVCaptureSession1","author":"Cyrus","date":"2018-11-12T14:11:00.000Z","_content":"\n![](capture_session1.png)\n\n### AVCaptureSession \nAVCaptureSession是AVFoundation捕捉栈的核心类。一个session相当于一个虚拟的”插线板”，用于连接输入和输出资源。捕捉会话被处理从物理设备得到的数据流，比如摄像头和麦克风设备，输出到一个或多个目的地。可以动态地配置输入和输出的线路，让开发者能够在会话进行中按需重新配置捕捉环境。\n\nsession还可以额外配置一个会话预设值（session preset）,用来控制捕捉数据的格式和质量。会话预设值默认为AVCaptureSessionPresetHigh,它适用于大多数情况。\n\n### AVCaptureDevice\nAVCaptureDevice为诸如摄像头或麦克风等物理设备定义了一个接口。AVCaptureDevice针对物理硬件设备定义了大量的控制方法，比如控制摄像头的对焦、曝光、白平衡和闪光灯等。\nAVCaptureDevice定义了大量类方法用于访问系统的捕捉设备，最常用的一个方法是defaultDeviceWithMediaType:,它会根据给定的媒体类型返回一个系统指定的默认设备。\n```\n+ (NSArray<AVCaptureDevice *> *)devicesWithMediaType:(AVMediaType)mediaType\n+ (nullable AVCaptureDevice *)defaultDeviceWithMediaType:(AVMediaType)mediaType;\n```\n\n### AVCaptureDeviceInput\n在使用捕捉设备进行处理前，需要将它添加为session的输入。不过一个captureDevice不能直接添加到captureSession中，需要将它封装到一个AVCaptureDeviceInput实例来添加。\n```\n+ (nullable instancetype)deviceInputWithDevice:(AVCaptureDevice *)device error:(NSError * _Nullable * _Nullable)outError;\n```\n\n### AVCaptureOutput\nAVFoundation定义了AVCaptureOutput的许多扩展类。AVCaptureOutput是一个抽象基类，用于为从捕捉会话得到的数据寻找输出目的地。框架定义了一些高级扩展类，如：\n```\nAVCaptureStillImageOutput:捕捉静态照片\nAVCaptureMovieFileOutput: 捕捉视频\nAVCaptureAudioDataOutput: 捕捉底层音频数据\nAVCaptureVideoDataOutput: 捕捉底层视频数据\n```\n\n### AVCaptureConnection\nsession首先需要确定由给定captureInput渲染的媒体类型，并自动建立其到能够接收该媒体类型的captureOutput的连接.比如AVCaptureMovieFileOutput可以授受音频和视频数据，所以会话会确定哪些输入产生视频，哪些输入产生音频，正确地建立该连接。\n\n### AVCaptureVideoPreviewLayer\nAVCaptureVideoPreviewLayer展示正在捕捉的场景。previewLayer是一个Core Animation的CALayer子类，对捕捉视频数据进行实时预览。\n\n代码：\n```\n//创建session和输入输出\nself.captureSession = [[AVCaptureSession alloc] init];                  // 1\n    self.captureSession.sessionPreset = AVCaptureSessionPresetHigh;\n \t// Set up default camera device\n \tAVCaptureDevice *videoDevice =                                          // 2\n        [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeVideo];\n    AVCaptureDeviceInput *videoInput =                                      // 3\n        [AVCaptureDeviceInput deviceInputWithDevice:videoDevice error:error];\n    if (videoInput) {\n        if ([self.captureSession canAddInput:videoInput]) {                 // 4\n            [self.captureSession addInput:videoInput];\n            self.activeVideoInput = videoInput;\n        }\n    } else {\n        return NO;\n    }\n    // Setup default microphone\n    AVCaptureDevice *audioDevice =                                          // 5\n        [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeAudio];\n    AVCaptureDeviceInput *audioInput =                                      // 6\n        [AVCaptureDeviceInput deviceInputWithDevice:audioDevice error:error];\n    if (audioInput) {\n        if ([self.captureSession canAddInput:audioInput]) {                 // 7\n            [self.captureSession addInput:audioInput];\n        }\n    } else {\n        return NO;\n    }\n \t// Setup the still image output\n    self.imageOutput = [[AVCaptureStillImageOutput alloc] init];            // 8\n    self.imageOutput.outputSettings = @{AVVideoCodecKey : AVVideoCodecJPEG};\n \tif ([self.captureSession canAddOutput:self.imageOutput]) {\n \t\t[self.captureSession addOutput:self.imageOutput];\n \t}\n    return YES;\n```\n\n切换摄像头\n```\n- (AVCaptureDevice *)activeCamera {                                         // 3\n    return self.activeVideoInput.device;\n}\n- (AVCaptureDevice *)inactiveCamera {                                       // 4\n    AVCaptureDevice *device = nil;\n    if (self.cameraCount > 1) {\n        if ([self activeCamera].position == AVCaptureDevicePositionBack) {  // 5\n            device = [self cameraWithPosition:AVCaptureDevicePositionFront];\n        } else {\n            device = [self cameraWithPosition:AVCaptureDevicePositionBack];\n        }\n    }\n    return device;\n}\n- (BOOL)canSwitchCameras {                                                  // 6\n    return self.cameraCount > 1;\n}\n\n- (BOOL)switchCameras {\n    if (![self canSwitchCameras]) {                                         // 1\n        return NO;\n    }\n    NSError *error;\n    AVCaptureDevice *videoDevice = [self inactiveCamera];                   // 2\n    AVCaptureDeviceInput *videoInput =\n    [AVCaptureDeviceInput deviceInputWithDevice:videoDevice error:&error];\n    if (videoInput) {\n        [self.captureSession beginConfiguration];                           // 3\n        [self.captureSession removeInput:self.activeVideoInput];            // 4\n        if ([self.captureSession canAddInput:videoInput]) {                 // 5\n            [self.captureSession addInput:videoInput];\n            self.activeVideoInput = videoInput;\n        } else {\n            [self.captureSession addInput:self.activeVideoInput];\n        }\n        [self.captureSession commitConfiguration];                          // 6\n    } else {\n        [self.delegate deviceConfigurationFailedWithError:error];           // 7\n        return NO;\n    }\n    return YES;\n}\n```\n\n闪光灯\n```\n- (BOOL)cameraHasFlash {\n    return [[self activeCamera] hasFlash];\n}\n- (AVCaptureFlashMode)flashMode {\n    return [[self activeCamera] flashMode];\n}\n- (void)setFlashMode:(AVCaptureFlashMode)flashMode {\n    AVCaptureDevice *device = [self activeCamera];\n    if (device.flashMode != flashMode &&\n        [device isFlashModeSupported:flashMode]) {\n        NSError *error;\n        if ([device lockForConfiguration:&error]) {\n            device.flashMode = flashMode;\n            [device unlockForConfiguration];\n        } else {\n            [self.delegate deviceConfigurationFailedWithError:error];\n        }\n    }\n}\n```\n\n手电筒\n```\n- (BOOL)cameraHasTorch {\n    return [[self activeCamera] hasTorch];\n}\n- (AVCaptureTorchMode)torchMode {\n    return [[self activeCamera] torchMode];\n}\n- (void)setTorchMode:(AVCaptureTorchMode)torchMode {\n    AVCaptureDevice *device = [self activeCamera];\n    if (device.torchMode != torchMode &&\n        [device isTorchModeSupported:torchMode]) {\n        NSError *error;\n        if ([device lockForConfiguration:&error]) {\n            device.torchMode = torchMode;\n            [device unlockForConfiguration];\n        } else {\n            [self.delegate deviceConfigurationFailedWithError:error];\n        }\n    }\n}\n```\n\n对焦\n```\n- (BOOL)cameraSupportsTapToFocus {                                          // 1\n    return [[self activeCamera] isFocusPointOfInterestSupported];\n}\n- (void)focusAtPoint:(CGPoint)point {                                       // 2\n    AVCaptureDevice *device = [self activeCamera];\n    if (device.isFocusPointOfInterestSupported &&                           // 3\n        [device isFocusModeSupported:AVCaptureFocusModeAutoFocus]) {\n        NSError *error;\n        if ([device lockForConfiguration:&error]) {                         // 4\n            device.focusPointOfInterest = point;\n            device.focusMode = AVCaptureFocusModeAutoFocus;\n            [device unlockForConfiguration];\n        } else {\n            [self.delegate deviceConfigurationFailedWithError:error];\n        }\n    }\n}\n```\n\n曝光\n```\n- (BOOL)cameraSupportsTapToExpose {                                         // 1\n    return [[self activeCamera] isExposurePointOfInterestSupported];\n}\n// Define KVO context pointer for observing 'adjustingExposure\" device property.\nstatic const NSString *THCameraAdjustingExposureContext;\n- (void)exposeAtPoint:(CGPoint)point {\n    AVCaptureDevice *device = [self activeCamera];\n    AVCaptureExposureMode exposureMode =\n    AVCaptureExposureModeContinuousAutoExposure;\n    if (device.isExposurePointOfInterestSupported &&                        // 2\n        [device isExposureModeSupported:exposureMode]) {\n        NSError *error;\n        if ([device lockForConfiguration:&error]) {                         // 3\n            device.exposurePointOfInterest = point;\n            device.exposureMode = exposureMode;\n            if ([device isExposureModeSupported:AVCaptureExposureModeLocked]) {\n                [device addObserver:self                                    // 4\n                         forKeyPath:@\"adjustingExposure\"\n                            options:NSKeyValueObservingOptionNew\n                            context:&THCameraAdjustingExposureContext];\n            }\n            [device unlockForConfiguration];\n        } else {\n            [self.delegate deviceConfigurationFailedWithError:error];\n        }\n    }\n}\n- (void)observeValueForKeyPath:(NSString *)keyPath\n                      ofObject:(id)object\n                        change:(NSDictionary *)change\n                       context:(void *)context {\n    if (context == &THCameraAdjustingExposureContext) {                     // 5\n        AVCaptureDevice *device = (AVCaptureDevice *)object;\n        if (!device.isAdjustingExposure &&                                  // 6\n            [device isExposureModeSupported:AVCaptureExposureModeLocked]) {\n            [object removeObserver:self                                    // 7\n                        forKeyPath:@\"adjustingExposure\"\n                           context:&THCameraAdjustingExposureContext];\n            dispatch_async(dispatch_get_main_queue(), ^{                    // 8\n                NSError *error;\n                if ([device lockForConfiguration:&error]) {\n                    device.exposureMode = AVCaptureExposureModeLocked;\n                    [device unlockForConfiguration];\n                } else {\n                    [self.delegate deviceConfigurationFailedWithError:error];\n                }\n            });\n        }\n    } else {\n        [super observeValueForKeyPath:keyPath\n                             ofObject:object\n                               change:change\n                              context:context];\n    }\n}\n```\n\nAVCaptureStillImageOutput生成图片并保存\n```\n- (void)captureStillImage {\n    AVCaptureConnection *connection =                                   \n        [self.imageOutput connectionWithMediaType:AVMediaTypeVideo];\n    if (connection.isVideoOrientationSupported) {                       \n        connection.videoOrientation = [self currentVideoOrientation];\n    }\n    id handler = ^(CMSampleBufferRef sampleBuffer, NSError *error) {\n        if (sampleBuffer != NULL) {\n            NSData *imageData =\n                [AVCaptureStillImageOutput\n                    jpegStillImageNSDataRepresentation:sampleBuffer];\n            UIImage *image = [[UIImage alloc] initWithData:imageData];\n            [self writeImageToAssetsLibrary:image];                         // 1\n        } else {\n            NSLog(@\"NULL sampleBuffer: %@\", [error localizedDescription]);\n        }\n    };\n    // Capture still image\n    [self.imageOutput captureStillImageAsynchronouslyFromConnection:connection\n                                                  completionHandler:handler];\n}\n- (void)writeImageToAssetsLibrary:(UIImage *)image {\n    ALAssetsLibrary *library = [[ALAssetsLibrary alloc] init];              // 2\n    [library writeImageToSavedPhotosAlbum:image.CGImage                    // 3\n                              orientation:(NSInteger)image.imageOrientation // 4\n                          completionBlock:^(NSURL *assetURL, NSError *error) {\n                              if (!error) {\n                                  [self postThumbnailNotifification:image]; // 5\n                              } else {\n                                  id message = [error localizedDescription];\n                                  NSLog(@\"Error: %@\", message);\n                              }\n                          }];\n}\n```\n\nAVCaptureMovieFileOutput生成文件并保存\n```\n/开始录制\n[self.movieOutput startRecordingToOutputFileURL:self.outputURL recordingDelegate:self];\n\n//停止录制\n[self.movieOutput stopRecording];\n\n#pragma mark - AVCaptureFileOutputRecordingDelegate - --\n- (void)captureOutput:(AVCaptureFileOutput *)captureOutput\ndidFinishRecordingToOutputFileAtURL:(NSURL *)outputFileURL\n      fromConnections:(NSArray *)connections\n                error:(NSError *)error {\n \tif (error) {                                                            // 1\n        [self.delegate mediaCaptureFailedWithError:error];\n \t} else {\n        [self writeVideoToAssetsLibrary:[self.outputURL copy]];\n \t}\n    self.outputURL = nil;\n}\n\n- (void)writeVideoToAssetsLibrary:(NSURL *)videoURL {\n    ALAssetsLibrary *library = [[ALAssetsLibrary alloc] init];              // 2\n    if ([library videoAtPathIsCompatibleWithSavedPhotosAlbum:videoURL]) {   // 3\n        ALAssetsLibraryWriteVideoCompletionBlock completionBlock;\n        completionBlock = ^(NSURL *assetURL, NSError *error){               // 4\n            if (error) {\n                [self.delegate assetLibraryWriteFailedWithError:error];\n            } else {\n                [self generateThumbnailForVideoAtURL:videoURL];\n            }\n        };\n        [library writeVideoAtPathToSavedPhotosAlbum:videoURL                // 8\n                                    completionBlock:completionBlock];\n    }\n}\n```","source":"_posts/AVFoundation学习笔记九.md","raw":"title: AVFoundation学习笔记九 AVCaptureSession1\nauthor: Cyrus\ntags: []\ncategories:\n  - AVFoundation\ndate: 2018-11-12 22:11:00\n---\n\n![](capture_session1.png)\n\n### AVCaptureSession \nAVCaptureSession是AVFoundation捕捉栈的核心类。一个session相当于一个虚拟的”插线板”，用于连接输入和输出资源。捕捉会话被处理从物理设备得到的数据流，比如摄像头和麦克风设备，输出到一个或多个目的地。可以动态地配置输入和输出的线路，让开发者能够在会话进行中按需重新配置捕捉环境。\n\nsession还可以额外配置一个会话预设值（session preset）,用来控制捕捉数据的格式和质量。会话预设值默认为AVCaptureSessionPresetHigh,它适用于大多数情况。\n\n### AVCaptureDevice\nAVCaptureDevice为诸如摄像头或麦克风等物理设备定义了一个接口。AVCaptureDevice针对物理硬件设备定义了大量的控制方法，比如控制摄像头的对焦、曝光、白平衡和闪光灯等。\nAVCaptureDevice定义了大量类方法用于访问系统的捕捉设备，最常用的一个方法是defaultDeviceWithMediaType:,它会根据给定的媒体类型返回一个系统指定的默认设备。\n```\n+ (NSArray<AVCaptureDevice *> *)devicesWithMediaType:(AVMediaType)mediaType\n+ (nullable AVCaptureDevice *)defaultDeviceWithMediaType:(AVMediaType)mediaType;\n```\n\n### AVCaptureDeviceInput\n在使用捕捉设备进行处理前，需要将它添加为session的输入。不过一个captureDevice不能直接添加到captureSession中，需要将它封装到一个AVCaptureDeviceInput实例来添加。\n```\n+ (nullable instancetype)deviceInputWithDevice:(AVCaptureDevice *)device error:(NSError * _Nullable * _Nullable)outError;\n```\n\n### AVCaptureOutput\nAVFoundation定义了AVCaptureOutput的许多扩展类。AVCaptureOutput是一个抽象基类，用于为从捕捉会话得到的数据寻找输出目的地。框架定义了一些高级扩展类，如：\n```\nAVCaptureStillImageOutput:捕捉静态照片\nAVCaptureMovieFileOutput: 捕捉视频\nAVCaptureAudioDataOutput: 捕捉底层音频数据\nAVCaptureVideoDataOutput: 捕捉底层视频数据\n```\n\n### AVCaptureConnection\nsession首先需要确定由给定captureInput渲染的媒体类型，并自动建立其到能够接收该媒体类型的captureOutput的连接.比如AVCaptureMovieFileOutput可以授受音频和视频数据，所以会话会确定哪些输入产生视频，哪些输入产生音频，正确地建立该连接。\n\n### AVCaptureVideoPreviewLayer\nAVCaptureVideoPreviewLayer展示正在捕捉的场景。previewLayer是一个Core Animation的CALayer子类，对捕捉视频数据进行实时预览。\n\n代码：\n```\n//创建session和输入输出\nself.captureSession = [[AVCaptureSession alloc] init];                  // 1\n    self.captureSession.sessionPreset = AVCaptureSessionPresetHigh;\n \t// Set up default camera device\n \tAVCaptureDevice *videoDevice =                                          // 2\n        [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeVideo];\n    AVCaptureDeviceInput *videoInput =                                      // 3\n        [AVCaptureDeviceInput deviceInputWithDevice:videoDevice error:error];\n    if (videoInput) {\n        if ([self.captureSession canAddInput:videoInput]) {                 // 4\n            [self.captureSession addInput:videoInput];\n            self.activeVideoInput = videoInput;\n        }\n    } else {\n        return NO;\n    }\n    // Setup default microphone\n    AVCaptureDevice *audioDevice =                                          // 5\n        [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeAudio];\n    AVCaptureDeviceInput *audioInput =                                      // 6\n        [AVCaptureDeviceInput deviceInputWithDevice:audioDevice error:error];\n    if (audioInput) {\n        if ([self.captureSession canAddInput:audioInput]) {                 // 7\n            [self.captureSession addInput:audioInput];\n        }\n    } else {\n        return NO;\n    }\n \t// Setup the still image output\n    self.imageOutput = [[AVCaptureStillImageOutput alloc] init];            // 8\n    self.imageOutput.outputSettings = @{AVVideoCodecKey : AVVideoCodecJPEG};\n \tif ([self.captureSession canAddOutput:self.imageOutput]) {\n \t\t[self.captureSession addOutput:self.imageOutput];\n \t}\n    return YES;\n```\n\n切换摄像头\n```\n- (AVCaptureDevice *)activeCamera {                                         // 3\n    return self.activeVideoInput.device;\n}\n- (AVCaptureDevice *)inactiveCamera {                                       // 4\n    AVCaptureDevice *device = nil;\n    if (self.cameraCount > 1) {\n        if ([self activeCamera].position == AVCaptureDevicePositionBack) {  // 5\n            device = [self cameraWithPosition:AVCaptureDevicePositionFront];\n        } else {\n            device = [self cameraWithPosition:AVCaptureDevicePositionBack];\n        }\n    }\n    return device;\n}\n- (BOOL)canSwitchCameras {                                                  // 6\n    return self.cameraCount > 1;\n}\n\n- (BOOL)switchCameras {\n    if (![self canSwitchCameras]) {                                         // 1\n        return NO;\n    }\n    NSError *error;\n    AVCaptureDevice *videoDevice = [self inactiveCamera];                   // 2\n    AVCaptureDeviceInput *videoInput =\n    [AVCaptureDeviceInput deviceInputWithDevice:videoDevice error:&error];\n    if (videoInput) {\n        [self.captureSession beginConfiguration];                           // 3\n        [self.captureSession removeInput:self.activeVideoInput];            // 4\n        if ([self.captureSession canAddInput:videoInput]) {                 // 5\n            [self.captureSession addInput:videoInput];\n            self.activeVideoInput = videoInput;\n        } else {\n            [self.captureSession addInput:self.activeVideoInput];\n        }\n        [self.captureSession commitConfiguration];                          // 6\n    } else {\n        [self.delegate deviceConfigurationFailedWithError:error];           // 7\n        return NO;\n    }\n    return YES;\n}\n```\n\n闪光灯\n```\n- (BOOL)cameraHasFlash {\n    return [[self activeCamera] hasFlash];\n}\n- (AVCaptureFlashMode)flashMode {\n    return [[self activeCamera] flashMode];\n}\n- (void)setFlashMode:(AVCaptureFlashMode)flashMode {\n    AVCaptureDevice *device = [self activeCamera];\n    if (device.flashMode != flashMode &&\n        [device isFlashModeSupported:flashMode]) {\n        NSError *error;\n        if ([device lockForConfiguration:&error]) {\n            device.flashMode = flashMode;\n            [device unlockForConfiguration];\n        } else {\n            [self.delegate deviceConfigurationFailedWithError:error];\n        }\n    }\n}\n```\n\n手电筒\n```\n- (BOOL)cameraHasTorch {\n    return [[self activeCamera] hasTorch];\n}\n- (AVCaptureTorchMode)torchMode {\n    return [[self activeCamera] torchMode];\n}\n- (void)setTorchMode:(AVCaptureTorchMode)torchMode {\n    AVCaptureDevice *device = [self activeCamera];\n    if (device.torchMode != torchMode &&\n        [device isTorchModeSupported:torchMode]) {\n        NSError *error;\n        if ([device lockForConfiguration:&error]) {\n            device.torchMode = torchMode;\n            [device unlockForConfiguration];\n        } else {\n            [self.delegate deviceConfigurationFailedWithError:error];\n        }\n    }\n}\n```\n\n对焦\n```\n- (BOOL)cameraSupportsTapToFocus {                                          // 1\n    return [[self activeCamera] isFocusPointOfInterestSupported];\n}\n- (void)focusAtPoint:(CGPoint)point {                                       // 2\n    AVCaptureDevice *device = [self activeCamera];\n    if (device.isFocusPointOfInterestSupported &&                           // 3\n        [device isFocusModeSupported:AVCaptureFocusModeAutoFocus]) {\n        NSError *error;\n        if ([device lockForConfiguration:&error]) {                         // 4\n            device.focusPointOfInterest = point;\n            device.focusMode = AVCaptureFocusModeAutoFocus;\n            [device unlockForConfiguration];\n        } else {\n            [self.delegate deviceConfigurationFailedWithError:error];\n        }\n    }\n}\n```\n\n曝光\n```\n- (BOOL)cameraSupportsTapToExpose {                                         // 1\n    return [[self activeCamera] isExposurePointOfInterestSupported];\n}\n// Define KVO context pointer for observing 'adjustingExposure\" device property.\nstatic const NSString *THCameraAdjustingExposureContext;\n- (void)exposeAtPoint:(CGPoint)point {\n    AVCaptureDevice *device = [self activeCamera];\n    AVCaptureExposureMode exposureMode =\n    AVCaptureExposureModeContinuousAutoExposure;\n    if (device.isExposurePointOfInterestSupported &&                        // 2\n        [device isExposureModeSupported:exposureMode]) {\n        NSError *error;\n        if ([device lockForConfiguration:&error]) {                         // 3\n            device.exposurePointOfInterest = point;\n            device.exposureMode = exposureMode;\n            if ([device isExposureModeSupported:AVCaptureExposureModeLocked]) {\n                [device addObserver:self                                    // 4\n                         forKeyPath:@\"adjustingExposure\"\n                            options:NSKeyValueObservingOptionNew\n                            context:&THCameraAdjustingExposureContext];\n            }\n            [device unlockForConfiguration];\n        } else {\n            [self.delegate deviceConfigurationFailedWithError:error];\n        }\n    }\n}\n- (void)observeValueForKeyPath:(NSString *)keyPath\n                      ofObject:(id)object\n                        change:(NSDictionary *)change\n                       context:(void *)context {\n    if (context == &THCameraAdjustingExposureContext) {                     // 5\n        AVCaptureDevice *device = (AVCaptureDevice *)object;\n        if (!device.isAdjustingExposure &&                                  // 6\n            [device isExposureModeSupported:AVCaptureExposureModeLocked]) {\n            [object removeObserver:self                                    // 7\n                        forKeyPath:@\"adjustingExposure\"\n                           context:&THCameraAdjustingExposureContext];\n            dispatch_async(dispatch_get_main_queue(), ^{                    // 8\n                NSError *error;\n                if ([device lockForConfiguration:&error]) {\n                    device.exposureMode = AVCaptureExposureModeLocked;\n                    [device unlockForConfiguration];\n                } else {\n                    [self.delegate deviceConfigurationFailedWithError:error];\n                }\n            });\n        }\n    } else {\n        [super observeValueForKeyPath:keyPath\n                             ofObject:object\n                               change:change\n                              context:context];\n    }\n}\n```\n\nAVCaptureStillImageOutput生成图片并保存\n```\n- (void)captureStillImage {\n    AVCaptureConnection *connection =                                   \n        [self.imageOutput connectionWithMediaType:AVMediaTypeVideo];\n    if (connection.isVideoOrientationSupported) {                       \n        connection.videoOrientation = [self currentVideoOrientation];\n    }\n    id handler = ^(CMSampleBufferRef sampleBuffer, NSError *error) {\n        if (sampleBuffer != NULL) {\n            NSData *imageData =\n                [AVCaptureStillImageOutput\n                    jpegStillImageNSDataRepresentation:sampleBuffer];\n            UIImage *image = [[UIImage alloc] initWithData:imageData];\n            [self writeImageToAssetsLibrary:image];                         // 1\n        } else {\n            NSLog(@\"NULL sampleBuffer: %@\", [error localizedDescription]);\n        }\n    };\n    // Capture still image\n    [self.imageOutput captureStillImageAsynchronouslyFromConnection:connection\n                                                  completionHandler:handler];\n}\n- (void)writeImageToAssetsLibrary:(UIImage *)image {\n    ALAssetsLibrary *library = [[ALAssetsLibrary alloc] init];              // 2\n    [library writeImageToSavedPhotosAlbum:image.CGImage                    // 3\n                              orientation:(NSInteger)image.imageOrientation // 4\n                          completionBlock:^(NSURL *assetURL, NSError *error) {\n                              if (!error) {\n                                  [self postThumbnailNotifification:image]; // 5\n                              } else {\n                                  id message = [error localizedDescription];\n                                  NSLog(@\"Error: %@\", message);\n                              }\n                          }];\n}\n```\n\nAVCaptureMovieFileOutput生成文件并保存\n```\n/开始录制\n[self.movieOutput startRecordingToOutputFileURL:self.outputURL recordingDelegate:self];\n\n//停止录制\n[self.movieOutput stopRecording];\n\n#pragma mark - AVCaptureFileOutputRecordingDelegate - --\n- (void)captureOutput:(AVCaptureFileOutput *)captureOutput\ndidFinishRecordingToOutputFileAtURL:(NSURL *)outputFileURL\n      fromConnections:(NSArray *)connections\n                error:(NSError *)error {\n \tif (error) {                                                            // 1\n        [self.delegate mediaCaptureFailedWithError:error];\n \t} else {\n        [self writeVideoToAssetsLibrary:[self.outputURL copy]];\n \t}\n    self.outputURL = nil;\n}\n\n- (void)writeVideoToAssetsLibrary:(NSURL *)videoURL {\n    ALAssetsLibrary *library = [[ALAssetsLibrary alloc] init];              // 2\n    if ([library videoAtPathIsCompatibleWithSavedPhotosAlbum:videoURL]) {   // 3\n        ALAssetsLibraryWriteVideoCompletionBlock completionBlock;\n        completionBlock = ^(NSURL *assetURL, NSError *error){               // 4\n            if (error) {\n                [self.delegate assetLibraryWriteFailedWithError:error];\n            } else {\n                [self generateThumbnailForVideoAtURL:videoURL];\n            }\n        };\n        [library writeVideoAtPathToSavedPhotosAlbum:videoURL                // 8\n                                    completionBlock:completionBlock];\n    }\n}\n```","slug":"AVFoundation学习笔记九","published":1,"updated":"2019-07-09T08:13:34.919Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyzlbt9c002d0j66bd4s1rqa","content":"<p><img src=\"//www.cyrus.fun/2018/11/12/AVFoundation学习笔记九/capture_session1.png\" alt=\"\"></p>\n<h3 id=\"AVCaptureSession\"><a href=\"#AVCaptureSession\" class=\"headerlink\" title=\"AVCaptureSession\"></a>AVCaptureSession</h3><p>AVCaptureSession是AVFoundation捕捉栈的核心类。一个session相当于一个虚拟的”插线板”，用于连接输入和输出资源。捕捉会话被处理从物理设备得到的数据流，比如摄像头和麦克风设备，输出到一个或多个目的地。可以动态地配置输入和输出的线路，让开发者能够在会话进行中按需重新配置捕捉环境。</p>\n<p>session还可以额外配置一个会话预设值（session preset）,用来控制捕捉数据的格式和质量。会话预设值默认为AVCaptureSessionPresetHigh,它适用于大多数情况。</p>\n<h3 id=\"AVCaptureDevice\"><a href=\"#AVCaptureDevice\" class=\"headerlink\" title=\"AVCaptureDevice\"></a>AVCaptureDevice</h3><p>AVCaptureDevice为诸如摄像头或麦克风等物理设备定义了一个接口。AVCaptureDevice针对物理硬件设备定义了大量的控制方法，比如控制摄像头的对焦、曝光、白平衡和闪光灯等。<br>AVCaptureDevice定义了大量类方法用于访问系统的捕捉设备，最常用的一个方法是defaultDeviceWithMediaType:,它会根据给定的媒体类型返回一个系统指定的默认设备。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (NSArray&lt;AVCaptureDevice *&gt; *)devicesWithMediaType:(AVMediaType)mediaType</span><br><span class=\"line\">+ (nullable AVCaptureDevice *)defaultDeviceWithMediaType:(AVMediaType)mediaType;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"AVCaptureDeviceInput\"><a href=\"#AVCaptureDeviceInput\" class=\"headerlink\" title=\"AVCaptureDeviceInput\"></a>AVCaptureDeviceInput</h3><p>在使用捕捉设备进行处理前，需要将它添加为session的输入。不过一个captureDevice不能直接添加到captureSession中，需要将它封装到一个AVCaptureDeviceInput实例来添加。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (nullable instancetype)deviceInputWithDevice:(AVCaptureDevice *)device error:(NSError * _Nullable * _Nullable)outError;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"AVCaptureOutput\"><a href=\"#AVCaptureOutput\" class=\"headerlink\" title=\"AVCaptureOutput\"></a>AVCaptureOutput</h3><p>AVFoundation定义了AVCaptureOutput的许多扩展类。AVCaptureOutput是一个抽象基类，用于为从捕捉会话得到的数据寻找输出目的地。框架定义了一些高级扩展类，如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AVCaptureStillImageOutput:捕捉静态照片</span><br><span class=\"line\">AVCaptureMovieFileOutput: 捕捉视频</span><br><span class=\"line\">AVCaptureAudioDataOutput: 捕捉底层音频数据</span><br><span class=\"line\">AVCaptureVideoDataOutput: 捕捉底层视频数据</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"AVCaptureConnection\"><a href=\"#AVCaptureConnection\" class=\"headerlink\" title=\"AVCaptureConnection\"></a>AVCaptureConnection</h3><p>session首先需要确定由给定captureInput渲染的媒体类型，并自动建立其到能够接收该媒体类型的captureOutput的连接.比如AVCaptureMovieFileOutput可以授受音频和视频数据，所以会话会确定哪些输入产生视频，哪些输入产生音频，正确地建立该连接。</p>\n<h3 id=\"AVCaptureVideoPreviewLayer\"><a href=\"#AVCaptureVideoPreviewLayer\" class=\"headerlink\" title=\"AVCaptureVideoPreviewLayer\"></a>AVCaptureVideoPreviewLayer</h3><p>AVCaptureVideoPreviewLayer展示正在捕捉的场景。previewLayer是一个Core Animation的CALayer子类，对捕捉视频数据进行实时预览。</p>\n<p>代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//创建session和输入输出</span><br><span class=\"line\">self.captureSession = [[AVCaptureSession alloc] init];                  // 1</span><br><span class=\"line\">    self.captureSession.sessionPreset = AVCaptureSessionPresetHigh;</span><br><span class=\"line\"> \t// Set up default camera device</span><br><span class=\"line\"> \tAVCaptureDevice *videoDevice =                                          // 2</span><br><span class=\"line\">        [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeVideo];</span><br><span class=\"line\">    AVCaptureDeviceInput *videoInput =                                      // 3</span><br><span class=\"line\">        [AVCaptureDeviceInput deviceInputWithDevice:videoDevice error:error];</span><br><span class=\"line\">    if (videoInput) &#123;</span><br><span class=\"line\">        if ([self.captureSession canAddInput:videoInput]) &#123;                 // 4</span><br><span class=\"line\">            [self.captureSession addInput:videoInput];</span><br><span class=\"line\">            self.activeVideoInput = videoInput;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        return NO;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // Setup default microphone</span><br><span class=\"line\">    AVCaptureDevice *audioDevice =                                          // 5</span><br><span class=\"line\">        [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeAudio];</span><br><span class=\"line\">    AVCaptureDeviceInput *audioInput =                                      // 6</span><br><span class=\"line\">        [AVCaptureDeviceInput deviceInputWithDevice:audioDevice error:error];</span><br><span class=\"line\">    if (audioInput) &#123;</span><br><span class=\"line\">        if ([self.captureSession canAddInput:audioInput]) &#123;                 // 7</span><br><span class=\"line\">            [self.captureSession addInput:audioInput];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        return NO;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> \t// Setup the still image output</span><br><span class=\"line\">    self.imageOutput = [[AVCaptureStillImageOutput alloc] init];            // 8</span><br><span class=\"line\">    self.imageOutput.outputSettings = @&#123;AVVideoCodecKey : AVVideoCodecJPEG&#125;;</span><br><span class=\"line\"> \tif ([self.captureSession canAddOutput:self.imageOutput]) &#123;</span><br><span class=\"line\"> \t\t[self.captureSession addOutput:self.imageOutput];</span><br><span class=\"line\"> \t&#125;</span><br><span class=\"line\">    return YES;</span><br></pre></td></tr></table></figure></p>\n<p>切换摄像头<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (AVCaptureDevice *)activeCamera &#123;                                         // 3</span><br><span class=\"line\">    return self.activeVideoInput.device;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (AVCaptureDevice *)inactiveCamera &#123;                                       // 4</span><br><span class=\"line\">    AVCaptureDevice *device = nil;</span><br><span class=\"line\">    if (self.cameraCount &gt; 1) &#123;</span><br><span class=\"line\">        if ([self activeCamera].position == AVCaptureDevicePositionBack) &#123;  // 5</span><br><span class=\"line\">            device = [self cameraWithPosition:AVCaptureDevicePositionFront];</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            device = [self cameraWithPosition:AVCaptureDevicePositionBack];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return device;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (BOOL)canSwitchCameras &#123;                                                  // 6</span><br><span class=\"line\">    return self.cameraCount &gt; 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (BOOL)switchCameras &#123;</span><br><span class=\"line\">    if (![self canSwitchCameras]) &#123;                                         // 1</span><br><span class=\"line\">        return NO;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    NSError *error;</span><br><span class=\"line\">    AVCaptureDevice *videoDevice = [self inactiveCamera];                   // 2</span><br><span class=\"line\">    AVCaptureDeviceInput *videoInput =</span><br><span class=\"line\">    [AVCaptureDeviceInput deviceInputWithDevice:videoDevice error:&amp;error];</span><br><span class=\"line\">    if (videoInput) &#123;</span><br><span class=\"line\">        [self.captureSession beginConfiguration];                           // 3</span><br><span class=\"line\">        [self.captureSession removeInput:self.activeVideoInput];            // 4</span><br><span class=\"line\">        if ([self.captureSession canAddInput:videoInput]) &#123;                 // 5</span><br><span class=\"line\">            [self.captureSession addInput:videoInput];</span><br><span class=\"line\">            self.activeVideoInput = videoInput;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            [self.captureSession addInput:self.activeVideoInput];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        [self.captureSession commitConfiguration];                          // 6</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        [self.delegate deviceConfigurationFailedWithError:error];           // 7</span><br><span class=\"line\">        return NO;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return YES;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>闪光灯<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (BOOL)cameraHasFlash &#123;</span><br><span class=\"line\">    return [[self activeCamera] hasFlash];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (AVCaptureFlashMode)flashMode &#123;</span><br><span class=\"line\">    return [[self activeCamera] flashMode];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (void)setFlashMode:(AVCaptureFlashMode)flashMode &#123;</span><br><span class=\"line\">    AVCaptureDevice *device = [self activeCamera];</span><br><span class=\"line\">    if (device.flashMode != flashMode &amp;&amp;</span><br><span class=\"line\">        [device isFlashModeSupported:flashMode]) &#123;</span><br><span class=\"line\">        NSError *error;</span><br><span class=\"line\">        if ([device lockForConfiguration:&amp;error]) &#123;</span><br><span class=\"line\">            device.flashMode = flashMode;</span><br><span class=\"line\">            [device unlockForConfiguration];</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            [self.delegate deviceConfigurationFailedWithError:error];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>手电筒<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (BOOL)cameraHasTorch &#123;</span><br><span class=\"line\">    return [[self activeCamera] hasTorch];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (AVCaptureTorchMode)torchMode &#123;</span><br><span class=\"line\">    return [[self activeCamera] torchMode];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (void)setTorchMode:(AVCaptureTorchMode)torchMode &#123;</span><br><span class=\"line\">    AVCaptureDevice *device = [self activeCamera];</span><br><span class=\"line\">    if (device.torchMode != torchMode &amp;&amp;</span><br><span class=\"line\">        [device isTorchModeSupported:torchMode]) &#123;</span><br><span class=\"line\">        NSError *error;</span><br><span class=\"line\">        if ([device lockForConfiguration:&amp;error]) &#123;</span><br><span class=\"line\">            device.torchMode = torchMode;</span><br><span class=\"line\">            [device unlockForConfiguration];</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            [self.delegate deviceConfigurationFailedWithError:error];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>对焦<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (BOOL)cameraSupportsTapToFocus &#123;                                          // 1</span><br><span class=\"line\">    return [[self activeCamera] isFocusPointOfInterestSupported];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (void)focusAtPoint:(CGPoint)point &#123;                                       // 2</span><br><span class=\"line\">    AVCaptureDevice *device = [self activeCamera];</span><br><span class=\"line\">    if (device.isFocusPointOfInterestSupported &amp;&amp;                           // 3</span><br><span class=\"line\">        [device isFocusModeSupported:AVCaptureFocusModeAutoFocus]) &#123;</span><br><span class=\"line\">        NSError *error;</span><br><span class=\"line\">        if ([device lockForConfiguration:&amp;error]) &#123;                         // 4</span><br><span class=\"line\">            device.focusPointOfInterest = point;</span><br><span class=\"line\">            device.focusMode = AVCaptureFocusModeAutoFocus;</span><br><span class=\"line\">            [device unlockForConfiguration];</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            [self.delegate deviceConfigurationFailedWithError:error];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>曝光<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (BOOL)cameraSupportsTapToExpose &#123;                                         // 1</span><br><span class=\"line\">    return [[self activeCamera] isExposurePointOfInterestSupported];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// Define KVO context pointer for observing &apos;adjustingExposure&quot; device property.</span><br><span class=\"line\">static const NSString *THCameraAdjustingExposureContext;</span><br><span class=\"line\">- (void)exposeAtPoint:(CGPoint)point &#123;</span><br><span class=\"line\">    AVCaptureDevice *device = [self activeCamera];</span><br><span class=\"line\">    AVCaptureExposureMode exposureMode =</span><br><span class=\"line\">    AVCaptureExposureModeContinuousAutoExposure;</span><br><span class=\"line\">    if (device.isExposurePointOfInterestSupported &amp;&amp;                        // 2</span><br><span class=\"line\">        [device isExposureModeSupported:exposureMode]) &#123;</span><br><span class=\"line\">        NSError *error;</span><br><span class=\"line\">        if ([device lockForConfiguration:&amp;error]) &#123;                         // 3</span><br><span class=\"line\">            device.exposurePointOfInterest = point;</span><br><span class=\"line\">            device.exposureMode = exposureMode;</span><br><span class=\"line\">            if ([device isExposureModeSupported:AVCaptureExposureModeLocked]) &#123;</span><br><span class=\"line\">                [device addObserver:self                                    // 4</span><br><span class=\"line\">                         forKeyPath:@&quot;adjustingExposure&quot;</span><br><span class=\"line\">                            options:NSKeyValueObservingOptionNew</span><br><span class=\"line\">                            context:&amp;THCameraAdjustingExposureContext];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            [device unlockForConfiguration];</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            [self.delegate deviceConfigurationFailedWithError:error];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (void)observeValueForKeyPath:(NSString *)keyPath</span><br><span class=\"line\">                      ofObject:(id)object</span><br><span class=\"line\">                        change:(NSDictionary *)change</span><br><span class=\"line\">                       context:(void *)context &#123;</span><br><span class=\"line\">    if (context == &amp;THCameraAdjustingExposureContext) &#123;                     // 5</span><br><span class=\"line\">        AVCaptureDevice *device = (AVCaptureDevice *)object;</span><br><span class=\"line\">        if (!device.isAdjustingExposure &amp;&amp;                                  // 6</span><br><span class=\"line\">            [device isExposureModeSupported:AVCaptureExposureModeLocked]) &#123;</span><br><span class=\"line\">            [object removeObserver:self                                    // 7</span><br><span class=\"line\">                        forKeyPath:@&quot;adjustingExposure&quot;</span><br><span class=\"line\">                           context:&amp;THCameraAdjustingExposureContext];</span><br><span class=\"line\">            dispatch_async(dispatch_get_main_queue(), ^&#123;                    // 8</span><br><span class=\"line\">                NSError *error;</span><br><span class=\"line\">                if ([device lockForConfiguration:&amp;error]) &#123;</span><br><span class=\"line\">                    device.exposureMode = AVCaptureExposureModeLocked;</span><br><span class=\"line\">                    [device unlockForConfiguration];</span><br><span class=\"line\">                &#125; else &#123;</span><br><span class=\"line\">                    [self.delegate deviceConfigurationFailedWithError:error];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        [super observeValueForKeyPath:keyPath</span><br><span class=\"line\">                             ofObject:object</span><br><span class=\"line\">                               change:change</span><br><span class=\"line\">                              context:context];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>AVCaptureStillImageOutput生成图片并保存<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)captureStillImage &#123;</span><br><span class=\"line\">    AVCaptureConnection *connection =                                   </span><br><span class=\"line\">        [self.imageOutput connectionWithMediaType:AVMediaTypeVideo];</span><br><span class=\"line\">    if (connection.isVideoOrientationSupported) &#123;                       </span><br><span class=\"line\">        connection.videoOrientation = [self currentVideoOrientation];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    id handler = ^(CMSampleBufferRef sampleBuffer, NSError *error) &#123;</span><br><span class=\"line\">        if (sampleBuffer != NULL) &#123;</span><br><span class=\"line\">            NSData *imageData =</span><br><span class=\"line\">                [AVCaptureStillImageOutput</span><br><span class=\"line\">                    jpegStillImageNSDataRepresentation:sampleBuffer];</span><br><span class=\"line\">            UIImage *image = [[UIImage alloc] initWithData:imageData];</span><br><span class=\"line\">            [self writeImageToAssetsLibrary:image];                         // 1</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            NSLog(@&quot;NULL sampleBuffer: %@&quot;, [error localizedDescription]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    // Capture still image</span><br><span class=\"line\">    [self.imageOutput captureStillImageAsynchronouslyFromConnection:connection</span><br><span class=\"line\">                                                  completionHandler:handler];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (void)writeImageToAssetsLibrary:(UIImage *)image &#123;</span><br><span class=\"line\">    ALAssetsLibrary *library = [[ALAssetsLibrary alloc] init];              // 2</span><br><span class=\"line\">    [library writeImageToSavedPhotosAlbum:image.CGImage                    // 3</span><br><span class=\"line\">                              orientation:(NSInteger)image.imageOrientation // 4</span><br><span class=\"line\">                          completionBlock:^(NSURL *assetURL, NSError *error) &#123;</span><br><span class=\"line\">                              if (!error) &#123;</span><br><span class=\"line\">                                  [self postThumbnailNotifification:image]; // 5</span><br><span class=\"line\">                              &#125; else &#123;</span><br><span class=\"line\">                                  id message = [error localizedDescription];</span><br><span class=\"line\">                                  NSLog(@&quot;Error: %@&quot;, message);</span><br><span class=\"line\">                              &#125;</span><br><span class=\"line\">                          &#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>AVCaptureMovieFileOutput生成文件并保存<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/开始录制</span><br><span class=\"line\">[self.movieOutput startRecordingToOutputFileURL:self.outputURL recordingDelegate:self];</span><br><span class=\"line\"></span><br><span class=\"line\">//停止录制</span><br><span class=\"line\">[self.movieOutput stopRecording];</span><br><span class=\"line\"></span><br><span class=\"line\">#pragma mark - AVCaptureFileOutputRecordingDelegate - --</span><br><span class=\"line\">- (void)captureOutput:(AVCaptureFileOutput *)captureOutput</span><br><span class=\"line\">didFinishRecordingToOutputFileAtURL:(NSURL *)outputFileURL</span><br><span class=\"line\">      fromConnections:(NSArray *)connections</span><br><span class=\"line\">                error:(NSError *)error &#123;</span><br><span class=\"line\"> \tif (error) &#123;                                                            // 1</span><br><span class=\"line\">        [self.delegate mediaCaptureFailedWithError:error];</span><br><span class=\"line\"> \t&#125; else &#123;</span><br><span class=\"line\">        [self writeVideoToAssetsLibrary:[self.outputURL copy]];</span><br><span class=\"line\"> \t&#125;</span><br><span class=\"line\">    self.outputURL = nil;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)writeVideoToAssetsLibrary:(NSURL *)videoURL &#123;</span><br><span class=\"line\">    ALAssetsLibrary *library = [[ALAssetsLibrary alloc] init];              // 2</span><br><span class=\"line\">    if ([library videoAtPathIsCompatibleWithSavedPhotosAlbum:videoURL]) &#123;   // 3</span><br><span class=\"line\">        ALAssetsLibraryWriteVideoCompletionBlock completionBlock;</span><br><span class=\"line\">        completionBlock = ^(NSURL *assetURL, NSError *error)&#123;               // 4</span><br><span class=\"line\">            if (error) &#123;</span><br><span class=\"line\">                [self.delegate assetLibraryWriteFailedWithError:error];</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                [self generateThumbnailForVideoAtURL:videoURL];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        [library writeVideoAtPathToSavedPhotosAlbum:videoURL                // 8</span><br><span class=\"line\">                                    completionBlock:completionBlock];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"//www.cyrus.fun/2018/11/12/AVFoundation学习笔记九/capture_session1.png\" alt=\"\"></p>\n<h3 id=\"AVCaptureSession\"><a href=\"#AVCaptureSession\" class=\"headerlink\" title=\"AVCaptureSession\"></a>AVCaptureSession</h3><p>AVCaptureSession是AVFoundation捕捉栈的核心类。一个session相当于一个虚拟的”插线板”，用于连接输入和输出资源。捕捉会话被处理从物理设备得到的数据流，比如摄像头和麦克风设备，输出到一个或多个目的地。可以动态地配置输入和输出的线路，让开发者能够在会话进行中按需重新配置捕捉环境。</p>\n<p>session还可以额外配置一个会话预设值（session preset）,用来控制捕捉数据的格式和质量。会话预设值默认为AVCaptureSessionPresetHigh,它适用于大多数情况。</p>\n<h3 id=\"AVCaptureDevice\"><a href=\"#AVCaptureDevice\" class=\"headerlink\" title=\"AVCaptureDevice\"></a>AVCaptureDevice</h3><p>AVCaptureDevice为诸如摄像头或麦克风等物理设备定义了一个接口。AVCaptureDevice针对物理硬件设备定义了大量的控制方法，比如控制摄像头的对焦、曝光、白平衡和闪光灯等。<br>AVCaptureDevice定义了大量类方法用于访问系统的捕捉设备，最常用的一个方法是defaultDeviceWithMediaType:,它会根据给定的媒体类型返回一个系统指定的默认设备。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (NSArray&lt;AVCaptureDevice *&gt; *)devicesWithMediaType:(AVMediaType)mediaType</span><br><span class=\"line\">+ (nullable AVCaptureDevice *)defaultDeviceWithMediaType:(AVMediaType)mediaType;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"AVCaptureDeviceInput\"><a href=\"#AVCaptureDeviceInput\" class=\"headerlink\" title=\"AVCaptureDeviceInput\"></a>AVCaptureDeviceInput</h3><p>在使用捕捉设备进行处理前，需要将它添加为session的输入。不过一个captureDevice不能直接添加到captureSession中，需要将它封装到一个AVCaptureDeviceInput实例来添加。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (nullable instancetype)deviceInputWithDevice:(AVCaptureDevice *)device error:(NSError * _Nullable * _Nullable)outError;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"AVCaptureOutput\"><a href=\"#AVCaptureOutput\" class=\"headerlink\" title=\"AVCaptureOutput\"></a>AVCaptureOutput</h3><p>AVFoundation定义了AVCaptureOutput的许多扩展类。AVCaptureOutput是一个抽象基类，用于为从捕捉会话得到的数据寻找输出目的地。框架定义了一些高级扩展类，如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AVCaptureStillImageOutput:捕捉静态照片</span><br><span class=\"line\">AVCaptureMovieFileOutput: 捕捉视频</span><br><span class=\"line\">AVCaptureAudioDataOutput: 捕捉底层音频数据</span><br><span class=\"line\">AVCaptureVideoDataOutput: 捕捉底层视频数据</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"AVCaptureConnection\"><a href=\"#AVCaptureConnection\" class=\"headerlink\" title=\"AVCaptureConnection\"></a>AVCaptureConnection</h3><p>session首先需要确定由给定captureInput渲染的媒体类型，并自动建立其到能够接收该媒体类型的captureOutput的连接.比如AVCaptureMovieFileOutput可以授受音频和视频数据，所以会话会确定哪些输入产生视频，哪些输入产生音频，正确地建立该连接。</p>\n<h3 id=\"AVCaptureVideoPreviewLayer\"><a href=\"#AVCaptureVideoPreviewLayer\" class=\"headerlink\" title=\"AVCaptureVideoPreviewLayer\"></a>AVCaptureVideoPreviewLayer</h3><p>AVCaptureVideoPreviewLayer展示正在捕捉的场景。previewLayer是一个Core Animation的CALayer子类，对捕捉视频数据进行实时预览。</p>\n<p>代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//创建session和输入输出</span><br><span class=\"line\">self.captureSession = [[AVCaptureSession alloc] init];                  // 1</span><br><span class=\"line\">    self.captureSession.sessionPreset = AVCaptureSessionPresetHigh;</span><br><span class=\"line\"> \t// Set up default camera device</span><br><span class=\"line\"> \tAVCaptureDevice *videoDevice =                                          // 2</span><br><span class=\"line\">        [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeVideo];</span><br><span class=\"line\">    AVCaptureDeviceInput *videoInput =                                      // 3</span><br><span class=\"line\">        [AVCaptureDeviceInput deviceInputWithDevice:videoDevice error:error];</span><br><span class=\"line\">    if (videoInput) &#123;</span><br><span class=\"line\">        if ([self.captureSession canAddInput:videoInput]) &#123;                 // 4</span><br><span class=\"line\">            [self.captureSession addInput:videoInput];</span><br><span class=\"line\">            self.activeVideoInput = videoInput;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        return NO;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // Setup default microphone</span><br><span class=\"line\">    AVCaptureDevice *audioDevice =                                          // 5</span><br><span class=\"line\">        [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeAudio];</span><br><span class=\"line\">    AVCaptureDeviceInput *audioInput =                                      // 6</span><br><span class=\"line\">        [AVCaptureDeviceInput deviceInputWithDevice:audioDevice error:error];</span><br><span class=\"line\">    if (audioInput) &#123;</span><br><span class=\"line\">        if ([self.captureSession canAddInput:audioInput]) &#123;                 // 7</span><br><span class=\"line\">            [self.captureSession addInput:audioInput];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        return NO;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> \t// Setup the still image output</span><br><span class=\"line\">    self.imageOutput = [[AVCaptureStillImageOutput alloc] init];            // 8</span><br><span class=\"line\">    self.imageOutput.outputSettings = @&#123;AVVideoCodecKey : AVVideoCodecJPEG&#125;;</span><br><span class=\"line\"> \tif ([self.captureSession canAddOutput:self.imageOutput]) &#123;</span><br><span class=\"line\"> \t\t[self.captureSession addOutput:self.imageOutput];</span><br><span class=\"line\"> \t&#125;</span><br><span class=\"line\">    return YES;</span><br></pre></td></tr></table></figure></p>\n<p>切换摄像头<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (AVCaptureDevice *)activeCamera &#123;                                         // 3</span><br><span class=\"line\">    return self.activeVideoInput.device;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (AVCaptureDevice *)inactiveCamera &#123;                                       // 4</span><br><span class=\"line\">    AVCaptureDevice *device = nil;</span><br><span class=\"line\">    if (self.cameraCount &gt; 1) &#123;</span><br><span class=\"line\">        if ([self activeCamera].position == AVCaptureDevicePositionBack) &#123;  // 5</span><br><span class=\"line\">            device = [self cameraWithPosition:AVCaptureDevicePositionFront];</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            device = [self cameraWithPosition:AVCaptureDevicePositionBack];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return device;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (BOOL)canSwitchCameras &#123;                                                  // 6</span><br><span class=\"line\">    return self.cameraCount &gt; 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (BOOL)switchCameras &#123;</span><br><span class=\"line\">    if (![self canSwitchCameras]) &#123;                                         // 1</span><br><span class=\"line\">        return NO;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    NSError *error;</span><br><span class=\"line\">    AVCaptureDevice *videoDevice = [self inactiveCamera];                   // 2</span><br><span class=\"line\">    AVCaptureDeviceInput *videoInput =</span><br><span class=\"line\">    [AVCaptureDeviceInput deviceInputWithDevice:videoDevice error:&amp;error];</span><br><span class=\"line\">    if (videoInput) &#123;</span><br><span class=\"line\">        [self.captureSession beginConfiguration];                           // 3</span><br><span class=\"line\">        [self.captureSession removeInput:self.activeVideoInput];            // 4</span><br><span class=\"line\">        if ([self.captureSession canAddInput:videoInput]) &#123;                 // 5</span><br><span class=\"line\">            [self.captureSession addInput:videoInput];</span><br><span class=\"line\">            self.activeVideoInput = videoInput;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            [self.captureSession addInput:self.activeVideoInput];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        [self.captureSession commitConfiguration];                          // 6</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        [self.delegate deviceConfigurationFailedWithError:error];           // 7</span><br><span class=\"line\">        return NO;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return YES;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>闪光灯<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (BOOL)cameraHasFlash &#123;</span><br><span class=\"line\">    return [[self activeCamera] hasFlash];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (AVCaptureFlashMode)flashMode &#123;</span><br><span class=\"line\">    return [[self activeCamera] flashMode];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (void)setFlashMode:(AVCaptureFlashMode)flashMode &#123;</span><br><span class=\"line\">    AVCaptureDevice *device = [self activeCamera];</span><br><span class=\"line\">    if (device.flashMode != flashMode &amp;&amp;</span><br><span class=\"line\">        [device isFlashModeSupported:flashMode]) &#123;</span><br><span class=\"line\">        NSError *error;</span><br><span class=\"line\">        if ([device lockForConfiguration:&amp;error]) &#123;</span><br><span class=\"line\">            device.flashMode = flashMode;</span><br><span class=\"line\">            [device unlockForConfiguration];</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            [self.delegate deviceConfigurationFailedWithError:error];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>手电筒<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (BOOL)cameraHasTorch &#123;</span><br><span class=\"line\">    return [[self activeCamera] hasTorch];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (AVCaptureTorchMode)torchMode &#123;</span><br><span class=\"line\">    return [[self activeCamera] torchMode];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (void)setTorchMode:(AVCaptureTorchMode)torchMode &#123;</span><br><span class=\"line\">    AVCaptureDevice *device = [self activeCamera];</span><br><span class=\"line\">    if (device.torchMode != torchMode &amp;&amp;</span><br><span class=\"line\">        [device isTorchModeSupported:torchMode]) &#123;</span><br><span class=\"line\">        NSError *error;</span><br><span class=\"line\">        if ([device lockForConfiguration:&amp;error]) &#123;</span><br><span class=\"line\">            device.torchMode = torchMode;</span><br><span class=\"line\">            [device unlockForConfiguration];</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            [self.delegate deviceConfigurationFailedWithError:error];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>对焦<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (BOOL)cameraSupportsTapToFocus &#123;                                          // 1</span><br><span class=\"line\">    return [[self activeCamera] isFocusPointOfInterestSupported];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (void)focusAtPoint:(CGPoint)point &#123;                                       // 2</span><br><span class=\"line\">    AVCaptureDevice *device = [self activeCamera];</span><br><span class=\"line\">    if (device.isFocusPointOfInterestSupported &amp;&amp;                           // 3</span><br><span class=\"line\">        [device isFocusModeSupported:AVCaptureFocusModeAutoFocus]) &#123;</span><br><span class=\"line\">        NSError *error;</span><br><span class=\"line\">        if ([device lockForConfiguration:&amp;error]) &#123;                         // 4</span><br><span class=\"line\">            device.focusPointOfInterest = point;</span><br><span class=\"line\">            device.focusMode = AVCaptureFocusModeAutoFocus;</span><br><span class=\"line\">            [device unlockForConfiguration];</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            [self.delegate deviceConfigurationFailedWithError:error];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>曝光<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (BOOL)cameraSupportsTapToExpose &#123;                                         // 1</span><br><span class=\"line\">    return [[self activeCamera] isExposurePointOfInterestSupported];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// Define KVO context pointer for observing &apos;adjustingExposure&quot; device property.</span><br><span class=\"line\">static const NSString *THCameraAdjustingExposureContext;</span><br><span class=\"line\">- (void)exposeAtPoint:(CGPoint)point &#123;</span><br><span class=\"line\">    AVCaptureDevice *device = [self activeCamera];</span><br><span class=\"line\">    AVCaptureExposureMode exposureMode =</span><br><span class=\"line\">    AVCaptureExposureModeContinuousAutoExposure;</span><br><span class=\"line\">    if (device.isExposurePointOfInterestSupported &amp;&amp;                        // 2</span><br><span class=\"line\">        [device isExposureModeSupported:exposureMode]) &#123;</span><br><span class=\"line\">        NSError *error;</span><br><span class=\"line\">        if ([device lockForConfiguration:&amp;error]) &#123;                         // 3</span><br><span class=\"line\">            device.exposurePointOfInterest = point;</span><br><span class=\"line\">            device.exposureMode = exposureMode;</span><br><span class=\"line\">            if ([device isExposureModeSupported:AVCaptureExposureModeLocked]) &#123;</span><br><span class=\"line\">                [device addObserver:self                                    // 4</span><br><span class=\"line\">                         forKeyPath:@&quot;adjustingExposure&quot;</span><br><span class=\"line\">                            options:NSKeyValueObservingOptionNew</span><br><span class=\"line\">                            context:&amp;THCameraAdjustingExposureContext];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            [device unlockForConfiguration];</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            [self.delegate deviceConfigurationFailedWithError:error];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (void)observeValueForKeyPath:(NSString *)keyPath</span><br><span class=\"line\">                      ofObject:(id)object</span><br><span class=\"line\">                        change:(NSDictionary *)change</span><br><span class=\"line\">                       context:(void *)context &#123;</span><br><span class=\"line\">    if (context == &amp;THCameraAdjustingExposureContext) &#123;                     // 5</span><br><span class=\"line\">        AVCaptureDevice *device = (AVCaptureDevice *)object;</span><br><span class=\"line\">        if (!device.isAdjustingExposure &amp;&amp;                                  // 6</span><br><span class=\"line\">            [device isExposureModeSupported:AVCaptureExposureModeLocked]) &#123;</span><br><span class=\"line\">            [object removeObserver:self                                    // 7</span><br><span class=\"line\">                        forKeyPath:@&quot;adjustingExposure&quot;</span><br><span class=\"line\">                           context:&amp;THCameraAdjustingExposureContext];</span><br><span class=\"line\">            dispatch_async(dispatch_get_main_queue(), ^&#123;                    // 8</span><br><span class=\"line\">                NSError *error;</span><br><span class=\"line\">                if ([device lockForConfiguration:&amp;error]) &#123;</span><br><span class=\"line\">                    device.exposureMode = AVCaptureExposureModeLocked;</span><br><span class=\"line\">                    [device unlockForConfiguration];</span><br><span class=\"line\">                &#125; else &#123;</span><br><span class=\"line\">                    [self.delegate deviceConfigurationFailedWithError:error];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        [super observeValueForKeyPath:keyPath</span><br><span class=\"line\">                             ofObject:object</span><br><span class=\"line\">                               change:change</span><br><span class=\"line\">                              context:context];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>AVCaptureStillImageOutput生成图片并保存<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)captureStillImage &#123;</span><br><span class=\"line\">    AVCaptureConnection *connection =                                   </span><br><span class=\"line\">        [self.imageOutput connectionWithMediaType:AVMediaTypeVideo];</span><br><span class=\"line\">    if (connection.isVideoOrientationSupported) &#123;                       </span><br><span class=\"line\">        connection.videoOrientation = [self currentVideoOrientation];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    id handler = ^(CMSampleBufferRef sampleBuffer, NSError *error) &#123;</span><br><span class=\"line\">        if (sampleBuffer != NULL) &#123;</span><br><span class=\"line\">            NSData *imageData =</span><br><span class=\"line\">                [AVCaptureStillImageOutput</span><br><span class=\"line\">                    jpegStillImageNSDataRepresentation:sampleBuffer];</span><br><span class=\"line\">            UIImage *image = [[UIImage alloc] initWithData:imageData];</span><br><span class=\"line\">            [self writeImageToAssetsLibrary:image];                         // 1</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            NSLog(@&quot;NULL sampleBuffer: %@&quot;, [error localizedDescription]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    // Capture still image</span><br><span class=\"line\">    [self.imageOutput captureStillImageAsynchronouslyFromConnection:connection</span><br><span class=\"line\">                                                  completionHandler:handler];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (void)writeImageToAssetsLibrary:(UIImage *)image &#123;</span><br><span class=\"line\">    ALAssetsLibrary *library = [[ALAssetsLibrary alloc] init];              // 2</span><br><span class=\"line\">    [library writeImageToSavedPhotosAlbum:image.CGImage                    // 3</span><br><span class=\"line\">                              orientation:(NSInteger)image.imageOrientation // 4</span><br><span class=\"line\">                          completionBlock:^(NSURL *assetURL, NSError *error) &#123;</span><br><span class=\"line\">                              if (!error) &#123;</span><br><span class=\"line\">                                  [self postThumbnailNotifification:image]; // 5</span><br><span class=\"line\">                              &#125; else &#123;</span><br><span class=\"line\">                                  id message = [error localizedDescription];</span><br><span class=\"line\">                                  NSLog(@&quot;Error: %@&quot;, message);</span><br><span class=\"line\">                              &#125;</span><br><span class=\"line\">                          &#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>AVCaptureMovieFileOutput生成文件并保存<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/开始录制</span><br><span class=\"line\">[self.movieOutput startRecordingToOutputFileURL:self.outputURL recordingDelegate:self];</span><br><span class=\"line\"></span><br><span class=\"line\">//停止录制</span><br><span class=\"line\">[self.movieOutput stopRecording];</span><br><span class=\"line\"></span><br><span class=\"line\">#pragma mark - AVCaptureFileOutputRecordingDelegate - --</span><br><span class=\"line\">- (void)captureOutput:(AVCaptureFileOutput *)captureOutput</span><br><span class=\"line\">didFinishRecordingToOutputFileAtURL:(NSURL *)outputFileURL</span><br><span class=\"line\">      fromConnections:(NSArray *)connections</span><br><span class=\"line\">                error:(NSError *)error &#123;</span><br><span class=\"line\"> \tif (error) &#123;                                                            // 1</span><br><span class=\"line\">        [self.delegate mediaCaptureFailedWithError:error];</span><br><span class=\"line\"> \t&#125; else &#123;</span><br><span class=\"line\">        [self writeVideoToAssetsLibrary:[self.outputURL copy]];</span><br><span class=\"line\"> \t&#125;</span><br><span class=\"line\">    self.outputURL = nil;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)writeVideoToAssetsLibrary:(NSURL *)videoURL &#123;</span><br><span class=\"line\">    ALAssetsLibrary *library = [[ALAssetsLibrary alloc] init];              // 2</span><br><span class=\"line\">    if ([library videoAtPathIsCompatibleWithSavedPhotosAlbum:videoURL]) &#123;   // 3</span><br><span class=\"line\">        ALAssetsLibraryWriteVideoCompletionBlock completionBlock;</span><br><span class=\"line\">        completionBlock = ^(NSURL *assetURL, NSError *error)&#123;               // 4</span><br><span class=\"line\">            if (error) &#123;</span><br><span class=\"line\">                [self.delegate assetLibraryWriteFailedWithError:error];</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                [self generateThumbnailForVideoAtURL:videoURL];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        [library writeVideoAtPathToSavedPhotosAlbum:videoURL                // 8</span><br><span class=\"line\">                                    completionBlock:completionBlock];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"AVFoundation学习笔记三  AVAudioSession","author":"Cyrus","date":"2018-10-25T02:49:00.000Z","_content":"注：\n文章部分内容来自：[https://www.jianshu.com/p/3e0a399380df](https://www.jianshu.com/p/3e0a399380df)\n及参考《AVFoundation 开发秘籍》\n\n#### 一、AVAudioSession是用来干嘛的？\n\n简单来说AVAudioSession是用来控制app的音频行为，比如插拔耳机后是否继续播放音频、接电话后返回是否继续播放、是否和其他音频数据混音等。当你遇到:\n\n* 是进行录音还是播放？\n* 当系统静音键按下时该如何表现？\n* 是从扬声器还是从听筒里面播放声音？\n* 插拔耳机后如何表现？\n* 来电话/闹钟响了后如何表现？\n* 其他音频App启动后如何表现？\n* ...\n这些场景的时候，就可以考虑一下“AVAudioSession”了。\n\n#### 二、AVAudioSession是如何控制音频行为的？\nAVFoundation定义了7种分类（category）来描述应用程序所使用的音频行为。\n![](session_category.png)\n\n7种类别各自的行为总结如下：\n* ***AVAudioSessionCategoryAmbient***： 只用于播放音乐时，并且可以和QQ音乐同时播放，比如玩游戏的时候还想听QQ音乐的歌，那么把游戏播放背景音就设置成这种类别。同时，当用户锁屏或者静音时也会随着静音，这种类别基本使用所有App的背景场景。\n* ***AVAudioSessionCategorySoloAmbient(默认)***：也是只用于播放,但是和***\"AVAudioSessionCategoryAmbient\"***不同的是，用了它就别想听QQ音乐了，比如不希望QQ音乐干扰的App，类似节奏大师。同样当用户锁屏或者静音时也会随着静音，锁屏了就玩不了节奏大师了。\n* ***AVAudioSessionCategoryPlayback***：如果锁屏了还想听声音怎么办？用这个类别，比如App本身就是播放器，同时当App播放时，其他类似QQ音乐就不能播放了。所以这种类别一般用于播放器类App\n* ***AVAudioSessionCategoryRecord***：有了播放器，肯定要录音机，比如微信语音的录制，就要用到这个类别，既然要安静的录音，肯定不希望有QQ音乐了，所以其他播放声音会中断。想想微信语音的场景，就知道什么时候用他了。\n* ***AVAudioSessionCategoryPlayAndRecord***：如果既想播放又想录制该用什么模式呢？比如VoIP，打电话这种场景，PlayAndRecord就是专门为这样的场景设计的 。\n* ***AVAudioSessionCategoryMultiRoute***：想象一个DJ用的App，手机连着HDMI到扬声器播放当前的音乐，然后耳机里面播放下一曲，这种常人不理解的场景，这个类别可以支持多个设备输入输出。\n* ***AVAudioSessionCategoryAudioProcessing***: 主要用于音频格式处理，一般可以配合AudioUnit进行使用\n\n#### 三、如何设置AVAudioSession\n\n获取AVAudioSession单例,设置类别并激活。音频会话通常会在应用程序启动时进行一次配置，所以可以将代码写在- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions：中。\n```\nAVAudioSession *session = [AVAudioSession sharedInstance];\nNSError *error;\n    if (![session setCategory:AVAudioSessionCategoryPlayback error:&error]) {\n        NSLog(@\"Category Error:%@\", [error localizedDescription]);\n    }\n    if (![session setActive:YES error:&error]) {\n        NSLog(@\"Activation Error:%@\", [error localizedDescription]);\n    }\n```\n\n```\n因为AVAudioSession会影响其他App的表现，当自己App的Session被激活，其他App的就会被解除激活，如何要让自己的Session解除激活后恢复其他App Session的激活状态呢？\n\n此时可以使用：\n\n(BOOL)setActive:(BOOL)active\nwithOptions:(AVAudioSessionSetActiveOptions)options\nerror:(NSError * _Nullable *)outError;\n这里的options传入AVAudioSessionSetActiveOptionNotifyOthersOnDeactivation 即可。\n\n当然，也可以通过otherAudioPlaying变量来提前判断当前是否有其他App在播放音频。\n```\n\n#### 四、如何根据自己需求调整AVAudioSession\nAVAudioSession的设置可以分三个层级\n```\nCategory确定基调---> options微调 + mode微调\n```\n\n##### Category的选项options\n上面介绍的这个七大类别，可以认为是设定了七种主场景，而这七类肯定是不能满足开发者所有的需求的。CoreAudio提供的方法是，首先定下七种的一种基调，然后在进行微调。CoreAudio为每种Category都提供了些许选项来进行微调。\n在设置完类别后，可以通过\n```\n@property(readonly) AVAudioSessionCategoryOptions categoryOptions;\n```\n属性，查看当前类别设置了哪些选项，注意这里的返回值是AVAudioSessionCategoryOptions，实际是多个options的“|”运算。默认情况下是0。\n\n| 选项 | 适用类别 | 作用 |\n| ----- | ----- | ----- |\n| AVAudioSessionCategoryOptionMixWithOthers | AVAudioSessionCategoryPlayAndRecord, AVAudioSessionCategoryPlayback, and AVAudioSessionCategoryMultiRoute | 是否可以和其他后台App进行混音 |\n| AVAudioSessionCategoryOptionDuckOthers | AVAudioSessionCategoryAmbient, AVAudioSessionCategoryPlayAndRecord, AVAudioSessionCategoryPlayback, and AVAudioSessionCategoryMultiRoute | 是否压低其他App声音 |\n| AVAudioSessionCategoryOptionAllowBluetooth | AVAudioSessionCategoryRecord and AVAudioSessionCategoryPlayAndRecord | 是否支持蓝牙耳机 |\n| AVAudioSessionCategoryOptionDefaultToSpeaker | AVAudioSessionCategoryPlayAndRecord | 是否默认用免提声音 |\n\n来看每个选项的基本作用：\n* AVAudioSessionCategoryOptionMixWithOthers ： 如果确实用的AVAudioSessionCategoryPlayback实现的一个背景音，但是呢，又想和QQ音乐并存，那么可以在AVAudioSessionCategoryPlayback类别下在设置这个选项，就可以实现共存了。\n* AVAudioSessionCategoryOptionDuckOthers：在实时通话的场景，比如QQ音乐，当进行视频通话的时候，会发现QQ音乐自动声音降低了，此时就是通过设置这个选项来对其他音乐App进行了压制。\n* AVAudioSessionCategoryOptionAllowBluetooth：如果要支持蓝牙耳机电话，则需要设置这个选项\n* AVAudioSessionCategoryOptionDefaultToSpeaker： 如果在VoIP模式下，希望默认打开免提功能，需要设置这个选项\n\n通过接口：\n```\n- (BOOL)setCategory:(NSString *)category withOptions:(AVAudioSessionCategoryOptions)options error:(NSError **)outError\n```\n来对当前的类别进行选项的设置。\n\n#### 七大模式（Mode）\n\n刚讲完七大类别，现在再来七大模式。通过上面的七大类别，我们基本覆盖了常用的主场景，在每个主场景中可以通过Option进行微调。为此CoreAudio提供了七大比较常见微调后的子场景。叫做各个类别的模式。\n\n| mode | 适用的类别 | 场景 |\n| -- | -- | -- |\n| AVAudioSessionModeDefault | 所有类别 | 默认的模式 |\n| AVAudioSessionModeVoiceChat | AVAudioSessionCategoryPlayAndRecord | VoIP |\n| AVAudioSessionModeGameChat | AVAudioSessionCategoryPlayAndRecord | 游戏录制，由GKVoiceChat自动设置，无需手动调用 |\n| AVAudioSessionModeVideoRecording | AVAudioSessionCategoryPlayAndRecord AVAudioSessionCategoryRecord | 录制视频时 |\n| AVAudioSessionModeMoviePlayback | AVAudioSessionCategoryPlayback | 视频播放 |\n| AVAudioSessionModeMeasurement | AVAudioSessionCategoryPlayAndRecord AVAudioSessionCategoryRecord AVAudioSessionCategoryPlayback | 最小系统 |\n| AVAudioSessionModeVideoChat | AVAudioSessionCategoryPlayAndRecord | 视频通话 |\n\n每个模式有其适用的类别，所以，并不是有“七七 四十九”种组合。如果当前处于的类别下没有这个模式，那么是设置不成功的。设置完Category后可以通过：\n```\n@property(readonly) NSArray<NSString *> *availableModes;\n```\n属性，查看其支持哪些属性，做合法性校验。\n\n来看具体应用：\n\n* AVAudioSessionModeDefault： 每种类别默认的就是这个模式，所有要想还原的话，就设置成这个模式。\n* AVAudioSessionModeVoiceChat：主要用于VoIP场景，此时系统会选择最佳的输入设备，比如插上耳机就使用耳机上的麦克风进行采集。此时有个副作用，他会设置类别的选项为\"AVAudioSessionCategoryOptionAllowBluetooth\"从而支持蓝牙耳机。\n* AVAudioSessionModeVideoChat ： 主要用于视频通话，比如QQ视频、FaceTime。时系统也会选择最佳的输入设备，比如插上耳机就使用耳机上的麦克风进行采集并且会设置类别的选项为\"AVAudioSessionCategoryOptionAllowBluetooth\" 和 \"AVAudioSessionCategoryOptionDefaultToSpeaker\"。\n* AVAudioSessionModeGameChat ： 适用于游戏App的采集和播放，比如“GKVoiceChat”对象，一般不需要手动设置\n另外几种和音频APP关系不大，一般我们只需要关注VoIP或者视频通话即可。\n\n通过调用：\n```\n- (BOOL)setMode:(NSString *)mode error:(NSError **)outError\n```\n可以在设置Category之后再设置模式。\n\n#### 系统中断响应\n<font color=color=#ff0000>AVAudioSessionInterruptionNotification</font>:电话、闹铃响等中断的通知,其回调回来的userInfo主要包含两个键：\n\n* AVAudioSessionInterruptionTypeKey:取值为 <font color=#ff0000> AVAudioSessionInterruptionTypeBegan </font>:表示中断开始，我们应该暂停播放和采集，取值为<font color=color=#ff0000>AVAudioSessionInterruptionTypeEnded</font>表示中断结束，我们可以继续播放和采集。\n* AVAudioSessionInterruptionOptionKey:当前只有一种值<font color=color=#ff0000>AVAudioSessionInterruptionOptionShouldResume</font>:表示此时也应该恢复继续播放和采集。\n\n示例如下：\n\n```\n//注册通知\nNSNotificationCenter *nsnc = [NSNotificationCenter defaultCenter];\n        [nsnc addObserver:self selector:@selector(handleInterruption:) name:AVAudioSessionInterruptionNotification object:[AVAudioSession sharedInstance]];\n        \n//处理回调\n- (void)handleInterruption: (NSNotification *)notification\n{\n    NSDictionary *info = notification.userInfo;\n    AVAudioSessionInterruptionType type = [info[AVAudioSessionInterruptionTypeKey] unsignedIntegerValue];\n    \n    if (type == AVAudioSessionInterruptionTypeBegan) {\n        //Handle AVAudioSessionInterruptionTypeBegan\n    } else {\n       // Handle AVAudioSessionInterruptionTypeEnd\n        AVAudioSessionInterruptionOptions options = [info[AVAudioSessionInterruptionOptionKey] unsignedIntegerValue];\n        if (options == AVAudioSessionInterruptionOptionShouldResume) {\n        \n        }\n    }\n}\n```\n\n<font color=#ff0000>AVAudioSessionSilenceSecondaryAudioHintNotification</font>:其他App占据AudioSession的通知，其回调回来的userInfo键为：\n\n```\nAVAudioSessionSilenceSecondaryAudioHintTypeKey\n```\n\n可能包含的值\n* <font color=color=#ff0000>AVAudioSessionSilenceSecondaryAudioHintTypeBegin</font>:表示其他App开始占据Session\n* <font color=color=#ff0000>AVAudioSessionInterruptionTypeEnded</font>:表示其他App开始释放Session\n\n\n#### 外设改变\n\n默认情况下，AudioSession会在App启动时选择一个最优的输出方案，比如插入耳机的时候，就用耳机。但是这个过程中，用户可能拔出耳机，我们App要如何感知这样的情况呢？\n\n<font color=color=#ff0000>**AVAudioSessionRouteChangeNotification**</font> : 外设改变时通知，在NSNotificationCenter中对其进行注册，userInfo中有键：\n* AVAudioSessionRouteChangeReasonKey ： 表示改变的原因\n\n| 枚举值 | 意义 |\n| ----- | ----- |\n| AVAudioSessionRouteChangeReasonUnknown | 未知原因 |\n| AVAudioSessionRouteChangeReasonNewDeviceAvailable | 有新设备可用 |\n| AVAudioSessionRouteChangeReasonOldDeviceUnavailable | 老设备不可用 |\n| AVAudioSessionRouteChangeReasonCategoryChange | 类别改变了 |\n| AVAudioSessionRouteChangeReasonOverride | App重置了输出设置 |\n| AVAudioSessionRouteChangeReasonWakeFromSleep | 从睡眠状态呼醒 |\n| AVAudioSessionRouteChangeReasonNoSuitableRouteForCategory | 当前Category下没有合适的设备 |\n| AVAudioSessionRouteChangeReasonRouteConfigurationChange | Rotuer的配置改变了 |\n\n示例代码：\n```\nNSNotificationCenter *nsnc = [NSNotificationCenter defaultCenter];\n[nsnc addObserver:self selector:@selector(handleRouteChange:) name:AVAudioSessionRouteChangeNotification object:[AVAudioSession sharedInstance]];\n\n- (void)handleRouteChange:(NSNotification *)notification\n{\n    NSDictionary *info = notification.userInfo;\n    AVAudioSessionRouteChangeReason reason = [info[AVAudioSessionRouteChangeReasonKey] unsignedIntegerValue];\n    if (reason == AVAudioSessionRouteChangeReasonOldDeviceUnavailable) {\n        //如果拔出耳机，停止播放\n        AVAudioSessionRouteDescription *previousRoute = info[AVAudioSessionRouteChangePreviousRouteKey];\n        AVAudioSessionPortDescription *previousOutput = previousRoute.outputs[0];\n        NSString *portType = previousOutput.portType;\n        if ([portType isEqualToString:AVAudioSessionPortHeadphones]) {\n            [self stop];\n        }\n    }\n}\n```","source":"_posts/AVFoundation学习笔记二-AVAudioSession.md","raw":"title: AVFoundation学习笔记三  AVAudioSession\nauthor: Cyrus\ntags: []\ncategories:\n  - AVFoundation\ndate: 2018-10-25 10:49:00\n---\n注：\n文章部分内容来自：[https://www.jianshu.com/p/3e0a399380df](https://www.jianshu.com/p/3e0a399380df)\n及参考《AVFoundation 开发秘籍》\n\n#### 一、AVAudioSession是用来干嘛的？\n\n简单来说AVAudioSession是用来控制app的音频行为，比如插拔耳机后是否继续播放音频、接电话后返回是否继续播放、是否和其他音频数据混音等。当你遇到:\n\n* 是进行录音还是播放？\n* 当系统静音键按下时该如何表现？\n* 是从扬声器还是从听筒里面播放声音？\n* 插拔耳机后如何表现？\n* 来电话/闹钟响了后如何表现？\n* 其他音频App启动后如何表现？\n* ...\n这些场景的时候，就可以考虑一下“AVAudioSession”了。\n\n#### 二、AVAudioSession是如何控制音频行为的？\nAVFoundation定义了7种分类（category）来描述应用程序所使用的音频行为。\n![](session_category.png)\n\n7种类别各自的行为总结如下：\n* ***AVAudioSessionCategoryAmbient***： 只用于播放音乐时，并且可以和QQ音乐同时播放，比如玩游戏的时候还想听QQ音乐的歌，那么把游戏播放背景音就设置成这种类别。同时，当用户锁屏或者静音时也会随着静音，这种类别基本使用所有App的背景场景。\n* ***AVAudioSessionCategorySoloAmbient(默认)***：也是只用于播放,但是和***\"AVAudioSessionCategoryAmbient\"***不同的是，用了它就别想听QQ音乐了，比如不希望QQ音乐干扰的App，类似节奏大师。同样当用户锁屏或者静音时也会随着静音，锁屏了就玩不了节奏大师了。\n* ***AVAudioSessionCategoryPlayback***：如果锁屏了还想听声音怎么办？用这个类别，比如App本身就是播放器，同时当App播放时，其他类似QQ音乐就不能播放了。所以这种类别一般用于播放器类App\n* ***AVAudioSessionCategoryRecord***：有了播放器，肯定要录音机，比如微信语音的录制，就要用到这个类别，既然要安静的录音，肯定不希望有QQ音乐了，所以其他播放声音会中断。想想微信语音的场景，就知道什么时候用他了。\n* ***AVAudioSessionCategoryPlayAndRecord***：如果既想播放又想录制该用什么模式呢？比如VoIP，打电话这种场景，PlayAndRecord就是专门为这样的场景设计的 。\n* ***AVAudioSessionCategoryMultiRoute***：想象一个DJ用的App，手机连着HDMI到扬声器播放当前的音乐，然后耳机里面播放下一曲，这种常人不理解的场景，这个类别可以支持多个设备输入输出。\n* ***AVAudioSessionCategoryAudioProcessing***: 主要用于音频格式处理，一般可以配合AudioUnit进行使用\n\n#### 三、如何设置AVAudioSession\n\n获取AVAudioSession单例,设置类别并激活。音频会话通常会在应用程序启动时进行一次配置，所以可以将代码写在- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions：中。\n```\nAVAudioSession *session = [AVAudioSession sharedInstance];\nNSError *error;\n    if (![session setCategory:AVAudioSessionCategoryPlayback error:&error]) {\n        NSLog(@\"Category Error:%@\", [error localizedDescription]);\n    }\n    if (![session setActive:YES error:&error]) {\n        NSLog(@\"Activation Error:%@\", [error localizedDescription]);\n    }\n```\n\n```\n因为AVAudioSession会影响其他App的表现，当自己App的Session被激活，其他App的就会被解除激活，如何要让自己的Session解除激活后恢复其他App Session的激活状态呢？\n\n此时可以使用：\n\n(BOOL)setActive:(BOOL)active\nwithOptions:(AVAudioSessionSetActiveOptions)options\nerror:(NSError * _Nullable *)outError;\n这里的options传入AVAudioSessionSetActiveOptionNotifyOthersOnDeactivation 即可。\n\n当然，也可以通过otherAudioPlaying变量来提前判断当前是否有其他App在播放音频。\n```\n\n#### 四、如何根据自己需求调整AVAudioSession\nAVAudioSession的设置可以分三个层级\n```\nCategory确定基调---> options微调 + mode微调\n```\n\n##### Category的选项options\n上面介绍的这个七大类别，可以认为是设定了七种主场景，而这七类肯定是不能满足开发者所有的需求的。CoreAudio提供的方法是，首先定下七种的一种基调，然后在进行微调。CoreAudio为每种Category都提供了些许选项来进行微调。\n在设置完类别后，可以通过\n```\n@property(readonly) AVAudioSessionCategoryOptions categoryOptions;\n```\n属性，查看当前类别设置了哪些选项，注意这里的返回值是AVAudioSessionCategoryOptions，实际是多个options的“|”运算。默认情况下是0。\n\n| 选项 | 适用类别 | 作用 |\n| ----- | ----- | ----- |\n| AVAudioSessionCategoryOptionMixWithOthers | AVAudioSessionCategoryPlayAndRecord, AVAudioSessionCategoryPlayback, and AVAudioSessionCategoryMultiRoute | 是否可以和其他后台App进行混音 |\n| AVAudioSessionCategoryOptionDuckOthers | AVAudioSessionCategoryAmbient, AVAudioSessionCategoryPlayAndRecord, AVAudioSessionCategoryPlayback, and AVAudioSessionCategoryMultiRoute | 是否压低其他App声音 |\n| AVAudioSessionCategoryOptionAllowBluetooth | AVAudioSessionCategoryRecord and AVAudioSessionCategoryPlayAndRecord | 是否支持蓝牙耳机 |\n| AVAudioSessionCategoryOptionDefaultToSpeaker | AVAudioSessionCategoryPlayAndRecord | 是否默认用免提声音 |\n\n来看每个选项的基本作用：\n* AVAudioSessionCategoryOptionMixWithOthers ： 如果确实用的AVAudioSessionCategoryPlayback实现的一个背景音，但是呢，又想和QQ音乐并存，那么可以在AVAudioSessionCategoryPlayback类别下在设置这个选项，就可以实现共存了。\n* AVAudioSessionCategoryOptionDuckOthers：在实时通话的场景，比如QQ音乐，当进行视频通话的时候，会发现QQ音乐自动声音降低了，此时就是通过设置这个选项来对其他音乐App进行了压制。\n* AVAudioSessionCategoryOptionAllowBluetooth：如果要支持蓝牙耳机电话，则需要设置这个选项\n* AVAudioSessionCategoryOptionDefaultToSpeaker： 如果在VoIP模式下，希望默认打开免提功能，需要设置这个选项\n\n通过接口：\n```\n- (BOOL)setCategory:(NSString *)category withOptions:(AVAudioSessionCategoryOptions)options error:(NSError **)outError\n```\n来对当前的类别进行选项的设置。\n\n#### 七大模式（Mode）\n\n刚讲完七大类别，现在再来七大模式。通过上面的七大类别，我们基本覆盖了常用的主场景，在每个主场景中可以通过Option进行微调。为此CoreAudio提供了七大比较常见微调后的子场景。叫做各个类别的模式。\n\n| mode | 适用的类别 | 场景 |\n| -- | -- | -- |\n| AVAudioSessionModeDefault | 所有类别 | 默认的模式 |\n| AVAudioSessionModeVoiceChat | AVAudioSessionCategoryPlayAndRecord | VoIP |\n| AVAudioSessionModeGameChat | AVAudioSessionCategoryPlayAndRecord | 游戏录制，由GKVoiceChat自动设置，无需手动调用 |\n| AVAudioSessionModeVideoRecording | AVAudioSessionCategoryPlayAndRecord AVAudioSessionCategoryRecord | 录制视频时 |\n| AVAudioSessionModeMoviePlayback | AVAudioSessionCategoryPlayback | 视频播放 |\n| AVAudioSessionModeMeasurement | AVAudioSessionCategoryPlayAndRecord AVAudioSessionCategoryRecord AVAudioSessionCategoryPlayback | 最小系统 |\n| AVAudioSessionModeVideoChat | AVAudioSessionCategoryPlayAndRecord | 视频通话 |\n\n每个模式有其适用的类别，所以，并不是有“七七 四十九”种组合。如果当前处于的类别下没有这个模式，那么是设置不成功的。设置完Category后可以通过：\n```\n@property(readonly) NSArray<NSString *> *availableModes;\n```\n属性，查看其支持哪些属性，做合法性校验。\n\n来看具体应用：\n\n* AVAudioSessionModeDefault： 每种类别默认的就是这个模式，所有要想还原的话，就设置成这个模式。\n* AVAudioSessionModeVoiceChat：主要用于VoIP场景，此时系统会选择最佳的输入设备，比如插上耳机就使用耳机上的麦克风进行采集。此时有个副作用，他会设置类别的选项为\"AVAudioSessionCategoryOptionAllowBluetooth\"从而支持蓝牙耳机。\n* AVAudioSessionModeVideoChat ： 主要用于视频通话，比如QQ视频、FaceTime。时系统也会选择最佳的输入设备，比如插上耳机就使用耳机上的麦克风进行采集并且会设置类别的选项为\"AVAudioSessionCategoryOptionAllowBluetooth\" 和 \"AVAudioSessionCategoryOptionDefaultToSpeaker\"。\n* AVAudioSessionModeGameChat ： 适用于游戏App的采集和播放，比如“GKVoiceChat”对象，一般不需要手动设置\n另外几种和音频APP关系不大，一般我们只需要关注VoIP或者视频通话即可。\n\n通过调用：\n```\n- (BOOL)setMode:(NSString *)mode error:(NSError **)outError\n```\n可以在设置Category之后再设置模式。\n\n#### 系统中断响应\n<font color=color=#ff0000>AVAudioSessionInterruptionNotification</font>:电话、闹铃响等中断的通知,其回调回来的userInfo主要包含两个键：\n\n* AVAudioSessionInterruptionTypeKey:取值为 <font color=#ff0000> AVAudioSessionInterruptionTypeBegan </font>:表示中断开始，我们应该暂停播放和采集，取值为<font color=color=#ff0000>AVAudioSessionInterruptionTypeEnded</font>表示中断结束，我们可以继续播放和采集。\n* AVAudioSessionInterruptionOptionKey:当前只有一种值<font color=color=#ff0000>AVAudioSessionInterruptionOptionShouldResume</font>:表示此时也应该恢复继续播放和采集。\n\n示例如下：\n\n```\n//注册通知\nNSNotificationCenter *nsnc = [NSNotificationCenter defaultCenter];\n        [nsnc addObserver:self selector:@selector(handleInterruption:) name:AVAudioSessionInterruptionNotification object:[AVAudioSession sharedInstance]];\n        \n//处理回调\n- (void)handleInterruption: (NSNotification *)notification\n{\n    NSDictionary *info = notification.userInfo;\n    AVAudioSessionInterruptionType type = [info[AVAudioSessionInterruptionTypeKey] unsignedIntegerValue];\n    \n    if (type == AVAudioSessionInterruptionTypeBegan) {\n        //Handle AVAudioSessionInterruptionTypeBegan\n    } else {\n       // Handle AVAudioSessionInterruptionTypeEnd\n        AVAudioSessionInterruptionOptions options = [info[AVAudioSessionInterruptionOptionKey] unsignedIntegerValue];\n        if (options == AVAudioSessionInterruptionOptionShouldResume) {\n        \n        }\n    }\n}\n```\n\n<font color=#ff0000>AVAudioSessionSilenceSecondaryAudioHintNotification</font>:其他App占据AudioSession的通知，其回调回来的userInfo键为：\n\n```\nAVAudioSessionSilenceSecondaryAudioHintTypeKey\n```\n\n可能包含的值\n* <font color=color=#ff0000>AVAudioSessionSilenceSecondaryAudioHintTypeBegin</font>:表示其他App开始占据Session\n* <font color=color=#ff0000>AVAudioSessionInterruptionTypeEnded</font>:表示其他App开始释放Session\n\n\n#### 外设改变\n\n默认情况下，AudioSession会在App启动时选择一个最优的输出方案，比如插入耳机的时候，就用耳机。但是这个过程中，用户可能拔出耳机，我们App要如何感知这样的情况呢？\n\n<font color=color=#ff0000>**AVAudioSessionRouteChangeNotification**</font> : 外设改变时通知，在NSNotificationCenter中对其进行注册，userInfo中有键：\n* AVAudioSessionRouteChangeReasonKey ： 表示改变的原因\n\n| 枚举值 | 意义 |\n| ----- | ----- |\n| AVAudioSessionRouteChangeReasonUnknown | 未知原因 |\n| AVAudioSessionRouteChangeReasonNewDeviceAvailable | 有新设备可用 |\n| AVAudioSessionRouteChangeReasonOldDeviceUnavailable | 老设备不可用 |\n| AVAudioSessionRouteChangeReasonCategoryChange | 类别改变了 |\n| AVAudioSessionRouteChangeReasonOverride | App重置了输出设置 |\n| AVAudioSessionRouteChangeReasonWakeFromSleep | 从睡眠状态呼醒 |\n| AVAudioSessionRouteChangeReasonNoSuitableRouteForCategory | 当前Category下没有合适的设备 |\n| AVAudioSessionRouteChangeReasonRouteConfigurationChange | Rotuer的配置改变了 |\n\n示例代码：\n```\nNSNotificationCenter *nsnc = [NSNotificationCenter defaultCenter];\n[nsnc addObserver:self selector:@selector(handleRouteChange:) name:AVAudioSessionRouteChangeNotification object:[AVAudioSession sharedInstance]];\n\n- (void)handleRouteChange:(NSNotification *)notification\n{\n    NSDictionary *info = notification.userInfo;\n    AVAudioSessionRouteChangeReason reason = [info[AVAudioSessionRouteChangeReasonKey] unsignedIntegerValue];\n    if (reason == AVAudioSessionRouteChangeReasonOldDeviceUnavailable) {\n        //如果拔出耳机，停止播放\n        AVAudioSessionRouteDescription *previousRoute = info[AVAudioSessionRouteChangePreviousRouteKey];\n        AVAudioSessionPortDescription *previousOutput = previousRoute.outputs[0];\n        NSString *portType = previousOutput.portType;\n        if ([portType isEqualToString:AVAudioSessionPortHeadphones]) {\n            [self stop];\n        }\n    }\n}\n```","slug":"AVFoundation学习笔记二-AVAudioSession","published":1,"updated":"2019-07-09T08:13:34.922Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyzlbt9d002e0j668mct0214","content":"<p>注：<br>文章部分内容来自：<a href=\"https://www.jianshu.com/p/3e0a399380df\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/3e0a399380df</a><br>及参考《AVFoundation 开发秘籍》</p>\n<h4 id=\"一、AVAudioSession是用来干嘛的？\"><a href=\"#一、AVAudioSession是用来干嘛的？\" class=\"headerlink\" title=\"一、AVAudioSession是用来干嘛的？\"></a>一、AVAudioSession是用来干嘛的？</h4><p>简单来说AVAudioSession是用来控制app的音频行为，比如插拔耳机后是否继续播放音频、接电话后返回是否继续播放、是否和其他音频数据混音等。当你遇到:</p>\n<ul>\n<li>是进行录音还是播放？</li>\n<li>当系统静音键按下时该如何表现？</li>\n<li>是从扬声器还是从听筒里面播放声音？</li>\n<li>插拔耳机后如何表现？</li>\n<li>来电话/闹钟响了后如何表现？</li>\n<li>其他音频App启动后如何表现？</li>\n<li>…<br>这些场景的时候，就可以考虑一下“AVAudioSession”了。</li>\n</ul>\n<h4 id=\"二、AVAudioSession是如何控制音频行为的？\"><a href=\"#二、AVAudioSession是如何控制音频行为的？\" class=\"headerlink\" title=\"二、AVAudioSession是如何控制音频行为的？\"></a>二、AVAudioSession是如何控制音频行为的？</h4><p>AVFoundation定义了7种分类（category）来描述应用程序所使用的音频行为。<br><img src=\"//www.cyrus.fun/2018/10/25/AVFoundation学习笔记二-AVAudioSession/session_category.png\" alt=\"\"></p>\n<p>7种类别各自的行为总结如下：</p>\n<ul>\n<li><strong><em>AVAudioSessionCategoryAmbient</em></strong>： 只用于播放音乐时，并且可以和QQ音乐同时播放，比如玩游戏的时候还想听QQ音乐的歌，那么把游戏播放背景音就设置成这种类别。同时，当用户锁屏或者静音时也会随着静音，这种类别基本使用所有App的背景场景。</li>\n<li><strong><em>AVAudioSessionCategorySoloAmbient(默认)</em></strong>：也是只用于播放,但是和<strong><em>“AVAudioSessionCategoryAmbient”</em></strong>不同的是，用了它就别想听QQ音乐了，比如不希望QQ音乐干扰的App，类似节奏大师。同样当用户锁屏或者静音时也会随着静音，锁屏了就玩不了节奏大师了。</li>\n<li><strong><em>AVAudioSessionCategoryPlayback</em></strong>：如果锁屏了还想听声音怎么办？用这个类别，比如App本身就是播放器，同时当App播放时，其他类似QQ音乐就不能播放了。所以这种类别一般用于播放器类App</li>\n<li><strong><em>AVAudioSessionCategoryRecord</em></strong>：有了播放器，肯定要录音机，比如微信语音的录制，就要用到这个类别，既然要安静的录音，肯定不希望有QQ音乐了，所以其他播放声音会中断。想想微信语音的场景，就知道什么时候用他了。</li>\n<li><strong><em>AVAudioSessionCategoryPlayAndRecord</em></strong>：如果既想播放又想录制该用什么模式呢？比如VoIP，打电话这种场景，PlayAndRecord就是专门为这样的场景设计的 。</li>\n<li><strong><em>AVAudioSessionCategoryMultiRoute</em></strong>：想象一个DJ用的App，手机连着HDMI到扬声器播放当前的音乐，然后耳机里面播放下一曲，这种常人不理解的场景，这个类别可以支持多个设备输入输出。</li>\n<li><strong><em>AVAudioSessionCategoryAudioProcessing</em></strong>: 主要用于音频格式处理，一般可以配合AudioUnit进行使用</li>\n</ul>\n<h4 id=\"三、如何设置AVAudioSession\"><a href=\"#三、如何设置AVAudioSession\" class=\"headerlink\" title=\"三、如何设置AVAudioSession\"></a>三、如何设置AVAudioSession</h4><p>获取AVAudioSession单例,设置类别并激活。音频会话通常会在应用程序启动时进行一次配置，所以可以将代码写在- (BOOL)application:(UIApplication <em>)application didFinishLaunchingWithOptions:(NSDictionary </em>)launchOptions：中。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AVAudioSession *session = [AVAudioSession sharedInstance];</span><br><span class=\"line\">NSError *error;</span><br><span class=\"line\">    if (![session setCategory:AVAudioSessionCategoryPlayback error:&amp;error]) &#123;</span><br><span class=\"line\">        NSLog(@&quot;Category Error:%@&quot;, [error localizedDescription]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (![session setActive:YES error:&amp;error]) &#123;</span><br><span class=\"line\">        NSLog(@&quot;Activation Error:%@&quot;, [error localizedDescription]);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">因为AVAudioSession会影响其他App的表现，当自己App的Session被激活，其他App的就会被解除激活，如何要让自己的Session解除激活后恢复其他App Session的激活状态呢？</span><br><span class=\"line\"></span><br><span class=\"line\">此时可以使用：</span><br><span class=\"line\"></span><br><span class=\"line\">(BOOL)setActive:(BOOL)active</span><br><span class=\"line\">withOptions:(AVAudioSessionSetActiveOptions)options</span><br><span class=\"line\">error:(NSError * _Nullable *)outError;</span><br><span class=\"line\">这里的options传入AVAudioSessionSetActiveOptionNotifyOthersOnDeactivation 即可。</span><br><span class=\"line\"></span><br><span class=\"line\">当然，也可以通过otherAudioPlaying变量来提前判断当前是否有其他App在播放音频。</span><br></pre></td></tr></table></figure>\n<h4 id=\"四、如何根据自己需求调整AVAudioSession\"><a href=\"#四、如何根据自己需求调整AVAudioSession\" class=\"headerlink\" title=\"四、如何根据自己需求调整AVAudioSession\"></a>四、如何根据自己需求调整AVAudioSession</h4><p>AVAudioSession的设置可以分三个层级<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Category确定基调---&gt; options微调 + mode微调</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"Category的选项options\"><a href=\"#Category的选项options\" class=\"headerlink\" title=\"Category的选项options\"></a>Category的选项options</h5><p>上面介绍的这个七大类别，可以认为是设定了七种主场景，而这七类肯定是不能满足开发者所有的需求的。CoreAudio提供的方法是，首先定下七种的一种基调，然后在进行微调。CoreAudio为每种Category都提供了些许选项来进行微调。<br>在设置完类别后，可以通过<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@property(readonly) AVAudioSessionCategoryOptions categoryOptions;</span><br></pre></td></tr></table></figure></p>\n<p>属性，查看当前类别设置了哪些选项，注意这里的返回值是AVAudioSessionCategoryOptions，实际是多个options的“|”运算。默认情况下是0。</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>适用类别</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>AVAudioSessionCategoryOptionMixWithOthers</td>\n<td>AVAudioSessionCategoryPlayAndRecord, AVAudioSessionCategoryPlayback, and AVAudioSessionCategoryMultiRoute</td>\n<td>是否可以和其他后台App进行混音</td>\n</tr>\n<tr>\n<td>AVAudioSessionCategoryOptionDuckOthers</td>\n<td>AVAudioSessionCategoryAmbient, AVAudioSessionCategoryPlayAndRecord, AVAudioSessionCategoryPlayback, and AVAudioSessionCategoryMultiRoute</td>\n<td>是否压低其他App声音</td>\n</tr>\n<tr>\n<td>AVAudioSessionCategoryOptionAllowBluetooth</td>\n<td>AVAudioSessionCategoryRecord and AVAudioSessionCategoryPlayAndRecord</td>\n<td>是否支持蓝牙耳机</td>\n</tr>\n<tr>\n<td>AVAudioSessionCategoryOptionDefaultToSpeaker</td>\n<td>AVAudioSessionCategoryPlayAndRecord</td>\n<td>是否默认用免提声音</td>\n</tr>\n</tbody>\n</table>\n<p>来看每个选项的基本作用：</p>\n<ul>\n<li>AVAudioSessionCategoryOptionMixWithOthers ： 如果确实用的AVAudioSessionCategoryPlayback实现的一个背景音，但是呢，又想和QQ音乐并存，那么可以在AVAudioSessionCategoryPlayback类别下在设置这个选项，就可以实现共存了。</li>\n<li>AVAudioSessionCategoryOptionDuckOthers：在实时通话的场景，比如QQ音乐，当进行视频通话的时候，会发现QQ音乐自动声音降低了，此时就是通过设置这个选项来对其他音乐App进行了压制。</li>\n<li>AVAudioSessionCategoryOptionAllowBluetooth：如果要支持蓝牙耳机电话，则需要设置这个选项</li>\n<li>AVAudioSessionCategoryOptionDefaultToSpeaker： 如果在VoIP模式下，希望默认打开免提功能，需要设置这个选项</li>\n</ul>\n<p>通过接口：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (BOOL)setCategory:(NSString *)category withOptions:(AVAudioSessionCategoryOptions)options error:(NSError **)outError</span><br></pre></td></tr></table></figure></p>\n<p>来对当前的类别进行选项的设置。</p>\n<h4 id=\"七大模式（Mode）\"><a href=\"#七大模式（Mode）\" class=\"headerlink\" title=\"七大模式（Mode）\"></a>七大模式（Mode）</h4><p>刚讲完七大类别，现在再来七大模式。通过上面的七大类别，我们基本覆盖了常用的主场景，在每个主场景中可以通过Option进行微调。为此CoreAudio提供了七大比较常见微调后的子场景。叫做各个类别的模式。</p>\n<table>\n<thead>\n<tr>\n<th>mode</th>\n<th>适用的类别</th>\n<th>场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>AVAudioSessionModeDefault</td>\n<td>所有类别</td>\n<td>默认的模式</td>\n</tr>\n<tr>\n<td>AVAudioSessionModeVoiceChat</td>\n<td>AVAudioSessionCategoryPlayAndRecord</td>\n<td>VoIP</td>\n</tr>\n<tr>\n<td>AVAudioSessionModeGameChat</td>\n<td>AVAudioSessionCategoryPlayAndRecord</td>\n<td>游戏录制，由GKVoiceChat自动设置，无需手动调用</td>\n</tr>\n<tr>\n<td>AVAudioSessionModeVideoRecording</td>\n<td>AVAudioSessionCategoryPlayAndRecord AVAudioSessionCategoryRecord</td>\n<td>录制视频时</td>\n</tr>\n<tr>\n<td>AVAudioSessionModeMoviePlayback</td>\n<td>AVAudioSessionCategoryPlayback</td>\n<td>视频播放</td>\n</tr>\n<tr>\n<td>AVAudioSessionModeMeasurement</td>\n<td>AVAudioSessionCategoryPlayAndRecord AVAudioSessionCategoryRecord AVAudioSessionCategoryPlayback</td>\n<td>最小系统</td>\n</tr>\n<tr>\n<td>AVAudioSessionModeVideoChat</td>\n<td>AVAudioSessionCategoryPlayAndRecord</td>\n<td>视频通话</td>\n</tr>\n</tbody>\n</table>\n<p>每个模式有其适用的类别，所以，并不是有“七七 四十九”种组合。如果当前处于的类别下没有这个模式，那么是设置不成功的。设置完Category后可以通过：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@property(readonly) NSArray&lt;NSString *&gt; *availableModes;</span><br></pre></td></tr></table></figure></p>\n<p>属性，查看其支持哪些属性，做合法性校验。</p>\n<p>来看具体应用：</p>\n<ul>\n<li>AVAudioSessionModeDefault： 每种类别默认的就是这个模式，所有要想还原的话，就设置成这个模式。</li>\n<li>AVAudioSessionModeVoiceChat：主要用于VoIP场景，此时系统会选择最佳的输入设备，比如插上耳机就使用耳机上的麦克风进行采集。此时有个副作用，他会设置类别的选项为”AVAudioSessionCategoryOptionAllowBluetooth”从而支持蓝牙耳机。</li>\n<li>AVAudioSessionModeVideoChat ： 主要用于视频通话，比如QQ视频、FaceTime。时系统也会选择最佳的输入设备，比如插上耳机就使用耳机上的麦克风进行采集并且会设置类别的选项为”AVAudioSessionCategoryOptionAllowBluetooth” 和 “AVAudioSessionCategoryOptionDefaultToSpeaker”。</li>\n<li>AVAudioSessionModeGameChat ： 适用于游戏App的采集和播放，比如“GKVoiceChat”对象，一般不需要手动设置<br>另外几种和音频APP关系不大，一般我们只需要关注VoIP或者视频通话即可。</li>\n</ul>\n<p>通过调用：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (BOOL)setMode:(NSString *)mode error:(NSError **)outError</span><br></pre></td></tr></table></figure></p>\n<p>可以在设置Category之后再设置模式。</p>\n<h4 id=\"系统中断响应\"><a href=\"#系统中断响应\" class=\"headerlink\" title=\"系统中断响应\"></a>系统中断响应</h4><p><font color=\"color=#ff0000\">AVAudioSessionInterruptionNotification</font>:电话、闹铃响等中断的通知,其回调回来的userInfo主要包含两个键：</p>\n<ul>\n<li>AVAudioSessionInterruptionTypeKey:取值为 <font color=\"#ff0000\"> AVAudioSessionInterruptionTypeBegan </font>:表示中断开始，我们应该暂停播放和采集，取值为<font color=\"color=#ff0000\">AVAudioSessionInterruptionTypeEnded</font>表示中断结束，我们可以继续播放和采集。</li>\n<li>AVAudioSessionInterruptionOptionKey:当前只有一种值<font color=\"color=#ff0000\">AVAudioSessionInterruptionOptionShouldResume</font>:表示此时也应该恢复继续播放和采集。</li>\n</ul>\n<p>示例如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//注册通知</span><br><span class=\"line\">NSNotificationCenter *nsnc = [NSNotificationCenter defaultCenter];</span><br><span class=\"line\">        [nsnc addObserver:self selector:@selector(handleInterruption:) name:AVAudioSessionInterruptionNotification object:[AVAudioSession sharedInstance]];</span><br><span class=\"line\">        </span><br><span class=\"line\">//处理回调</span><br><span class=\"line\">- (void)handleInterruption: (NSNotification *)notification</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSDictionary *info = notification.userInfo;</span><br><span class=\"line\">    AVAudioSessionInterruptionType type = [info[AVAudioSessionInterruptionTypeKey] unsignedIntegerValue];</span><br><span class=\"line\">    </span><br><span class=\"line\">    if (type == AVAudioSessionInterruptionTypeBegan) &#123;</span><br><span class=\"line\">        //Handle AVAudioSessionInterruptionTypeBegan</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">       // Handle AVAudioSessionInterruptionTypeEnd</span><br><span class=\"line\">        AVAudioSessionInterruptionOptions options = [info[AVAudioSessionInterruptionOptionKey] unsignedIntegerValue];</span><br><span class=\"line\">        if (options == AVAudioSessionInterruptionOptionShouldResume) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><font color=\"#ff0000\">AVAudioSessionSilenceSecondaryAudioHintNotification</font>:其他App占据AudioSession的通知，其回调回来的userInfo键为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AVAudioSessionSilenceSecondaryAudioHintTypeKey</span><br></pre></td></tr></table></figure>\n<p>可能包含的值</p>\n<ul>\n<li><font color=\"color=#ff0000\">AVAudioSessionSilenceSecondaryAudioHintTypeBegin</font>:表示其他App开始占据Session</li>\n<li><font color=\"color=#ff0000\">AVAudioSessionInterruptionTypeEnded</font>:表示其他App开始释放Session</li>\n</ul>\n<h4 id=\"外设改变\"><a href=\"#外设改变\" class=\"headerlink\" title=\"外设改变\"></a>外设改变</h4><p>默认情况下，AudioSession会在App启动时选择一个最优的输出方案，比如插入耳机的时候，就用耳机。但是这个过程中，用户可能拔出耳机，我们App要如何感知这样的情况呢？</p>\n<p><font color=\"color=#ff0000\"><strong>AVAudioSessionRouteChangeNotification</strong></font> : 外设改变时通知，在NSNotificationCenter中对其进行注册，userInfo中有键：</p>\n<ul>\n<li>AVAudioSessionRouteChangeReasonKey ： 表示改变的原因</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>枚举值</th>\n<th>意义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>AVAudioSessionRouteChangeReasonUnknown</td>\n<td>未知原因</td>\n</tr>\n<tr>\n<td>AVAudioSessionRouteChangeReasonNewDeviceAvailable</td>\n<td>有新设备可用</td>\n</tr>\n<tr>\n<td>AVAudioSessionRouteChangeReasonOldDeviceUnavailable</td>\n<td>老设备不可用</td>\n</tr>\n<tr>\n<td>AVAudioSessionRouteChangeReasonCategoryChange</td>\n<td>类别改变了</td>\n</tr>\n<tr>\n<td>AVAudioSessionRouteChangeReasonOverride</td>\n<td>App重置了输出设置</td>\n</tr>\n<tr>\n<td>AVAudioSessionRouteChangeReasonWakeFromSleep</td>\n<td>从睡眠状态呼醒</td>\n</tr>\n<tr>\n<td>AVAudioSessionRouteChangeReasonNoSuitableRouteForCategory</td>\n<td>当前Category下没有合适的设备</td>\n</tr>\n<tr>\n<td>AVAudioSessionRouteChangeReasonRouteConfigurationChange</td>\n<td>Rotuer的配置改变了</td>\n</tr>\n</tbody>\n</table>\n<p>示例代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSNotificationCenter *nsnc = [NSNotificationCenter defaultCenter];</span><br><span class=\"line\">[nsnc addObserver:self selector:@selector(handleRouteChange:) name:AVAudioSessionRouteChangeNotification object:[AVAudioSession sharedInstance]];</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)handleRouteChange:(NSNotification *)notification</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSDictionary *info = notification.userInfo;</span><br><span class=\"line\">    AVAudioSessionRouteChangeReason reason = [info[AVAudioSessionRouteChangeReasonKey] unsignedIntegerValue];</span><br><span class=\"line\">    if (reason == AVAudioSessionRouteChangeReasonOldDeviceUnavailable) &#123;</span><br><span class=\"line\">        //如果拔出耳机，停止播放</span><br><span class=\"line\">        AVAudioSessionRouteDescription *previousRoute = info[AVAudioSessionRouteChangePreviousRouteKey];</span><br><span class=\"line\">        AVAudioSessionPortDescription *previousOutput = previousRoute.outputs[0];</span><br><span class=\"line\">        NSString *portType = previousOutput.portType;</span><br><span class=\"line\">        if ([portType isEqualToString:AVAudioSessionPortHeadphones]) &#123;</span><br><span class=\"line\">            [self stop];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>注：<br>文章部分内容来自：<a href=\"https://www.jianshu.com/p/3e0a399380df\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/3e0a399380df</a><br>及参考《AVFoundation 开发秘籍》</p>\n<h4 id=\"一、AVAudioSession是用来干嘛的？\"><a href=\"#一、AVAudioSession是用来干嘛的？\" class=\"headerlink\" title=\"一、AVAudioSession是用来干嘛的？\"></a>一、AVAudioSession是用来干嘛的？</h4><p>简单来说AVAudioSession是用来控制app的音频行为，比如插拔耳机后是否继续播放音频、接电话后返回是否继续播放、是否和其他音频数据混音等。当你遇到:</p>\n<ul>\n<li>是进行录音还是播放？</li>\n<li>当系统静音键按下时该如何表现？</li>\n<li>是从扬声器还是从听筒里面播放声音？</li>\n<li>插拔耳机后如何表现？</li>\n<li>来电话/闹钟响了后如何表现？</li>\n<li>其他音频App启动后如何表现？</li>\n<li>…<br>这些场景的时候，就可以考虑一下“AVAudioSession”了。</li>\n</ul>\n<h4 id=\"二、AVAudioSession是如何控制音频行为的？\"><a href=\"#二、AVAudioSession是如何控制音频行为的？\" class=\"headerlink\" title=\"二、AVAudioSession是如何控制音频行为的？\"></a>二、AVAudioSession是如何控制音频行为的？</h4><p>AVFoundation定义了7种分类（category）来描述应用程序所使用的音频行为。<br><img src=\"//www.cyrus.fun/2018/10/25/AVFoundation学习笔记二-AVAudioSession/session_category.png\" alt=\"\"></p>\n<p>7种类别各自的行为总结如下：</p>\n<ul>\n<li><strong><em>AVAudioSessionCategoryAmbient</em></strong>： 只用于播放音乐时，并且可以和QQ音乐同时播放，比如玩游戏的时候还想听QQ音乐的歌，那么把游戏播放背景音就设置成这种类别。同时，当用户锁屏或者静音时也会随着静音，这种类别基本使用所有App的背景场景。</li>\n<li><strong><em>AVAudioSessionCategorySoloAmbient(默认)</em></strong>：也是只用于播放,但是和<strong><em>“AVAudioSessionCategoryAmbient”</em></strong>不同的是，用了它就别想听QQ音乐了，比如不希望QQ音乐干扰的App，类似节奏大师。同样当用户锁屏或者静音时也会随着静音，锁屏了就玩不了节奏大师了。</li>\n<li><strong><em>AVAudioSessionCategoryPlayback</em></strong>：如果锁屏了还想听声音怎么办？用这个类别，比如App本身就是播放器，同时当App播放时，其他类似QQ音乐就不能播放了。所以这种类别一般用于播放器类App</li>\n<li><strong><em>AVAudioSessionCategoryRecord</em></strong>：有了播放器，肯定要录音机，比如微信语音的录制，就要用到这个类别，既然要安静的录音，肯定不希望有QQ音乐了，所以其他播放声音会中断。想想微信语音的场景，就知道什么时候用他了。</li>\n<li><strong><em>AVAudioSessionCategoryPlayAndRecord</em></strong>：如果既想播放又想录制该用什么模式呢？比如VoIP，打电话这种场景，PlayAndRecord就是专门为这样的场景设计的 。</li>\n<li><strong><em>AVAudioSessionCategoryMultiRoute</em></strong>：想象一个DJ用的App，手机连着HDMI到扬声器播放当前的音乐，然后耳机里面播放下一曲，这种常人不理解的场景，这个类别可以支持多个设备输入输出。</li>\n<li><strong><em>AVAudioSessionCategoryAudioProcessing</em></strong>: 主要用于音频格式处理，一般可以配合AudioUnit进行使用</li>\n</ul>\n<h4 id=\"三、如何设置AVAudioSession\"><a href=\"#三、如何设置AVAudioSession\" class=\"headerlink\" title=\"三、如何设置AVAudioSession\"></a>三、如何设置AVAudioSession</h4><p>获取AVAudioSession单例,设置类别并激活。音频会话通常会在应用程序启动时进行一次配置，所以可以将代码写在- (BOOL)application:(UIApplication <em>)application didFinishLaunchingWithOptions:(NSDictionary </em>)launchOptions：中。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AVAudioSession *session = [AVAudioSession sharedInstance];</span><br><span class=\"line\">NSError *error;</span><br><span class=\"line\">    if (![session setCategory:AVAudioSessionCategoryPlayback error:&amp;error]) &#123;</span><br><span class=\"line\">        NSLog(@&quot;Category Error:%@&quot;, [error localizedDescription]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (![session setActive:YES error:&amp;error]) &#123;</span><br><span class=\"line\">        NSLog(@&quot;Activation Error:%@&quot;, [error localizedDescription]);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">因为AVAudioSession会影响其他App的表现，当自己App的Session被激活，其他App的就会被解除激活，如何要让自己的Session解除激活后恢复其他App Session的激活状态呢？</span><br><span class=\"line\"></span><br><span class=\"line\">此时可以使用：</span><br><span class=\"line\"></span><br><span class=\"line\">(BOOL)setActive:(BOOL)active</span><br><span class=\"line\">withOptions:(AVAudioSessionSetActiveOptions)options</span><br><span class=\"line\">error:(NSError * _Nullable *)outError;</span><br><span class=\"line\">这里的options传入AVAudioSessionSetActiveOptionNotifyOthersOnDeactivation 即可。</span><br><span class=\"line\"></span><br><span class=\"line\">当然，也可以通过otherAudioPlaying变量来提前判断当前是否有其他App在播放音频。</span><br></pre></td></tr></table></figure>\n<h4 id=\"四、如何根据自己需求调整AVAudioSession\"><a href=\"#四、如何根据自己需求调整AVAudioSession\" class=\"headerlink\" title=\"四、如何根据自己需求调整AVAudioSession\"></a>四、如何根据自己需求调整AVAudioSession</h4><p>AVAudioSession的设置可以分三个层级<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Category确定基调---&gt; options微调 + mode微调</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"Category的选项options\"><a href=\"#Category的选项options\" class=\"headerlink\" title=\"Category的选项options\"></a>Category的选项options</h5><p>上面介绍的这个七大类别，可以认为是设定了七种主场景，而这七类肯定是不能满足开发者所有的需求的。CoreAudio提供的方法是，首先定下七种的一种基调，然后在进行微调。CoreAudio为每种Category都提供了些许选项来进行微调。<br>在设置完类别后，可以通过<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@property(readonly) AVAudioSessionCategoryOptions categoryOptions;</span><br></pre></td></tr></table></figure></p>\n<p>属性，查看当前类别设置了哪些选项，注意这里的返回值是AVAudioSessionCategoryOptions，实际是多个options的“|”运算。默认情况下是0。</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>适用类别</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>AVAudioSessionCategoryOptionMixWithOthers</td>\n<td>AVAudioSessionCategoryPlayAndRecord, AVAudioSessionCategoryPlayback, and AVAudioSessionCategoryMultiRoute</td>\n<td>是否可以和其他后台App进行混音</td>\n</tr>\n<tr>\n<td>AVAudioSessionCategoryOptionDuckOthers</td>\n<td>AVAudioSessionCategoryAmbient, AVAudioSessionCategoryPlayAndRecord, AVAudioSessionCategoryPlayback, and AVAudioSessionCategoryMultiRoute</td>\n<td>是否压低其他App声音</td>\n</tr>\n<tr>\n<td>AVAudioSessionCategoryOptionAllowBluetooth</td>\n<td>AVAudioSessionCategoryRecord and AVAudioSessionCategoryPlayAndRecord</td>\n<td>是否支持蓝牙耳机</td>\n</tr>\n<tr>\n<td>AVAudioSessionCategoryOptionDefaultToSpeaker</td>\n<td>AVAudioSessionCategoryPlayAndRecord</td>\n<td>是否默认用免提声音</td>\n</tr>\n</tbody>\n</table>\n<p>来看每个选项的基本作用：</p>\n<ul>\n<li>AVAudioSessionCategoryOptionMixWithOthers ： 如果确实用的AVAudioSessionCategoryPlayback实现的一个背景音，但是呢，又想和QQ音乐并存，那么可以在AVAudioSessionCategoryPlayback类别下在设置这个选项，就可以实现共存了。</li>\n<li>AVAudioSessionCategoryOptionDuckOthers：在实时通话的场景，比如QQ音乐，当进行视频通话的时候，会发现QQ音乐自动声音降低了，此时就是通过设置这个选项来对其他音乐App进行了压制。</li>\n<li>AVAudioSessionCategoryOptionAllowBluetooth：如果要支持蓝牙耳机电话，则需要设置这个选项</li>\n<li>AVAudioSessionCategoryOptionDefaultToSpeaker： 如果在VoIP模式下，希望默认打开免提功能，需要设置这个选项</li>\n</ul>\n<p>通过接口：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (BOOL)setCategory:(NSString *)category withOptions:(AVAudioSessionCategoryOptions)options error:(NSError **)outError</span><br></pre></td></tr></table></figure></p>\n<p>来对当前的类别进行选项的设置。</p>\n<h4 id=\"七大模式（Mode）\"><a href=\"#七大模式（Mode）\" class=\"headerlink\" title=\"七大模式（Mode）\"></a>七大模式（Mode）</h4><p>刚讲完七大类别，现在再来七大模式。通过上面的七大类别，我们基本覆盖了常用的主场景，在每个主场景中可以通过Option进行微调。为此CoreAudio提供了七大比较常见微调后的子场景。叫做各个类别的模式。</p>\n<table>\n<thead>\n<tr>\n<th>mode</th>\n<th>适用的类别</th>\n<th>场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>AVAudioSessionModeDefault</td>\n<td>所有类别</td>\n<td>默认的模式</td>\n</tr>\n<tr>\n<td>AVAudioSessionModeVoiceChat</td>\n<td>AVAudioSessionCategoryPlayAndRecord</td>\n<td>VoIP</td>\n</tr>\n<tr>\n<td>AVAudioSessionModeGameChat</td>\n<td>AVAudioSessionCategoryPlayAndRecord</td>\n<td>游戏录制，由GKVoiceChat自动设置，无需手动调用</td>\n</tr>\n<tr>\n<td>AVAudioSessionModeVideoRecording</td>\n<td>AVAudioSessionCategoryPlayAndRecord AVAudioSessionCategoryRecord</td>\n<td>录制视频时</td>\n</tr>\n<tr>\n<td>AVAudioSessionModeMoviePlayback</td>\n<td>AVAudioSessionCategoryPlayback</td>\n<td>视频播放</td>\n</tr>\n<tr>\n<td>AVAudioSessionModeMeasurement</td>\n<td>AVAudioSessionCategoryPlayAndRecord AVAudioSessionCategoryRecord AVAudioSessionCategoryPlayback</td>\n<td>最小系统</td>\n</tr>\n<tr>\n<td>AVAudioSessionModeVideoChat</td>\n<td>AVAudioSessionCategoryPlayAndRecord</td>\n<td>视频通话</td>\n</tr>\n</tbody>\n</table>\n<p>每个模式有其适用的类别，所以，并不是有“七七 四十九”种组合。如果当前处于的类别下没有这个模式，那么是设置不成功的。设置完Category后可以通过：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@property(readonly) NSArray&lt;NSString *&gt; *availableModes;</span><br></pre></td></tr></table></figure></p>\n<p>属性，查看其支持哪些属性，做合法性校验。</p>\n<p>来看具体应用：</p>\n<ul>\n<li>AVAudioSessionModeDefault： 每种类别默认的就是这个模式，所有要想还原的话，就设置成这个模式。</li>\n<li>AVAudioSessionModeVoiceChat：主要用于VoIP场景，此时系统会选择最佳的输入设备，比如插上耳机就使用耳机上的麦克风进行采集。此时有个副作用，他会设置类别的选项为”AVAudioSessionCategoryOptionAllowBluetooth”从而支持蓝牙耳机。</li>\n<li>AVAudioSessionModeVideoChat ： 主要用于视频通话，比如QQ视频、FaceTime。时系统也会选择最佳的输入设备，比如插上耳机就使用耳机上的麦克风进行采集并且会设置类别的选项为”AVAudioSessionCategoryOptionAllowBluetooth” 和 “AVAudioSessionCategoryOptionDefaultToSpeaker”。</li>\n<li>AVAudioSessionModeGameChat ： 适用于游戏App的采集和播放，比如“GKVoiceChat”对象，一般不需要手动设置<br>另外几种和音频APP关系不大，一般我们只需要关注VoIP或者视频通话即可。</li>\n</ul>\n<p>通过调用：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (BOOL)setMode:(NSString *)mode error:(NSError **)outError</span><br></pre></td></tr></table></figure></p>\n<p>可以在设置Category之后再设置模式。</p>\n<h4 id=\"系统中断响应\"><a href=\"#系统中断响应\" class=\"headerlink\" title=\"系统中断响应\"></a>系统中断响应</h4><p><font color=\"color=#ff0000\">AVAudioSessionInterruptionNotification</font>:电话、闹铃响等中断的通知,其回调回来的userInfo主要包含两个键：</p>\n<ul>\n<li>AVAudioSessionInterruptionTypeKey:取值为 <font color=\"#ff0000\"> AVAudioSessionInterruptionTypeBegan </font>:表示中断开始，我们应该暂停播放和采集，取值为<font color=\"color=#ff0000\">AVAudioSessionInterruptionTypeEnded</font>表示中断结束，我们可以继续播放和采集。</li>\n<li>AVAudioSessionInterruptionOptionKey:当前只有一种值<font color=\"color=#ff0000\">AVAudioSessionInterruptionOptionShouldResume</font>:表示此时也应该恢复继续播放和采集。</li>\n</ul>\n<p>示例如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//注册通知</span><br><span class=\"line\">NSNotificationCenter *nsnc = [NSNotificationCenter defaultCenter];</span><br><span class=\"line\">        [nsnc addObserver:self selector:@selector(handleInterruption:) name:AVAudioSessionInterruptionNotification object:[AVAudioSession sharedInstance]];</span><br><span class=\"line\">        </span><br><span class=\"line\">//处理回调</span><br><span class=\"line\">- (void)handleInterruption: (NSNotification *)notification</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSDictionary *info = notification.userInfo;</span><br><span class=\"line\">    AVAudioSessionInterruptionType type = [info[AVAudioSessionInterruptionTypeKey] unsignedIntegerValue];</span><br><span class=\"line\">    </span><br><span class=\"line\">    if (type == AVAudioSessionInterruptionTypeBegan) &#123;</span><br><span class=\"line\">        //Handle AVAudioSessionInterruptionTypeBegan</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">       // Handle AVAudioSessionInterruptionTypeEnd</span><br><span class=\"line\">        AVAudioSessionInterruptionOptions options = [info[AVAudioSessionInterruptionOptionKey] unsignedIntegerValue];</span><br><span class=\"line\">        if (options == AVAudioSessionInterruptionOptionShouldResume) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><font color=\"#ff0000\">AVAudioSessionSilenceSecondaryAudioHintNotification</font>:其他App占据AudioSession的通知，其回调回来的userInfo键为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AVAudioSessionSilenceSecondaryAudioHintTypeKey</span><br></pre></td></tr></table></figure>\n<p>可能包含的值</p>\n<ul>\n<li><font color=\"color=#ff0000\">AVAudioSessionSilenceSecondaryAudioHintTypeBegin</font>:表示其他App开始占据Session</li>\n<li><font color=\"color=#ff0000\">AVAudioSessionInterruptionTypeEnded</font>:表示其他App开始释放Session</li>\n</ul>\n<h4 id=\"外设改变\"><a href=\"#外设改变\" class=\"headerlink\" title=\"外设改变\"></a>外设改变</h4><p>默认情况下，AudioSession会在App启动时选择一个最优的输出方案，比如插入耳机的时候，就用耳机。但是这个过程中，用户可能拔出耳机，我们App要如何感知这样的情况呢？</p>\n<p><font color=\"color=#ff0000\"><strong>AVAudioSessionRouteChangeNotification</strong></font> : 外设改变时通知，在NSNotificationCenter中对其进行注册，userInfo中有键：</p>\n<ul>\n<li>AVAudioSessionRouteChangeReasonKey ： 表示改变的原因</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>枚举值</th>\n<th>意义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>AVAudioSessionRouteChangeReasonUnknown</td>\n<td>未知原因</td>\n</tr>\n<tr>\n<td>AVAudioSessionRouteChangeReasonNewDeviceAvailable</td>\n<td>有新设备可用</td>\n</tr>\n<tr>\n<td>AVAudioSessionRouteChangeReasonOldDeviceUnavailable</td>\n<td>老设备不可用</td>\n</tr>\n<tr>\n<td>AVAudioSessionRouteChangeReasonCategoryChange</td>\n<td>类别改变了</td>\n</tr>\n<tr>\n<td>AVAudioSessionRouteChangeReasonOverride</td>\n<td>App重置了输出设置</td>\n</tr>\n<tr>\n<td>AVAudioSessionRouteChangeReasonWakeFromSleep</td>\n<td>从睡眠状态呼醒</td>\n</tr>\n<tr>\n<td>AVAudioSessionRouteChangeReasonNoSuitableRouteForCategory</td>\n<td>当前Category下没有合适的设备</td>\n</tr>\n<tr>\n<td>AVAudioSessionRouteChangeReasonRouteConfigurationChange</td>\n<td>Rotuer的配置改变了</td>\n</tr>\n</tbody>\n</table>\n<p>示例代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSNotificationCenter *nsnc = [NSNotificationCenter defaultCenter];</span><br><span class=\"line\">[nsnc addObserver:self selector:@selector(handleRouteChange:) name:AVAudioSessionRouteChangeNotification object:[AVAudioSession sharedInstance]];</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)handleRouteChange:(NSNotification *)notification</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSDictionary *info = notification.userInfo;</span><br><span class=\"line\">    AVAudioSessionRouteChangeReason reason = [info[AVAudioSessionRouteChangeReasonKey] unsignedIntegerValue];</span><br><span class=\"line\">    if (reason == AVAudioSessionRouteChangeReasonOldDeviceUnavailable) &#123;</span><br><span class=\"line\">        //如果拔出耳机，停止播放</span><br><span class=\"line\">        AVAudioSessionRouteDescription *previousRoute = info[AVAudioSessionRouteChangePreviousRouteKey];</span><br><span class=\"line\">        AVAudioSessionPortDescription *previousOutput = previousRoute.outputs[0];</span><br><span class=\"line\">        NSString *portType = previousOutput.portType;</span><br><span class=\"line\">        if ([portType isEqualToString:AVAudioSessionPortHeadphones]) &#123;</span><br><span class=\"line\">            [self stop];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"AVFoundation学习笔记八 AVPlayer及缩略图等相关功能","author":"Cyrus","date":"2018-11-08T15:25:00.000Z","_content":"\n![](player_classes.png)\n\n### AVPlayer\n一个用来播放基本时间的视听媒体的控制器对象。支持播放从本地、分步下载或通过HTTP Live Streaming协议得到的流媒体，并在多种播放场景中播放这些视频资源。AVPlayer是一个不可见组件，要将视频资源导出到用户界面的目标位置，需要使用AVPlyerLayer类。\n\n### AVPlayerLayer\n构建于Core animation上，是AVFoundation中能找到的为数不多的可见组件。AVPlayerLayer扩展了CoreAnimation的CALayer类，并通过框架在屏幕上显示视频内容。\n```\nAVPlayerLayer的videoGravity属性：\nAVLayerVideoGravityResizeAspect：默认值，保持视频原始宽高比，可能会有黑边；\nAVLayerVideoGravityResizeAspectFill： 保持原始宽高比，短边填充屏幕，长边可能会超出屏幕\nAVLayerVideoGravityResize：填充屏幕，不保持宽高比，图像会变形，最不常用。\n```\n\n### AVPlayerItem\nAVAsset包含一些媒体数据的静态信息，如创建日期、元数据和时长等，但是没有当前播放时间、音量和查找特定位置的方法这些动态数据，需要AVPlayerItem和AVPlayerItemTrack类构建相应的动态内容。\n\n```\n代码如下（简单，没啥说的）：\nNSURL *assetURL = [[NSBundle mainBundle] URLForResource:@\"1\" withExtension:@\"mp4\"];\n    AVAsset *asset = [AVAsset assetWithURL:assetURL];\n    \n    AVPlayerItem *item = [[AVPlayerItem alloc] initWithAsset:asset];\n    AVPlayer *player = [[AVPlayer alloc] initWithPlayerItem:item];\n    AVPlayerLayer *layer = [AVPlayerLayer playerLayerWithPlayer:player];\n    layer.frame = self.view.bounds;\n    [self.view.layer addSublayer:layer];\n    [player play];\n```\n\n### CMTime\nCMTime是Core Media的一种数据结构。CMTime为时间的正确表示给出了一种结构，即分数值的方式（分子、分母）,定义如下：\n```\n//value/timescale = seconds.\n    typedef struct\n    {\n        CMTimeValue    value;       //分子 int64_t\n        CMTimeScale    timescale;   //分母 int32_t\n        CMTimeFlags    flags;\n        CMTimeEpoch    epoch;\n    } CMTime;\n    \n    创建\n    //0.5s\n    CMTime halfSecond = CMTimeMake(1, 2);\n    //5s\n    CMTime fiveSeconds = CMTimeMake(5, 1);\n    //44.1kHz\n    CMTime oneSample = CMTimeMake(1, 44100);\n    //0\n    CMTime zeroTime = kCMTimeZero;\n```\n\n### 播放过程中的进度监听\n```\n- (void)addPlayerItemTimeObserver {\n    \n    // Create 0.5 second refresh interval - REFRESH_INTERVAL == 0.5\n    CMTime interval =\n        CMTimeMakeWithSeconds(0.5, NSEC_PER_SEC);              // 1\n    \n    // Main dispatch queue\n    dispatch_queue_t queue = dispatch_get_main_queue();                     // 2\n    \n    // Create callback block for time observer\n \n    void (^callback)(CMTime time) = ^(CMTime time) {\n        NSTimeInterval currentTime = CMTimeGetSeconds(time);\n        NSTimeInterval duration = CMTimeGetSeconds(weakSelf.playerItem.duration);\n        //do something with currentTime and duration\n    };\n    \n    // Add observer and store pointer for future use\n    self.timeObserver = [self.player addPeriodicTimeObserverForInterval:interval queue:queue usingBlock:callback];\n}\n\n\n可通过： [self.player removeTimeObserver:self.timeObserver]; 移除监听\n```\n\n### <font color=ff0000>视频进度缩略图</font>\nAVAssetImageGenerator工具类。这个类可以从一个Asset视频曲目中提取图片。生成一个或多个缩略图。主要包含两个方法：\n```\nAVAssetImageGenerator工具类。这个类可以从一个Asset视频曲目中提取图片。生成一个或多个缩略图。主要包含两个方法：\n/**\nrequestedTime: 指定获取缩略图的时间 传入数据\nactualTime:    生成图片的准确时间   传出数据\n*/\n\n- (nullable CGImageRef)copyCGImageAtTime:(CMTime)requestedTime actualTime:(nullable CMTime *)actualTime error:(NSError * _Nullable * _Nullable)outError //生成指定时间的单张缩略图\n```\n\n代码如下：\n```\n//指定时间生成缩略图\n//创建URL\n    NSURL *url=[NSURL URLWithString:[_videoURLStr stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding]];\n    AVURLAsset *urlAsset=[AVURLAsset assetWithURL:url];\n    AVAssetImageGenerator *imageGenerator=[AVAssetImageGenerator assetImageGeneratorWithAsset:urlAsset];\n    NSError *error=nil;\n    CMTime time=CMTimeMakeWithSeconds(timeBySecond, 10);\n    CMTime actualTime;\n    CGImageRef cgImage= [imageGenerator copyCGImageAtTime:time actualTime:&actualTime error:&error];\n    if(error){\n        return;\n    }\n    CMTimeShow(actualTime);\n    UIImage *image=[UIImage imageWithCGImage:cgImage];//转化为UIImage\n    //保存到相册\n    UIImageWriteToSavedPhotosAlbum(image,nil, nil, nil);\n    CGImageRelease(cgImage);\n```\n\n```\n//生成指定时间数组的一组缩略图\ntypedef void (^AVAssetImageGeneratorCompletionHandler)(CMTime requestedTime, CGImageRef _Nullable image, CMTime actualTime, AVAssetImageGeneratorResult result, NSError * _Nullable error);\n- (void)generateCGImagesAsynchronouslyForTimes:(NSArray<NSValue *> *)requestedTimes completionHandler:(AVAssetImageGeneratorCompletionHandler)handler;\n- (void)generateThumbnails {\n    \n    self.imageGenerator =                                                   // 1\n        [AVAssetImageGenerator assetImageGeneratorWithAsset:self.asset];\n    \n    // Generate the @2x equivalent\n    self.imageGenerator.maximumSize = CGSizeMake(200.0f, 0.0f);             // 2\n    CMTime duration = self.asset.duration;\n    NSMutableArray *times = [NSMutableArray array];                         // 3\n    CMTimeValue increment = duration.value / 20;\n    CMTimeValue currentValue = 2.0 * duration.timescale;\n    while (currentValue <= duration.value) {\n        CMTime time = CMTimeMake(currentValue, duration.timescale);\n        [times addObject:[NSValue valueWithCMTime:time]];\n        currentValue += increment;\n    }\n    __block NSUInteger imageCount = times.count;                            // 4\n    __block NSMutableArray *images = [NSMutableArray array];\n    AVAssetImageGeneratorCompletionHandler handler;                         // 5 handler会多次回调，每次生成一张缩略图/失败\n    \n    handler = ^(CMTime requestedTime,\n                CGImageRef imageRef,\n                CMTime actualTime,\n                AVAssetImageGeneratorResult result,\n                NSError *error) {\n        if (result == AVAssetImageGeneratorSucceeded) {                     // 6\n            UIImage *image = [UIImage imageWithCGImage:imageRef];\n            id thumbnail =\n                [THThumbnail thumbnailWithImage:image time:actualTime];\n            [images addObject:thumbnail];\n        } else {\n            NSLog(@\"Error: %@\", [error localizedDescription]);\n        }\n        // If the decremented image count is at 0, we're all done.\n        if (--imageCount == 0) {                                            // 7\n            dispatch_async(dispatch_get_main_queue(), ^{\n                NSString *name = THThumbnailsGeneratedNotification;\n                NSNotificationCenter *nc = [NSNotificationCenter defaultCenter];\n                [nc postNotificationName:name object:images];\n            });\n        }\n    };\n    [self.imageGenerator generateCGImagesAsynchronouslyForTimes:times completionHandler:handler];\n}\n```\n\n### 字幕切换\nAVFoundation在展示字幕和隐藏字幕方面提供了可靠方法。AVPlayerLayer会自动渲染这些元素，并且可以让开发者告诉应用程序哪些元素里面要渲染。完成这些操作需要用到AVMediaSelectionGroup和AVMediaSelectionOption两个类。\n```\nNSArray *mediaCharacteristics = asset.availableMediaCharacteristicsWithMediaSelectionOptions;\n    for (NSString *characteristic in mediaCharacteristics) {\n        //可选择的轨道组\n        AVMediaSelectionGroup *group = [asset mediaSelectionGroupForMediaCharacteristic:characteristic];\n        NSLog(@\"%@\", characteristic);\n        for (AVMediaSelectionOption *option in group.options) {\n            //option:轨道组中的轨道\n            NSLog(@\"Option:%@\", option.displayName);\n            \n            //- (void)selectMediaOption:(nullable AVMediaSelectionOption *)mediaSelectionOption inMediaSelectionGroup:(AVMediaSelectionGroup *)mediaSelectionGroup\n            //对所择轨道的切换，如切换字幕、音频等\n            [item selectMediaOption:option inMediaSelectionGroup:group];\n        }\n    }\n```\n结果显示：\n![](option_result.png)\n\n### airplay\n```\nMPVolumeView *volumeView = [[MPVolumeView alloc] initWithFrame:CGRectZero];\nvolumeView.showsVolumeSlider = NO;\n[volumeView sizeToFit];\n[self.view addSubview:volumeView];\n```\n可以弹出airplay播放设备，如mac上的air server，但air Server闪退，原因未知\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/AVFoundation学习笔记八-AVPlayer及缩略图等相关功能.md","raw":"title: AVFoundation学习笔记八 AVPlayer及缩略图等相关功能\nauthor: Cyrus\ntags: []\ncategories:\n  - AVFoundation\ndate: 2018-11-08 23:25:00\n---\n\n![](player_classes.png)\n\n### AVPlayer\n一个用来播放基本时间的视听媒体的控制器对象。支持播放从本地、分步下载或通过HTTP Live Streaming协议得到的流媒体，并在多种播放场景中播放这些视频资源。AVPlayer是一个不可见组件，要将视频资源导出到用户界面的目标位置，需要使用AVPlyerLayer类。\n\n### AVPlayerLayer\n构建于Core animation上，是AVFoundation中能找到的为数不多的可见组件。AVPlayerLayer扩展了CoreAnimation的CALayer类，并通过框架在屏幕上显示视频内容。\n```\nAVPlayerLayer的videoGravity属性：\nAVLayerVideoGravityResizeAspect：默认值，保持视频原始宽高比，可能会有黑边；\nAVLayerVideoGravityResizeAspectFill： 保持原始宽高比，短边填充屏幕，长边可能会超出屏幕\nAVLayerVideoGravityResize：填充屏幕，不保持宽高比，图像会变形，最不常用。\n```\n\n### AVPlayerItem\nAVAsset包含一些媒体数据的静态信息，如创建日期、元数据和时长等，但是没有当前播放时间、音量和查找特定位置的方法这些动态数据，需要AVPlayerItem和AVPlayerItemTrack类构建相应的动态内容。\n\n```\n代码如下（简单，没啥说的）：\nNSURL *assetURL = [[NSBundle mainBundle] URLForResource:@\"1\" withExtension:@\"mp4\"];\n    AVAsset *asset = [AVAsset assetWithURL:assetURL];\n    \n    AVPlayerItem *item = [[AVPlayerItem alloc] initWithAsset:asset];\n    AVPlayer *player = [[AVPlayer alloc] initWithPlayerItem:item];\n    AVPlayerLayer *layer = [AVPlayerLayer playerLayerWithPlayer:player];\n    layer.frame = self.view.bounds;\n    [self.view.layer addSublayer:layer];\n    [player play];\n```\n\n### CMTime\nCMTime是Core Media的一种数据结构。CMTime为时间的正确表示给出了一种结构，即分数值的方式（分子、分母）,定义如下：\n```\n//value/timescale = seconds.\n    typedef struct\n    {\n        CMTimeValue    value;       //分子 int64_t\n        CMTimeScale    timescale;   //分母 int32_t\n        CMTimeFlags    flags;\n        CMTimeEpoch    epoch;\n    } CMTime;\n    \n    创建\n    //0.5s\n    CMTime halfSecond = CMTimeMake(1, 2);\n    //5s\n    CMTime fiveSeconds = CMTimeMake(5, 1);\n    //44.1kHz\n    CMTime oneSample = CMTimeMake(1, 44100);\n    //0\n    CMTime zeroTime = kCMTimeZero;\n```\n\n### 播放过程中的进度监听\n```\n- (void)addPlayerItemTimeObserver {\n    \n    // Create 0.5 second refresh interval - REFRESH_INTERVAL == 0.5\n    CMTime interval =\n        CMTimeMakeWithSeconds(0.5, NSEC_PER_SEC);              // 1\n    \n    // Main dispatch queue\n    dispatch_queue_t queue = dispatch_get_main_queue();                     // 2\n    \n    // Create callback block for time observer\n \n    void (^callback)(CMTime time) = ^(CMTime time) {\n        NSTimeInterval currentTime = CMTimeGetSeconds(time);\n        NSTimeInterval duration = CMTimeGetSeconds(weakSelf.playerItem.duration);\n        //do something with currentTime and duration\n    };\n    \n    // Add observer and store pointer for future use\n    self.timeObserver = [self.player addPeriodicTimeObserverForInterval:interval queue:queue usingBlock:callback];\n}\n\n\n可通过： [self.player removeTimeObserver:self.timeObserver]; 移除监听\n```\n\n### <font color=ff0000>视频进度缩略图</font>\nAVAssetImageGenerator工具类。这个类可以从一个Asset视频曲目中提取图片。生成一个或多个缩略图。主要包含两个方法：\n```\nAVAssetImageGenerator工具类。这个类可以从一个Asset视频曲目中提取图片。生成一个或多个缩略图。主要包含两个方法：\n/**\nrequestedTime: 指定获取缩略图的时间 传入数据\nactualTime:    生成图片的准确时间   传出数据\n*/\n\n- (nullable CGImageRef)copyCGImageAtTime:(CMTime)requestedTime actualTime:(nullable CMTime *)actualTime error:(NSError * _Nullable * _Nullable)outError //生成指定时间的单张缩略图\n```\n\n代码如下：\n```\n//指定时间生成缩略图\n//创建URL\n    NSURL *url=[NSURL URLWithString:[_videoURLStr stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding]];\n    AVURLAsset *urlAsset=[AVURLAsset assetWithURL:url];\n    AVAssetImageGenerator *imageGenerator=[AVAssetImageGenerator assetImageGeneratorWithAsset:urlAsset];\n    NSError *error=nil;\n    CMTime time=CMTimeMakeWithSeconds(timeBySecond, 10);\n    CMTime actualTime;\n    CGImageRef cgImage= [imageGenerator copyCGImageAtTime:time actualTime:&actualTime error:&error];\n    if(error){\n        return;\n    }\n    CMTimeShow(actualTime);\n    UIImage *image=[UIImage imageWithCGImage:cgImage];//转化为UIImage\n    //保存到相册\n    UIImageWriteToSavedPhotosAlbum(image,nil, nil, nil);\n    CGImageRelease(cgImage);\n```\n\n```\n//生成指定时间数组的一组缩略图\ntypedef void (^AVAssetImageGeneratorCompletionHandler)(CMTime requestedTime, CGImageRef _Nullable image, CMTime actualTime, AVAssetImageGeneratorResult result, NSError * _Nullable error);\n- (void)generateCGImagesAsynchronouslyForTimes:(NSArray<NSValue *> *)requestedTimes completionHandler:(AVAssetImageGeneratorCompletionHandler)handler;\n- (void)generateThumbnails {\n    \n    self.imageGenerator =                                                   // 1\n        [AVAssetImageGenerator assetImageGeneratorWithAsset:self.asset];\n    \n    // Generate the @2x equivalent\n    self.imageGenerator.maximumSize = CGSizeMake(200.0f, 0.0f);             // 2\n    CMTime duration = self.asset.duration;\n    NSMutableArray *times = [NSMutableArray array];                         // 3\n    CMTimeValue increment = duration.value / 20;\n    CMTimeValue currentValue = 2.0 * duration.timescale;\n    while (currentValue <= duration.value) {\n        CMTime time = CMTimeMake(currentValue, duration.timescale);\n        [times addObject:[NSValue valueWithCMTime:time]];\n        currentValue += increment;\n    }\n    __block NSUInteger imageCount = times.count;                            // 4\n    __block NSMutableArray *images = [NSMutableArray array];\n    AVAssetImageGeneratorCompletionHandler handler;                         // 5 handler会多次回调，每次生成一张缩略图/失败\n    \n    handler = ^(CMTime requestedTime,\n                CGImageRef imageRef,\n                CMTime actualTime,\n                AVAssetImageGeneratorResult result,\n                NSError *error) {\n        if (result == AVAssetImageGeneratorSucceeded) {                     // 6\n            UIImage *image = [UIImage imageWithCGImage:imageRef];\n            id thumbnail =\n                [THThumbnail thumbnailWithImage:image time:actualTime];\n            [images addObject:thumbnail];\n        } else {\n            NSLog(@\"Error: %@\", [error localizedDescription]);\n        }\n        // If the decremented image count is at 0, we're all done.\n        if (--imageCount == 0) {                                            // 7\n            dispatch_async(dispatch_get_main_queue(), ^{\n                NSString *name = THThumbnailsGeneratedNotification;\n                NSNotificationCenter *nc = [NSNotificationCenter defaultCenter];\n                [nc postNotificationName:name object:images];\n            });\n        }\n    };\n    [self.imageGenerator generateCGImagesAsynchronouslyForTimes:times completionHandler:handler];\n}\n```\n\n### 字幕切换\nAVFoundation在展示字幕和隐藏字幕方面提供了可靠方法。AVPlayerLayer会自动渲染这些元素，并且可以让开发者告诉应用程序哪些元素里面要渲染。完成这些操作需要用到AVMediaSelectionGroup和AVMediaSelectionOption两个类。\n```\nNSArray *mediaCharacteristics = asset.availableMediaCharacteristicsWithMediaSelectionOptions;\n    for (NSString *characteristic in mediaCharacteristics) {\n        //可选择的轨道组\n        AVMediaSelectionGroup *group = [asset mediaSelectionGroupForMediaCharacteristic:characteristic];\n        NSLog(@\"%@\", characteristic);\n        for (AVMediaSelectionOption *option in group.options) {\n            //option:轨道组中的轨道\n            NSLog(@\"Option:%@\", option.displayName);\n            \n            //- (void)selectMediaOption:(nullable AVMediaSelectionOption *)mediaSelectionOption inMediaSelectionGroup:(AVMediaSelectionGroup *)mediaSelectionGroup\n            //对所择轨道的切换，如切换字幕、音频等\n            [item selectMediaOption:option inMediaSelectionGroup:group];\n        }\n    }\n```\n结果显示：\n![](option_result.png)\n\n### airplay\n```\nMPVolumeView *volumeView = [[MPVolumeView alloc] initWithFrame:CGRectZero];\nvolumeView.showsVolumeSlider = NO;\n[volumeView sizeToFit];\n[self.view addSubview:volumeView];\n```\n可以弹出airplay播放设备，如mac上的air server，但air Server闪退，原因未知\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"AVFoundation学习笔记八-AVPlayer及缩略图等相关功能","published":1,"updated":"2019-07-09T08:13:34.925Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyzlbt9e002f0j66qdgzhulr","content":"<p><img src=\"//www.cyrus.fun/2018/11/08/AVFoundation学习笔记八-AVPlayer及缩略图等相关功能/player_classes.png\" alt=\"\"></p>\n<h3 id=\"AVPlayer\"><a href=\"#AVPlayer\" class=\"headerlink\" title=\"AVPlayer\"></a>AVPlayer</h3><p>一个用来播放基本时间的视听媒体的控制器对象。支持播放从本地、分步下载或通过HTTP Live Streaming协议得到的流媒体，并在多种播放场景中播放这些视频资源。AVPlayer是一个不可见组件，要将视频资源导出到用户界面的目标位置，需要使用AVPlyerLayer类。</p>\n<h3 id=\"AVPlayerLayer\"><a href=\"#AVPlayerLayer\" class=\"headerlink\" title=\"AVPlayerLayer\"></a>AVPlayerLayer</h3><p>构建于Core animation上，是AVFoundation中能找到的为数不多的可见组件。AVPlayerLayer扩展了CoreAnimation的CALayer类，并通过框架在屏幕上显示视频内容。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AVPlayerLayer的videoGravity属性：</span><br><span class=\"line\">AVLayerVideoGravityResizeAspect：默认值，保持视频原始宽高比，可能会有黑边；</span><br><span class=\"line\">AVLayerVideoGravityResizeAspectFill： 保持原始宽高比，短边填充屏幕，长边可能会超出屏幕</span><br><span class=\"line\">AVLayerVideoGravityResize：填充屏幕，不保持宽高比，图像会变形，最不常用。</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"AVPlayerItem\"><a href=\"#AVPlayerItem\" class=\"headerlink\" title=\"AVPlayerItem\"></a>AVPlayerItem</h3><p>AVAsset包含一些媒体数据的静态信息，如创建日期、元数据和时长等，但是没有当前播放时间、音量和查找特定位置的方法这些动态数据，需要AVPlayerItem和AVPlayerItemTrack类构建相应的动态内容。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">代码如下（简单，没啥说的）：</span><br><span class=\"line\">NSURL *assetURL = [[NSBundle mainBundle] URLForResource:@&quot;1&quot; withExtension:@&quot;mp4&quot;];</span><br><span class=\"line\">    AVAsset *asset = [AVAsset assetWithURL:assetURL];</span><br><span class=\"line\">    </span><br><span class=\"line\">    AVPlayerItem *item = [[AVPlayerItem alloc] initWithAsset:asset];</span><br><span class=\"line\">    AVPlayer *player = [[AVPlayer alloc] initWithPlayerItem:item];</span><br><span class=\"line\">    AVPlayerLayer *layer = [AVPlayerLayer playerLayerWithPlayer:player];</span><br><span class=\"line\">    layer.frame = self.view.bounds;</span><br><span class=\"line\">    [self.view.layer addSublayer:layer];</span><br><span class=\"line\">    [player play];</span><br></pre></td></tr></table></figure>\n<h3 id=\"CMTime\"><a href=\"#CMTime\" class=\"headerlink\" title=\"CMTime\"></a>CMTime</h3><p>CMTime是Core Media的一种数据结构。CMTime为时间的正确表示给出了一种结构，即分数值的方式（分子、分母）,定义如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//value/timescale = seconds.</span><br><span class=\"line\">    typedef struct</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        CMTimeValue    value;       //分子 int64_t</span><br><span class=\"line\">        CMTimeScale    timescale;   //分母 int32_t</span><br><span class=\"line\">        CMTimeFlags    flags;</span><br><span class=\"line\">        CMTimeEpoch    epoch;</span><br><span class=\"line\">    &#125; CMTime;</span><br><span class=\"line\">    </span><br><span class=\"line\">    创建</span><br><span class=\"line\">    //0.5s</span><br><span class=\"line\">    CMTime halfSecond = CMTimeMake(1, 2);</span><br><span class=\"line\">    //5s</span><br><span class=\"line\">    CMTime fiveSeconds = CMTimeMake(5, 1);</span><br><span class=\"line\">    //44.1kHz</span><br><span class=\"line\">    CMTime oneSample = CMTimeMake(1, 44100);</span><br><span class=\"line\">    //0</span><br><span class=\"line\">    CMTime zeroTime = kCMTimeZero;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"播放过程中的进度监听\"><a href=\"#播放过程中的进度监听\" class=\"headerlink\" title=\"播放过程中的进度监听\"></a>播放过程中的进度监听</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)addPlayerItemTimeObserver &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // Create 0.5 second refresh interval - REFRESH_INTERVAL == 0.5</span><br><span class=\"line\">    CMTime interval =</span><br><span class=\"line\">        CMTimeMakeWithSeconds(0.5, NSEC_PER_SEC);              // 1</span><br><span class=\"line\">    </span><br><span class=\"line\">    // Main dispatch queue</span><br><span class=\"line\">    dispatch_queue_t queue = dispatch_get_main_queue();                     // 2</span><br><span class=\"line\">    </span><br><span class=\"line\">    // Create callback block for time observer</span><br><span class=\"line\"> </span><br><span class=\"line\">    void (^callback)(CMTime time) = ^(CMTime time) &#123;</span><br><span class=\"line\">        NSTimeInterval currentTime = CMTimeGetSeconds(time);</span><br><span class=\"line\">        NSTimeInterval duration = CMTimeGetSeconds(weakSelf.playerItem.duration);</span><br><span class=\"line\">        //do something with currentTime and duration</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // Add observer and store pointer for future use</span><br><span class=\"line\">    self.timeObserver = [self.player addPeriodicTimeObserverForInterval:interval queue:queue usingBlock:callback];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">可通过： [self.player removeTimeObserver:self.timeObserver]; 移除监听</span><br></pre></td></tr></table></figure>\n<h3 id=\"视频进度缩略图\"><a href=\"#视频进度缩略图\" class=\"headerlink\" title=\"视频进度缩略图\"></a><font color=\"ff0000\">视频进度缩略图</font></h3><p>AVAssetImageGenerator工具类。这个类可以从一个Asset视频曲目中提取图片。生成一个或多个缩略图。主要包含两个方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AVAssetImageGenerator工具类。这个类可以从一个Asset视频曲目中提取图片。生成一个或多个缩略图。主要包含两个方法：</span><br><span class=\"line\">/**</span><br><span class=\"line\">requestedTime: 指定获取缩略图的时间 传入数据</span><br><span class=\"line\">actualTime:    生成图片的准确时间   传出数据</span><br><span class=\"line\">*/</span><br><span class=\"line\"></span><br><span class=\"line\">- (nullable CGImageRef)copyCGImageAtTime:(CMTime)requestedTime actualTime:(nullable CMTime *)actualTime error:(NSError * _Nullable * _Nullable)outError //生成指定时间的单张缩略图</span><br></pre></td></tr></table></figure></p>\n<p>代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//指定时间生成缩略图</span><br><span class=\"line\">//创建URL</span><br><span class=\"line\">    NSURL *url=[NSURL URLWithString:[_videoURLStr stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding]];</span><br><span class=\"line\">    AVURLAsset *urlAsset=[AVURLAsset assetWithURL:url];</span><br><span class=\"line\">    AVAssetImageGenerator *imageGenerator=[AVAssetImageGenerator assetImageGeneratorWithAsset:urlAsset];</span><br><span class=\"line\">    NSError *error=nil;</span><br><span class=\"line\">    CMTime time=CMTimeMakeWithSeconds(timeBySecond, 10);</span><br><span class=\"line\">    CMTime actualTime;</span><br><span class=\"line\">    CGImageRef cgImage= [imageGenerator copyCGImageAtTime:time actualTime:&amp;actualTime error:&amp;error];</span><br><span class=\"line\">    if(error)&#123;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    CMTimeShow(actualTime);</span><br><span class=\"line\">    UIImage *image=[UIImage imageWithCGImage:cgImage];//转化为UIImage</span><br><span class=\"line\">    //保存到相册</span><br><span class=\"line\">    UIImageWriteToSavedPhotosAlbum(image,nil, nil, nil);</span><br><span class=\"line\">    CGImageRelease(cgImage);</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//生成指定时间数组的一组缩略图</span><br><span class=\"line\">typedef void (^AVAssetImageGeneratorCompletionHandler)(CMTime requestedTime, CGImageRef _Nullable image, CMTime actualTime, AVAssetImageGeneratorResult result, NSError * _Nullable error);</span><br><span class=\"line\">- (void)generateCGImagesAsynchronouslyForTimes:(NSArray&lt;NSValue *&gt; *)requestedTimes completionHandler:(AVAssetImageGeneratorCompletionHandler)handler;</span><br><span class=\"line\">- (void)generateThumbnails &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    self.imageGenerator =                                                   // 1</span><br><span class=\"line\">        [AVAssetImageGenerator assetImageGeneratorWithAsset:self.asset];</span><br><span class=\"line\">    </span><br><span class=\"line\">    // Generate the @2x equivalent</span><br><span class=\"line\">    self.imageGenerator.maximumSize = CGSizeMake(200.0f, 0.0f);             // 2</span><br><span class=\"line\">    CMTime duration = self.asset.duration;</span><br><span class=\"line\">    NSMutableArray *times = [NSMutableArray array];                         // 3</span><br><span class=\"line\">    CMTimeValue increment = duration.value / 20;</span><br><span class=\"line\">    CMTimeValue currentValue = 2.0 * duration.timescale;</span><br><span class=\"line\">    while (currentValue &lt;= duration.value) &#123;</span><br><span class=\"line\">        CMTime time = CMTimeMake(currentValue, duration.timescale);</span><br><span class=\"line\">        [times addObject:[NSValue valueWithCMTime:time]];</span><br><span class=\"line\">        currentValue += increment;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    __block NSUInteger imageCount = times.count;                            // 4</span><br><span class=\"line\">    __block NSMutableArray *images = [NSMutableArray array];</span><br><span class=\"line\">    AVAssetImageGeneratorCompletionHandler handler;                         // 5 handler会多次回调，每次生成一张缩略图/失败</span><br><span class=\"line\">    </span><br><span class=\"line\">    handler = ^(CMTime requestedTime,</span><br><span class=\"line\">                CGImageRef imageRef,</span><br><span class=\"line\">                CMTime actualTime,</span><br><span class=\"line\">                AVAssetImageGeneratorResult result,</span><br><span class=\"line\">                NSError *error) &#123;</span><br><span class=\"line\">        if (result == AVAssetImageGeneratorSucceeded) &#123;                     // 6</span><br><span class=\"line\">            UIImage *image = [UIImage imageWithCGImage:imageRef];</span><br><span class=\"line\">            id thumbnail =</span><br><span class=\"line\">                [THThumbnail thumbnailWithImage:image time:actualTime];</span><br><span class=\"line\">            [images addObject:thumbnail];</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            NSLog(@&quot;Error: %@&quot;, [error localizedDescription]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        // If the decremented image count is at 0, we&apos;re all done.</span><br><span class=\"line\">        if (--imageCount == 0) &#123;                                            // 7</span><br><span class=\"line\">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">                NSString *name = THThumbnailsGeneratedNotification;</span><br><span class=\"line\">                NSNotificationCenter *nc = [NSNotificationCenter defaultCenter];</span><br><span class=\"line\">                [nc postNotificationName:name object:images];</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    [self.imageGenerator generateCGImagesAsynchronouslyForTimes:times completionHandler:handler];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"字幕切换\"><a href=\"#字幕切换\" class=\"headerlink\" title=\"字幕切换\"></a>字幕切换</h3><p>AVFoundation在展示字幕和隐藏字幕方面提供了可靠方法。AVPlayerLayer会自动渲染这些元素，并且可以让开发者告诉应用程序哪些元素里面要渲染。完成这些操作需要用到AVMediaSelectionGroup和AVMediaSelectionOption两个类。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSArray *mediaCharacteristics = asset.availableMediaCharacteristicsWithMediaSelectionOptions;</span><br><span class=\"line\">    for (NSString *characteristic in mediaCharacteristics) &#123;</span><br><span class=\"line\">        //可选择的轨道组</span><br><span class=\"line\">        AVMediaSelectionGroup *group = [asset mediaSelectionGroupForMediaCharacteristic:characteristic];</span><br><span class=\"line\">        NSLog(@&quot;%@&quot;, characteristic);</span><br><span class=\"line\">        for (AVMediaSelectionOption *option in group.options) &#123;</span><br><span class=\"line\">            //option:轨道组中的轨道</span><br><span class=\"line\">            NSLog(@&quot;Option:%@&quot;, option.displayName);</span><br><span class=\"line\">            </span><br><span class=\"line\">            //- (void)selectMediaOption:(nullable AVMediaSelectionOption *)mediaSelectionOption inMediaSelectionGroup:(AVMediaSelectionGroup *)mediaSelectionGroup</span><br><span class=\"line\">            //对所择轨道的切换，如切换字幕、音频等</span><br><span class=\"line\">            [item selectMediaOption:option inMediaSelectionGroup:group];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>结果显示：<br><img src=\"//www.cyrus.fun/2018/11/08/AVFoundation学习笔记八-AVPlayer及缩略图等相关功能/option_result.png\" alt=\"\"></p>\n<h3 id=\"airplay\"><a href=\"#airplay\" class=\"headerlink\" title=\"airplay\"></a>airplay</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MPVolumeView *volumeView = [[MPVolumeView alloc] initWithFrame:CGRectZero];</span><br><span class=\"line\">volumeView.showsVolumeSlider = NO;</span><br><span class=\"line\">[volumeView sizeToFit];</span><br><span class=\"line\">[self.view addSubview:volumeView];</span><br></pre></td></tr></table></figure>\n<p>可以弹出airplay播放设备，如mac上的air server，但air Server闪退，原因未知</p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"//www.cyrus.fun/2018/11/08/AVFoundation学习笔记八-AVPlayer及缩略图等相关功能/player_classes.png\" alt=\"\"></p>\n<h3 id=\"AVPlayer\"><a href=\"#AVPlayer\" class=\"headerlink\" title=\"AVPlayer\"></a>AVPlayer</h3><p>一个用来播放基本时间的视听媒体的控制器对象。支持播放从本地、分步下载或通过HTTP Live Streaming协议得到的流媒体，并在多种播放场景中播放这些视频资源。AVPlayer是一个不可见组件，要将视频资源导出到用户界面的目标位置，需要使用AVPlyerLayer类。</p>\n<h3 id=\"AVPlayerLayer\"><a href=\"#AVPlayerLayer\" class=\"headerlink\" title=\"AVPlayerLayer\"></a>AVPlayerLayer</h3><p>构建于Core animation上，是AVFoundation中能找到的为数不多的可见组件。AVPlayerLayer扩展了CoreAnimation的CALayer类，并通过框架在屏幕上显示视频内容。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AVPlayerLayer的videoGravity属性：</span><br><span class=\"line\">AVLayerVideoGravityResizeAspect：默认值，保持视频原始宽高比，可能会有黑边；</span><br><span class=\"line\">AVLayerVideoGravityResizeAspectFill： 保持原始宽高比，短边填充屏幕，长边可能会超出屏幕</span><br><span class=\"line\">AVLayerVideoGravityResize：填充屏幕，不保持宽高比，图像会变形，最不常用。</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"AVPlayerItem\"><a href=\"#AVPlayerItem\" class=\"headerlink\" title=\"AVPlayerItem\"></a>AVPlayerItem</h3><p>AVAsset包含一些媒体数据的静态信息，如创建日期、元数据和时长等，但是没有当前播放时间、音量和查找特定位置的方法这些动态数据，需要AVPlayerItem和AVPlayerItemTrack类构建相应的动态内容。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">代码如下（简单，没啥说的）：</span><br><span class=\"line\">NSURL *assetURL = [[NSBundle mainBundle] URLForResource:@&quot;1&quot; withExtension:@&quot;mp4&quot;];</span><br><span class=\"line\">    AVAsset *asset = [AVAsset assetWithURL:assetURL];</span><br><span class=\"line\">    </span><br><span class=\"line\">    AVPlayerItem *item = [[AVPlayerItem alloc] initWithAsset:asset];</span><br><span class=\"line\">    AVPlayer *player = [[AVPlayer alloc] initWithPlayerItem:item];</span><br><span class=\"line\">    AVPlayerLayer *layer = [AVPlayerLayer playerLayerWithPlayer:player];</span><br><span class=\"line\">    layer.frame = self.view.bounds;</span><br><span class=\"line\">    [self.view.layer addSublayer:layer];</span><br><span class=\"line\">    [player play];</span><br></pre></td></tr></table></figure>\n<h3 id=\"CMTime\"><a href=\"#CMTime\" class=\"headerlink\" title=\"CMTime\"></a>CMTime</h3><p>CMTime是Core Media的一种数据结构。CMTime为时间的正确表示给出了一种结构，即分数值的方式（分子、分母）,定义如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//value/timescale = seconds.</span><br><span class=\"line\">    typedef struct</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        CMTimeValue    value;       //分子 int64_t</span><br><span class=\"line\">        CMTimeScale    timescale;   //分母 int32_t</span><br><span class=\"line\">        CMTimeFlags    flags;</span><br><span class=\"line\">        CMTimeEpoch    epoch;</span><br><span class=\"line\">    &#125; CMTime;</span><br><span class=\"line\">    </span><br><span class=\"line\">    创建</span><br><span class=\"line\">    //0.5s</span><br><span class=\"line\">    CMTime halfSecond = CMTimeMake(1, 2);</span><br><span class=\"line\">    //5s</span><br><span class=\"line\">    CMTime fiveSeconds = CMTimeMake(5, 1);</span><br><span class=\"line\">    //44.1kHz</span><br><span class=\"line\">    CMTime oneSample = CMTimeMake(1, 44100);</span><br><span class=\"line\">    //0</span><br><span class=\"line\">    CMTime zeroTime = kCMTimeZero;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"播放过程中的进度监听\"><a href=\"#播放过程中的进度监听\" class=\"headerlink\" title=\"播放过程中的进度监听\"></a>播放过程中的进度监听</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)addPlayerItemTimeObserver &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // Create 0.5 second refresh interval - REFRESH_INTERVAL == 0.5</span><br><span class=\"line\">    CMTime interval =</span><br><span class=\"line\">        CMTimeMakeWithSeconds(0.5, NSEC_PER_SEC);              // 1</span><br><span class=\"line\">    </span><br><span class=\"line\">    // Main dispatch queue</span><br><span class=\"line\">    dispatch_queue_t queue = dispatch_get_main_queue();                     // 2</span><br><span class=\"line\">    </span><br><span class=\"line\">    // Create callback block for time observer</span><br><span class=\"line\"> </span><br><span class=\"line\">    void (^callback)(CMTime time) = ^(CMTime time) &#123;</span><br><span class=\"line\">        NSTimeInterval currentTime = CMTimeGetSeconds(time);</span><br><span class=\"line\">        NSTimeInterval duration = CMTimeGetSeconds(weakSelf.playerItem.duration);</span><br><span class=\"line\">        //do something with currentTime and duration</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // Add observer and store pointer for future use</span><br><span class=\"line\">    self.timeObserver = [self.player addPeriodicTimeObserverForInterval:interval queue:queue usingBlock:callback];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">可通过： [self.player removeTimeObserver:self.timeObserver]; 移除监听</span><br></pre></td></tr></table></figure>\n<h3 id=\"视频进度缩略图\"><a href=\"#视频进度缩略图\" class=\"headerlink\" title=\"视频进度缩略图\"></a><font color=\"ff0000\">视频进度缩略图</font></h3><p>AVAssetImageGenerator工具类。这个类可以从一个Asset视频曲目中提取图片。生成一个或多个缩略图。主要包含两个方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AVAssetImageGenerator工具类。这个类可以从一个Asset视频曲目中提取图片。生成一个或多个缩略图。主要包含两个方法：</span><br><span class=\"line\">/**</span><br><span class=\"line\">requestedTime: 指定获取缩略图的时间 传入数据</span><br><span class=\"line\">actualTime:    生成图片的准确时间   传出数据</span><br><span class=\"line\">*/</span><br><span class=\"line\"></span><br><span class=\"line\">- (nullable CGImageRef)copyCGImageAtTime:(CMTime)requestedTime actualTime:(nullable CMTime *)actualTime error:(NSError * _Nullable * _Nullable)outError //生成指定时间的单张缩略图</span><br></pre></td></tr></table></figure></p>\n<p>代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//指定时间生成缩略图</span><br><span class=\"line\">//创建URL</span><br><span class=\"line\">    NSURL *url=[NSURL URLWithString:[_videoURLStr stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding]];</span><br><span class=\"line\">    AVURLAsset *urlAsset=[AVURLAsset assetWithURL:url];</span><br><span class=\"line\">    AVAssetImageGenerator *imageGenerator=[AVAssetImageGenerator assetImageGeneratorWithAsset:urlAsset];</span><br><span class=\"line\">    NSError *error=nil;</span><br><span class=\"line\">    CMTime time=CMTimeMakeWithSeconds(timeBySecond, 10);</span><br><span class=\"line\">    CMTime actualTime;</span><br><span class=\"line\">    CGImageRef cgImage= [imageGenerator copyCGImageAtTime:time actualTime:&amp;actualTime error:&amp;error];</span><br><span class=\"line\">    if(error)&#123;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    CMTimeShow(actualTime);</span><br><span class=\"line\">    UIImage *image=[UIImage imageWithCGImage:cgImage];//转化为UIImage</span><br><span class=\"line\">    //保存到相册</span><br><span class=\"line\">    UIImageWriteToSavedPhotosAlbum(image,nil, nil, nil);</span><br><span class=\"line\">    CGImageRelease(cgImage);</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//生成指定时间数组的一组缩略图</span><br><span class=\"line\">typedef void (^AVAssetImageGeneratorCompletionHandler)(CMTime requestedTime, CGImageRef _Nullable image, CMTime actualTime, AVAssetImageGeneratorResult result, NSError * _Nullable error);</span><br><span class=\"line\">- (void)generateCGImagesAsynchronouslyForTimes:(NSArray&lt;NSValue *&gt; *)requestedTimes completionHandler:(AVAssetImageGeneratorCompletionHandler)handler;</span><br><span class=\"line\">- (void)generateThumbnails &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    self.imageGenerator =                                                   // 1</span><br><span class=\"line\">        [AVAssetImageGenerator assetImageGeneratorWithAsset:self.asset];</span><br><span class=\"line\">    </span><br><span class=\"line\">    // Generate the @2x equivalent</span><br><span class=\"line\">    self.imageGenerator.maximumSize = CGSizeMake(200.0f, 0.0f);             // 2</span><br><span class=\"line\">    CMTime duration = self.asset.duration;</span><br><span class=\"line\">    NSMutableArray *times = [NSMutableArray array];                         // 3</span><br><span class=\"line\">    CMTimeValue increment = duration.value / 20;</span><br><span class=\"line\">    CMTimeValue currentValue = 2.0 * duration.timescale;</span><br><span class=\"line\">    while (currentValue &lt;= duration.value) &#123;</span><br><span class=\"line\">        CMTime time = CMTimeMake(currentValue, duration.timescale);</span><br><span class=\"line\">        [times addObject:[NSValue valueWithCMTime:time]];</span><br><span class=\"line\">        currentValue += increment;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    __block NSUInteger imageCount = times.count;                            // 4</span><br><span class=\"line\">    __block NSMutableArray *images = [NSMutableArray array];</span><br><span class=\"line\">    AVAssetImageGeneratorCompletionHandler handler;                         // 5 handler会多次回调，每次生成一张缩略图/失败</span><br><span class=\"line\">    </span><br><span class=\"line\">    handler = ^(CMTime requestedTime,</span><br><span class=\"line\">                CGImageRef imageRef,</span><br><span class=\"line\">                CMTime actualTime,</span><br><span class=\"line\">                AVAssetImageGeneratorResult result,</span><br><span class=\"line\">                NSError *error) &#123;</span><br><span class=\"line\">        if (result == AVAssetImageGeneratorSucceeded) &#123;                     // 6</span><br><span class=\"line\">            UIImage *image = [UIImage imageWithCGImage:imageRef];</span><br><span class=\"line\">            id thumbnail =</span><br><span class=\"line\">                [THThumbnail thumbnailWithImage:image time:actualTime];</span><br><span class=\"line\">            [images addObject:thumbnail];</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            NSLog(@&quot;Error: %@&quot;, [error localizedDescription]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        // If the decremented image count is at 0, we&apos;re all done.</span><br><span class=\"line\">        if (--imageCount == 0) &#123;                                            // 7</span><br><span class=\"line\">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">                NSString *name = THThumbnailsGeneratedNotification;</span><br><span class=\"line\">                NSNotificationCenter *nc = [NSNotificationCenter defaultCenter];</span><br><span class=\"line\">                [nc postNotificationName:name object:images];</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    [self.imageGenerator generateCGImagesAsynchronouslyForTimes:times completionHandler:handler];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"字幕切换\"><a href=\"#字幕切换\" class=\"headerlink\" title=\"字幕切换\"></a>字幕切换</h3><p>AVFoundation在展示字幕和隐藏字幕方面提供了可靠方法。AVPlayerLayer会自动渲染这些元素，并且可以让开发者告诉应用程序哪些元素里面要渲染。完成这些操作需要用到AVMediaSelectionGroup和AVMediaSelectionOption两个类。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSArray *mediaCharacteristics = asset.availableMediaCharacteristicsWithMediaSelectionOptions;</span><br><span class=\"line\">    for (NSString *characteristic in mediaCharacteristics) &#123;</span><br><span class=\"line\">        //可选择的轨道组</span><br><span class=\"line\">        AVMediaSelectionGroup *group = [asset mediaSelectionGroupForMediaCharacteristic:characteristic];</span><br><span class=\"line\">        NSLog(@&quot;%@&quot;, characteristic);</span><br><span class=\"line\">        for (AVMediaSelectionOption *option in group.options) &#123;</span><br><span class=\"line\">            //option:轨道组中的轨道</span><br><span class=\"line\">            NSLog(@&quot;Option:%@&quot;, option.displayName);</span><br><span class=\"line\">            </span><br><span class=\"line\">            //- (void)selectMediaOption:(nullable AVMediaSelectionOption *)mediaSelectionOption inMediaSelectionGroup:(AVMediaSelectionGroup *)mediaSelectionGroup</span><br><span class=\"line\">            //对所择轨道的切换，如切换字幕、音频等</span><br><span class=\"line\">            [item selectMediaOption:option inMediaSelectionGroup:group];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>结果显示：<br><img src=\"//www.cyrus.fun/2018/11/08/AVFoundation学习笔记八-AVPlayer及缩略图等相关功能/option_result.png\" alt=\"\"></p>\n<h3 id=\"airplay\"><a href=\"#airplay\" class=\"headerlink\" title=\"airplay\"></a>airplay</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MPVolumeView *volumeView = [[MPVolumeView alloc] initWithFrame:CGRectZero];</span><br><span class=\"line\">volumeView.showsVolumeSlider = NO;</span><br><span class=\"line\">[volumeView sizeToFit];</span><br><span class=\"line\">[self.view addSubview:volumeView];</span><br></pre></td></tr></table></figure>\n<p>可以弹出airplay播放设备，如mac上的air server，但air Server闪退，原因未知</p>\n"},{"title":"V4L视频采集","author":"Cyrus","date":"2019-01-31T13:59:00.000Z","_content":"V4L是 Video for Linux的缩写,它是Linux 内核中关于视频设备的子系统，它为linux 下的视频驱动提供了统一的接口，使得应用程序可以使用统一的API 函数操作不同的视频设备，极大地简化了视频系统的开发和维护。\n由于早期的 V4L 有很多缺陷，Bill Dirks 等人对其进行了重新设计，并取名为Video for Linux 2(V4L2使用)，最早出现于Linux2.5.x 版本。V4L2 相比于V4L 有更好的扩展性和灵活性，并且支持的硬件设备更多。\n因此在应用程序V4L编程实际是指v4l2,我们这个系列的以V4L2为主,但由于历史的原因,V4L2一般兼容V4L.所以很多程序可以用V4L接口.\n\n### 工作流程\n打开设备－> 检查和设置设备属性－> 设置帧格式－> 设置一种输入输出方法（缓冲区管理）－> 循环获取数据－> 关闭设备。\n#### 1、打开设备\n一般V4L设备结点名是 /dev/videoN.如第一个V4L设备是/dev/video0.\n~~~\nint fd = open(\"/dev/video0\",O_RDWR |O_NONBLOCK);\n~~~\n\n#### 2、检查和设置设备属性\n主要通过ioctl来操作,格式\n~~~\nint ioctl (int __fd, unsigned long int __request, .../*args*/) ;\n~~~\n其中，__request是V4L2一些ioctl命令,常见如下.\n~~~\nVIDIOC_REQBUFS：分配内存\nVIDIOC_QUERYBUF：把VIDIOC_REQBUFS中分配的数据缓存转换成物理地址\nVIDIOC_QUERYCAP：查询驱动功能\nVIDIOC_ENUM_FMT：获取当前驱动支持的视频格式\nVIDIOC_S_FMT：设置当前驱动的频捕获格式\nVIDIOC_G_FMT：读取当前驱动的频捕获格式\nVIDIOC_TRY_FMT：验证当前驱动的显示格式\nVIDIOC_CROPCAP：查询驱动的修剪能力\nVIDIOC_S_CROP：设置视频信号的边框\nVIDIOC_G_CROP：读取视频信号的边框\nVIDIOC_QBUF：把数据从缓存中读取出来\nVIDIOC_DQBUF：把数据放回缓存队列\nVIDIOC_STREAMON：开始视频显示函数\nVIDIOC_STREAMOFF：结束视频显示函数\nVIDIOC_QUERYSTD：检查当前视频设备支持的标准，例如PAL或NTSC。\n~~~\n\n#### 2.1 查询设备属性： VIDIOC_QUERYCAP\n相关函数：\n~~~\nint ioctl(int fd, int request, struct v4l2_capability *argp); \n~~~\n相关结构体：\n~~~\nstruct v4l2_capability  \n{  \nu8 driver[16]; // 驱动名字  \nu8 card[32]; // 设备名字  \nu8 bus_info[32]; // 设备在系统中的位置  \nu32 version; // 驱动版本号  \nu32 capabilities; // 设备支持的操作  \nu32 reserved[4]; // 保留字段  \n}; \n~~~\n\ncapabilities 常用值:\n\nV4L2_CAP_VIDEO_CAPTURE // 是否支持图像获取\n\n例：显示设备信息\n~~~\n\nstruct v4l2_capability cap;    \nioctl(fd,VIDIOC_QUERYCAP,&cap);  \n \nprintf(“Driver Name:%s\\nCard Name:%s\\nBus info:%s\\nDriver Version:%u.%u.%u\\n”,cap.driver,cap.card,cap.bus_info,(cap.version>>16)&0XFF, (cap.version>>8)&0XFF,cap.version&0XFF);  \n~~~\n\n#### 3、设置视频的制式和帧格式\n制式包括PAL，NTSC，帧的格式个包括宽度和高度等。\n\n相关函数\n~~~\nint ioctl(int fd, int request, struct v4l2_fmtdesc *argp);  \n  \nint ioctl(int fd, int request, struct v4l2_format *argp);  \n~~~\n相关结构体：\n\n<font color=ff0000>v4l2_cropcap</font> 结构体用来设置摄像头的捕捉能力，在捕捉上视频时应先先设置\n\nv4l2_cropcap 的 type 域，再通过 VIDIO_CROPCAP 操作命令获取设备捕捉能力的参数，保存于 v4l2_cropcap 结构体中，包括 bounds（最大捕捉方框的左上角坐标和宽高），defrect（默认捕捉方框的左上角坐标和宽高）等。\n\nv4l2_format 结构体用来设置摄像头的视频制式、帧格式等，在设置这个参数时应先填 好 v4l2_format 的各个域，如 type（传输流类型），fmt.pix.width(宽)，fmt.pix.heigth(高)，fmt.pix.field(采样区域，如隔行采样)，fmt.pix.pixelformat(采样类型，如 YUV4:2:2)，然后通过 VIDIO_S_FMT 操作命令设置视频捕捉格式。\n\n#### 3.1 查询并显示所有支持的格式：VIDIOC_ENUM_FMT\n相关函数：\n~~~\nint ioctl(int fd, int request, struct v4l2_fmtdesc *argp);  \n~~~\n相关结构体：\n~~~\nstruct v4l2_fmtdesc   \n{   \nu32 index; // 要查询的格式序号，应用程序设置  \nenum v4l2_buf_type type; // 帧类型，应用程序设置  \nu32 flags; // 是否为压缩格式  \nu8 description[32]; // 格式名称  \nu32 pixelformat; // 格式  \nu32 reserved[4]; // 保留   \n}; \n~~~\n例：显示所有支持的格式\n~~~\nstruct v4l2_fmtdesc fmtdesc; \nfmtdesc.index=0; \nfmtdesc.type=V4L2_BUF_TYPE_VIDEO_CAPTURE; \nprintf(\"Support format:\\n\");  \nwhile(ioctl(fd, VIDIOC_ENUM_FMT, &fmtdesc) != -1)  \n{  \n\tprintf(\"\\t%d.%s\\n\",fmtdesc.index+1,fmtdesc.description);  \n\tfmtdesc.index++;   \n}  \n~~~\n\n#### 3.2 查看或设置当前格式： VIDIOC_G_FMT, VIDIOC_S_FMT\n检查是否支持某种格式：VIDIOC_TRY_FMT\n\n相关函数：\n~~~\nint ioctl(int fd, int request, struct v4l2_format *argp);  \n~~~\n相关结构体：\n~~~\nstruct v4l2_format  \n{  \n\tenum v4l2_buf_type type; // 帧类型，应用程序设置  \n\tunion fmt  {  \n        struct v4l2_pix_format pix; // 视频设备使用  \n        struct v4l2_window win;  \n        struct v4l2_vbi_format vbi;  \n        struct v4l2_sliced_vbi_format sliced;  \n        u8 raw_data[200];  \n    };  \n};  \n  \nstruct v4l2_pix_format  \n{  \n    u32 width; // 帧宽，单位像素  \n    u32 height; // 帧高，单位像素  \n    u32 pixelformat; // 帧格式  \n    enum v4l2_field field;  \n    u32 bytesperline;  \n    u32 sizeimage;  \n    enum v4l2_colorspace colorspace;  \n    u32 priv;  \n};  \n~~~\n\n例:显示当前帧的相关信息\n~~~\nstruct v4l2_format fmt;  \n  \nfmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;  \n  \nioctl(fd, VIDIOC_G_FMT, &fmt);  \n  \nprintf(“Current data format information:\\n\\twidth:%d\\n\\theight:%d\\n”, fmt.fmt.pix.width,fmt.fmt.pix.height);  \n  \nstruct v4l2_fmtdesc fmtdesc;  \n  \nfmtdesc.index = 0;  \n  \nfmtdesc.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;  \n  \nwhile(ioctl(fd,VIDIOC_ENUM_FMT,&fmtdesc) != -1)  \n{  \n    if(fmtdesc.pixelformat & fmt.fmt.pix.pixelformat)  \n    {  \n        printf(“\\tformat:%s\\n”,fmtdesc.description);  \n        break;  \n    }  \n    fmtdesc.index++;  \n}  \n~~~\n\n例：检查是否支持某种帧格式\n~~~\nstruct v4l2_format fmt;   \n  \nfmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;   \n  \nfmt.fmt.pix.pixelformat = V4L2_PIX_FMT_RGB32;   \n  \nif(ioctl(fd,VIDIOC_TRY_FMT,&fmt) == -1)   \n{  \n    if(errno==EINVAL)  \n    {  \n        printf(“not support format RGB32!\\n”);  \n    }  \n} \n~~~\n\n#### 3.3 图像的缩放 VIDIOC_CROPCAP\n相关函数：\n~~~\nint ioctl(int fd, int request, struct v4l2_cropcap *argp);  \nint ioctl(int fd, int request, struct v4l2_crop *argp);  \nint ioctl(int fd, int request, const struct v4l2_crop *argp);\n~~~\n\n相关结构体：\n\nv4l2_cropcap 结构体用来设置摄像头的捕捉能力，在捕捉上视频时应先先设置v4l2_cropcap 的 type 域，再通过 VIDIO_CROPCAP 操作命令获取设备捕捉能力的参数，保存于 v4l2_cropcap 结构体中，包括 bounds（最大捕捉方框的左上角坐标和宽高），defrect（默认捕捉方框的左上角坐标和宽高）等。\n\nCropping 和 scaling 主要指的是图像的取景范围及图片的比例缩放的支持。Crop 就 是把得到的数据作一定的裁剪和伸缩，裁剪可以只取样我们可以得到的图像大小的一部分， 剪裁的主要参数是位置、长度、宽度。而 scale 的设置是通过 VIDIOC_G_FMT 和 VIDIOC_S_FMT 来获得和设置当前的 image 的长度，宽度来实现的。\n\n我们可以假设 bounds 是 sensor 最大能捕捉到的图像范围，而 defrect 是设备默认 的最大取样范围，这个可以通过 VIDIOC_CROPCAP 的 ioctl 来获得设备的 crap 相关的属 性 v4l2_cropcap，其中的 bounds 就是这个 bounds，其实就是上限。每个设备都有个默 认的取样范围，就是 defrect，就是 default rect 的意思，它比 bounds 要小一些。这 个范围也是通过 VIDIOC_CROPCAP 的 ioctl 来获得的 v4l2_cropcap 结构中的 defrect 来表示的，我们可以通过 VIDIOC_G_CROP 和 VIDIOC_S_CROP 来获取和设置设备当前的 crop 设置。\n\n#### 3.4 设置设备捕捉能力的参数\n相关函数：\n~~~\nint ioctl(int fd, int request, struct v4l2_cropcap *argp); \n~~~\n相关结构体：\n~~~\nstruct v4l2_cropcap  \n{  \n    enum v4l2_buf_type type; // 数据流的类型，应用程序设置  \n    struct v4l2_rect bounds; // 这是 camera 的镜头能捕捉到的窗口大小的局限  \n    struct v4l2_rect defrect; // 定义默认窗口大小，包括起点位置及长,宽的大小，大小以像素为单位  \n    struct v4l2_fract pixelaspect; // 定义了图片的宽高比  \n};  \n~~~\n\n#### 3.5 设置窗口取景参数 VIDIOC_G_CROP 和 VIDIOC_S_CROP\n相关函数：\n~~~\nint ioctl(int fd, int request, struct v4l2_crop *argp);  \nint ioctl(int fd, int request, const struct v4l2_crop *argp);\n~~~\n\n相关结构体：\n~~~\nstruct v4l2_crop  \n{  \n    enum v4l2_buf_type type;// 应用程序设置  \n    struct v4l2_rect c;  \n}\n~~~\n\n#### 3.6 video Inputs and Outputs\nVIDIOC_G_INPUT 和 VIDIOC_S_INPUT 用来查询和选则当前的 input，一个 video 设备 节点可能对应多个视频源，比如 saf7113 可以最多支持四路 cvbs 输入，如果上层想在四 个cvbs视频输入间切换，那么就要调用 ioctl(fd, VIDIOC_S_INPUT, &input) 来切换。VIDIOC_G_INPUT and VIDIOC_G_OUTPUT 返回当前的 video input和output的index.\n\n相关函数：\n~~~\nint ioctl(int fd, int request, struct v4l2_input *argp);\n~~~\n相关结构体：\n~~~\nstruct v4l2_input   \n{  \n    __u32 index;    /* Which input */  \n    __u8 name[32];  /* Label */  \n    __u32 type;     /* Type of input */  \n    __u32 audioset; /* Associated audios (bitfield) */  \n    __u32 tuner;    /* Associated tuner */  \n    v4l2_std_id std;  \n    __u32 status;  \n    __u32 reserved[4];  \n}; \n~~~\n我们可以通过VIDIOC_ENUMINPUT and VIDIOC_ENUMOUTPUT 分别列举一个input或者 output的信息，我们使用一个v4l2_input结构体来存放查询结果，这个结构体中有一个 index域用来指定你索要查询的是第几个input/ouput,如果你所查询的这个input是当前正 在使用的，那么在v4l2_input还会包含一些当前的状态信息，如果所 查询的input/output 不存在，那么回返回EINVAL错误，所以，我们通过循环查找，直到返回错误来遍历所有的 input/output. VIDIOC_G_INPUT and VIDIOC_G_OUTPUT 返回当前的video input和output 的index.\n\n### 4、申请和管理缓冲区\n应用程序和设备有三种交换数据的方法，直接 read/write、内存映射(memory mapping)和用户指针。这里只讨论内存映射(memory mapping)。\n\n#### 4.1 向设备申请缓冲区 VIDIOC_REQBUFS\n相关函数：\n~~~\nint ioctl(int fd, int request, struct v4l2_requestbuffers *argp);  \n~~~\n相关结构体：\n~~~\nstruct v4l2_requestbuffers  \n{  \n    u32 count; // 缓冲区内缓冲帧的数目  \n    enum v4l2_buf_type type; // 缓冲帧数据格式  \n    enum v4l2_memory memory; // 区别是内存映射还是用户指针方式  \n    u32 reserved[2];  \n}; \n\n\n注：\nenum v4l2_memoy\n{\n    V4L2_MEMORY_MMAP, V4L2_MEMORY_USERPTR\n\n};\n//count,type,memory 都要应用程序设置\n~~~\n\n例：申请一个拥有四个缓冲帧的缓冲区\n~~~\nstruct v4l2_requestbuffers req;   \nreq.count = 4;    \nreq.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;   \nreq.memory = V4L2_MEMORY_MMAP;   \nioctl(fd,VIDIOC_REQBUFS,&req);  \n~~~\n\n#### 4.2 获取缓冲帧的地址，长度：VIDIOC_QUERYBUF\n相关函数:\n~~~\nint ioctl(int fd, int request, struct v4l2_buffer *argp);  \n~~~\n相关结构体：\n~~~\nstruct v4l2_buffer  \n{  \n    u32 index; //buffer 序号  \n    enum v4l2_buf_type type; //buffer 类型  \n    u32 byteused; //buffer 中已使用的字节数  \n    u32 flags; // 区分是MMAP 还是USERPTR  \n    enum v4l2_field field;  \n    struct timeval timestamp; // 获取第一个字节时的系统时间  \n    struct v4l2_timecode timecode;  \n    u32 sequence; // 队列中的序号  \n    enum v4l2_memory memory; //IO 方式，被应用程序设置  \n    union m  \n    {  \n        u32 offset; // 缓冲帧地址，只对MMAP 有效  \n        unsigned long userptr;  \n    };  \n    u32 length; // 缓冲帧长度  \n    u32 input;  \n    u32 reserved;  \n};\n~~~\n\n#### 4.3 内存映射MMAP 及定义一个结构体来映射每个缓冲帧\n相关结构体：\n~~~\nstruct buffer  \n{  \n    void* start;  \n    unsigned int length;  \n}*buffers; \n~~~\n\n相关函数：\n~~~\nvoid *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset) \n\n//addr 映射起始地址，一般为NULL ，让内核自动选择\n//length 被映射内存块的长度\n//prot 标志映射后能否被读写，其值为PROT_EXEC,PROT_READ,PROT_WRITE, PROT_NONE\n//flags 确定此内存映射能否被其他进程共享，MAP_SHARED,MAP_PRIVATE\n//fd,offset, 确定被映射的内存地址 返回成功映射后的地址，不成功返回MAP_FAILED ((void*)-1)\n~~~\n\n相关函数：\n~~~\nint munmap(void *addr, size_t length);// 断开映射  \n\n//addr 为映射后的地址，length 为映射后的内存长度\n~~~\n\n### 5、启动 或 停止数据流 VIDIOC_STREAMON， VIDIOC_STREAMOFF\n~~~\nint ioctl(int fd, int request, const int *argp);\n\n//argp 为流类型指针，如V4L2_BUF_TYPE_VIDEO_CAPTURE.\n~~~\n\n#### 5.1 在开始之前，还应当把缓冲帧放入缓冲队列：\n~~~\nVIDIOC_QBUF\t\t//把帧放入队列\nVIDIOC_DQBUF\t//从队列中取出帧\n\nint ioctl(int fd, int request, struct v4l2_buffer *argp);  \n~~~\n例：把四个缓冲帧放入队列，并启动数据流\n~~~\nunsigned int i;   \nenum v4l2_buf_type type;  \nfor (i = 0; i < 4; ++i) // 将缓冲帧放入队列  \n{  \n    struct v4l2_buffer buf;  \n    buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;  \n    buf.memory = V4L2_MEMORY_MMAP;  \n    buf.index = i;  \n    ioctl (fd, VIDIOC_QBUF, &buf);  \n}  \ntype = V4L2_BUF_TYPE_VIDEO_CAPTURE;  \nioctl (fd, VIDIOC_STREAMON, &type); \n~~~\n例：获取一帧并处理\n~~~\nstruct v4l2_buffer buf; \nCLEAR (buf);  \nbuf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;  \nbuf.memory = V4L2_MEMORY_MMAP;  \nioctl (fd, VIDIOC_DQBUF, &buf); // 从缓冲区取出一个缓冲帧  \nprocess_image (buffers[buf.index].start); //  \nioctl (fd，VIDIOC_QBUF，&buf); //  \n~~~\n\n附官方 v4l2 video capture example\n~~~\n/* \n *  V4L2 video capture example \n * \n *  This program can be used and distributed without restrictions. \n * \n *      This program is provided with the V4L2 API \n * see http://linuxtv.org/docs.php for more information \n */  \n  \n#include <stdio.h>  \n#include <stdlib.h>  \n#include <string.h>  \n#include <assert.h>  \n  \n#include <getopt.h>             /* getopt_long() */  \n  \n#include <fcntl.h>              /* low-level i/o */  \n#include <unistd.h>  \n#include <errno.h>  \n#include <sys/stat.h>  \n#include <sys/types.h>  \n#include <sys/time.h>  \n#include <sys/mman.h>  \n#include <sys/ioctl.h>  \n  \n#include <linux/videodev2.h>  \n  \n#define CLEAR(x) memset(&(x), 0, sizeof(x))  \n  \nenum io_method {  \n        IO_METHOD_READ,  \n        IO_METHOD_MMAP,  \n        IO_METHOD_USERPTR,  \n};  \n  \nstruct buffer {  \n        void   *start;  \n        size_t  length;  \n};  \n  \nstatic char            *dev_name;  \nstatic enum io_method   io = IO_METHOD_MMAP;  \nstatic int              fd = -1;  \nstruct buffer          *buffers;  \nstatic unsigned int     n_buffers;  \nstatic int              out_buf;  \nstatic int              force_format;  \nstatic int              frame_count = 70;  \n  \n/* \n * \n * \n * \n * \n */  \nstatic void errno_exit(const char *s)  \n{  \n        fprintf(stderr, \"%s error %d, %s\\n\", s, errno, strerror(errno));  \n        exit(EXIT_FAILURE);  \n}  \n  \n  \nstatic int xioctl(int fh, int request, void *arg)  \n{  \n        int r;  \n  \n        do {  \n                r = ioctl(fh, request, arg);  \n        } while (-1 == r && EINTR == errno);  \n  \n        return r;  \n}  \n  \nstatic void process_image(const void *p, int size)  \n{  \n        if (out_buf)  \n                fwrite(p, size, 1, stdout);  \n  \n        fflush(stderr);  \n        fprintf(stderr, \".\");  \n        fflush(stdout);  \n}  \n  \nstatic int read_frame(void)  \n{  \n        struct v4l2_buffer buf;  \n        unsigned int i;  \n  \n        switch (io) {  \n        case IO_METHOD_READ:  \n                if (-1 == read(fd, buffers[0].start, buffers[0].length)) {  \n                        switch (errno) {  \n                        case EAGAIN:  \n                                return 0;  \n  \n                        case EIO:  \n                                /* Could ignore EIO, see spec. */  \n  \n                                /* fall through */  \n  \n                        default:  \n                                errno_exit(\"read\");  \n                        }  \n                }  \n  \n                process_image(buffers[0].start, buffers[0].length);  \n                break;  \n  \n        case IO_METHOD_MMAP:  \n                CLEAR(buf);  \n  \n                buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;  \n                buf.memory = V4L2_MEMORY_MMAP;  \n  \n                if (-1 == xioctl(fd, VIDIOC_DQBUF, &buf)) {  \n                        switch (errno) {  \n                        case EAGAIN:  \n                                return 0;  \n  \n                        case EIO:  \n                                /* Could ignore EIO, see spec. */  \n  \n                                /* fall through */  \n  \n                        default:  \n                                errno_exit(\"VIDIOC_DQBUF\");  \n                        }  \n                }  \n  \n                assert(buf.index < n_buffers);  \n  \n                process_image(buffers[buf.index].start, buf.bytesused);  \n  \n                if (-1 == xioctl(fd, VIDIOC_QBUF, &buf))  \n                        errno_exit(\"VIDIOC_QBUF\");  \n                break;  \n  \n        case IO_METHOD_USERPTR:  \n                CLEAR(buf);  \n  \n                buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;  \n                buf.memory = V4L2_MEMORY_USERPTR;  \n  \n                if (-1 == xioctl(fd, VIDIOC_DQBUF, &buf)) {  \n                        switch (errno) {  \n                        case EAGAIN:  \n                                return 0;  \n  \n                        case EIO:  \n                                /* Could ignore EIO, see spec. */  \n  \n                                /* fall through */  \n  \n                        default:  \n                                errno_exit(\"VIDIOC_DQBUF\");  \n                        }  \n                }  \n  \n                for (i = 0; i < n_buffers; ++i)  \n                        if (buf.m.userptr == (unsigned long)buffers[i].start  \n                            && buf.length == buffers[i].length)  \n                                break;  \n  \n                assert(i < n_buffers);  \n  \n                process_image((void *)buf.m.userptr, buf.bytesused);  \n  \n                if (-1 == xioctl(fd, VIDIOC_QBUF, &buf))  \n                        errno_exit(\"VIDIOC_QBUF\");  \n                break;  \n        }  \n  \n        return 1;  \n}  \n  \n/* two operations \n * step1 : delay \n * step2 : read frame \n */  \nstatic void mainloop(void)  \n{  \n        unsigned int count;  \n  \n        count = frame_count;  \n  \n        while (count-- > 0) {  \n                for (;;) {  \n                        fd_set fds;  \n                        struct timeval tv;  \n                        int r;  \n  \n                        FD_ZERO(&fds);  \n                        FD_SET(fd, &fds);  \n  \n                        /* Timeout. */  \n                        tv.tv_sec = 2;  \n                        tv.tv_usec = 0;  \n  \n                        r = select(fd + 1, &fds, NULL, NULL, &tv);  \n  \n                        if (-1 == r) {  \n                                if (EINTR == errno)  \n                                        continue;  \n                                errno_exit(\"select\");  \n                        }  \n  \n                        if (0 == r) {  \n                                fprintf(stderr, \"select timeout\\n\");  \n                                exit(EXIT_FAILURE);  \n                        }  \n  \n                        if (read_frame())  \n                                break;  \n                        /* EAGAIN - continue select loop. */  \n                }  \n        }  \n}  \n/* \n * one operation \n * step1 : VIDIOC_STREAMOFF \n */  \nstatic void stop_capturing(void)  \n{  \n        enum v4l2_buf_type type;  \n  \n        switch (io) {  \n        case IO_METHOD_READ:  \n                /* Nothing to do. */  \n                break;  \n  \n        case IO_METHOD_MMAP:  \n        case IO_METHOD_USERPTR:  \n                type = V4L2_BUF_TYPE_VIDEO_CAPTURE;  \n                if (-1 == xioctl(fd, VIDIOC_STREAMOFF, &type))  \n                        errno_exit(\"VIDIOC_STREAMOFF\");  \n                break;  \n        }  \n}  \n  \n/* tow operations \n * step1 : VIDIOC_QBUF(insert buffer to queue) \n * step2 : VIDIOC_STREAMOFF \n */  \nstatic void start_capturing(void)  \n{  \n        unsigned int i;  \n        enum v4l2_buf_type type;  \n  \n        switch (io) {  \n        case IO_METHOD_READ:  \n                /* Nothing to do. */  \n                break;  \n  \n        case IO_METHOD_MMAP:  \n                for (i = 0; i < n_buffers; ++i) {  \n                        struct v4l2_buffer buf;  \n  \n                        CLEAR(buf);  \n                        buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;  \n                        buf.memory = V4L2_MEMORY_MMAP;  \n                        buf.index = i;  \n  \n                        if (-1 == xioctl(fd, VIDIOC_QBUF, &buf))  \n                                errno_exit(\"VIDIOC_QBUF\");  \n                }  \n                type = V4L2_BUF_TYPE_VIDEO_CAPTURE;  \n                if (-1 == xioctl(fd, VIDIOC_STREAMON, &type))  \n                        errno_exit(\"VIDIOC_STREAMON\");  \n                break;  \n  \n        case IO_METHOD_USERPTR:  \n                for (i = 0; i < n_buffers; ++i) {  \n                        struct v4l2_buffer buf;  \n  \n                        CLEAR(buf);  \n                        buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;  \n                        buf.memory = V4L2_MEMORY_USERPTR;  \n                        buf.index = i;  \n                        buf.m.userptr = (unsigned long)buffers[i].start;  \n                        buf.length = buffers[i].length;  \n  \n                        if (-1 == xioctl(fd, VIDIOC_QBUF, &buf))  \n                                errno_exit(\"VIDIOC_QBUF\");  \n                }  \n                type = V4L2_BUF_TYPE_VIDEO_CAPTURE;  \n                if (-1 == xioctl(fd, VIDIOC_STREAMON, &type))  \n                        errno_exit(\"VIDIOC_STREAMON\");  \n                break;  \n        }  \n}  \n  \n/* two operations \n * step1 : munmap buffers \n * steo2 : free buffers \n */  \nstatic void uninit_device(void)  \n{  \n        unsigned int i;  \n  \n        switch (io) {  \n        case IO_METHOD_READ:  \n                free(buffers[0].start);  \n                break;  \n  \n        case IO_METHOD_MMAP:  \n                for (i = 0; i < n_buffers; ++i)  \n                        if (-1 == munmap(buffers[i].start, buffers[i].length))  \n                                errno_exit(\"munmap\");  \n                break;  \n  \n        case IO_METHOD_USERPTR:  \n                for (i = 0; i < n_buffers; ++i)  \n                        free(buffers[i].start);  \n                break;  \n        }  \n  \n        free(buffers);  \n}  \n  \nstatic void init_read(unsigned int buffer_size)  \n{  \n        buffers = calloc(1, sizeof(*buffers));  \n  \n        if (!buffers) {  \n                fprintf(stderr, \"Out of memory\\n\");  \n                exit(EXIT_FAILURE);  \n        }  \n  \n        buffers[0].length = buffer_size;  \n        buffers[0].start = malloc(buffer_size);  \n  \n        if (!buffers[0].start) {  \n                fprintf(stderr, \"Out of memory\\n\");  \n                exit(EXIT_FAILURE);  \n        }  \n}  \n  \nstatic void init_mmap(void)  \n{  \n        struct v4l2_requestbuffers req;  \n  \n        CLEAR(req);  \n  \n        req.count = 4;  \n        req.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;  \n        req.memory = V4L2_MEMORY_MMAP;  \n  \n        if (-1 == xioctl(fd, VIDIOC_REQBUFS, &req)) {  \n                if (EINVAL == errno) {  \n                        fprintf(stderr, \"%s does not support \"  \n                                 \"memory mapping\\n\", dev_name);  \n                        exit(EXIT_FAILURE);  \n                } else {  \n                        errno_exit(\"VIDIOC_REQBUFS\");  \n                }  \n        }  \n  \n        if (req.count < 2) {  \n                fprintf(stderr, \"Insufficient buffer memory on %s\\n\",  \n                         dev_name);  \n                exit(EXIT_FAILURE);  \n        }  \n  \n        buffers = calloc(req.count, sizeof(*buffers));  \n  \n        if (!buffers) {  \n                fprintf(stderr, \"Out of memory\\n\");  \n                exit(EXIT_FAILURE);  \n        }  \n  \n        for (n_buffers = 0; n_buffers < req.count; ++n_buffers) {  \n                struct v4l2_buffer buf;  \n  \n                CLEAR(buf);  \n  \n                buf.type        = V4L2_BUF_TYPE_VIDEO_CAPTURE;  \n                buf.memory      = V4L2_MEMORY_MMAP;  \n                buf.index       = n_buffers;  \n  \n                if (-1 == xioctl(fd, VIDIOC_QUERYBUF, &buf))  \n                        errno_exit(\"VIDIOC_QUERYBUF\");  \n  \n                buffers[n_buffers].length = buf.length;  \n                buffers[n_buffers].start =  \n                        mmap(NULL /* start anywhere */,  \n                              buf.length,  \n                              PROT_READ | PROT_WRITE /* required */,  \n                              MAP_SHARED /* recommended */,  \n                              fd, buf.m.offset);  \n  \n                if (MAP_FAILED == buffers[n_buffers].start)  \n                        errno_exit(\"mmap\");  \n        }  \n}  \n  \nstatic void init_userp(unsigned int buffer_size)  \n{  \n        struct v4l2_requestbuffers req;  \n  \n        CLEAR(req);  \n  \n        req.count  = 4;  \n        req.type   = V4L2_BUF_TYPE_VIDEO_CAPTURE;  \n        req.memory = V4L2_MEMORY_USERPTR;  \n  \n        if (-1 == xioctl(fd, VIDIOC_REQBUFS, &req)) {  \n                if (EINVAL == errno) {  \n                        fprintf(stderr, \"%s does not support \"  \n                                 \"user pointer i/o\\n\", dev_name);  \n                        exit(EXIT_FAILURE);  \n                } else {  \n                        errno_exit(\"VIDIOC_REQBUFS\");  \n                }  \n        }  \n  \n        buffers = calloc(4, sizeof(*buffers));  \n  \n        if (!buffers) {  \n                fprintf(stderr, \"Out of memory\\n\");  \n                exit(EXIT_FAILURE);  \n        }  \n  \n        for (n_buffers = 0; n_buffers < 4; ++n_buffers) {  \n                buffers[n_buffers].length = buffer_size;  \n                buffers[n_buffers].start = malloc(buffer_size);  \n  \n                if (!buffers[n_buffers].start) {  \n                        fprintf(stderr, \"Out of memory\\n\");  \n                        exit(EXIT_FAILURE);  \n                }  \n        }  \n}  \n  \n/* five operations \n * step1 : cap :query camera's capability and check it(is a video device? is it support read? is it support streaming?) \n * step2 : cropcap:set cropcap's type and get cropcap by VIDIOC_CROPCAP \n * step3 : set crop parameter by VIDIOC_S_CROP (such as frame type and angle) \n * step4 : set fmt \n * step5 : mmap \n */  \nstatic void init_device(void)  \n{  \n        struct v4l2_capability cap;  \n        struct v4l2_cropcap cropcap;  \n        struct v4l2_crop crop;  \n        struct v4l2_format fmt;  \n        unsigned int min;  \n  \n        if (-1 == xioctl(fd, VIDIOC_QUERYCAP, &cap)) {  \n                if (EINVAL == errno) {  \n                        fprintf(stderr, \"%s is no V4L2 device\\n\",  \n                                 dev_name);  \n                        exit(EXIT_FAILURE);  \n                } else {  \n                        errno_exit(\"VIDIOC_QUERYCAP\");  \n                }  \n        }  \n  \n        if (!(cap.capabilities & V4L2_CAP_VIDEO_CAPTURE)) {  \n                fprintf(stderr, \"%s is no video capture device\\n\",  \n                         dev_name);  \n                exit(EXIT_FAILURE);  \n        }  \n  \n        switch (io) {  \n        case IO_METHOD_READ:  \n                if (!(cap.capabilities & V4L2_CAP_READWRITE)) {  \n                        fprintf(stderr, \"%s does not support read i/o\\n\",  \n                                 dev_name);  \n                        exit(EXIT_FAILURE);  \n                }  \n                break;  \n  \n        case IO_METHOD_MMAP:  \n        case IO_METHOD_USERPTR:  \n                if (!(cap.capabilities & V4L2_CAP_STREAMING)) {  \n                        fprintf(stderr, \"%s does not support streaming i/o\\n\",  \n                                 dev_name);  \n                        exit(EXIT_FAILURE);  \n                }  \n                break;  \n        }  \n  \n  \n        /* Select video input, video standard and tune here. */  \n  \n  \n        CLEAR(cropcap);  \n  \n        cropcap.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;  \n        /* if device support cropcap's type then set crop */  \n        if (0 == xioctl(fd, VIDIOC_CROPCAP, &cropcap)) {  \n                crop.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;  \n                crop.c = cropcap.defrect; /* reset to default */  \n  \n                if (-1 == xioctl(fd, VIDIOC_S_CROP, &crop)) {  \n                        switch (errno) {  \n                        case EINVAL:  \n                                /* Cropping not supported. */  \n                                break;  \n                        default:  \n                                /* Errors ignored. */  \n                                break;  \n                        }  \n                }  \n        } else {  \n                /* Errors ignored. */  \n        }  \n  \n  \n        CLEAR(fmt);  \n  \n        fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;  \n        if (force_format) {  \n                fmt.fmt.pix.width       = 640;  \n                fmt.fmt.pix.height      = 480;  \n                fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_YUYV;  \n                fmt.fmt.pix.field       = V4L2_FIELD_INTERLACED;  \n  \n                if (-1 == xioctl(fd, VIDIOC_S_FMT, &fmt))  \n                        errno_exit(\"VIDIOC_S_FMT\");  \n  \n                /* Note VIDIOC_S_FMT may change width and height. */  \n        } else {  \n                /* Preserve original settings as set by v4l2-ctl for example */  \n                if (-1 == xioctl(fd, VIDIOC_G_FMT, &fmt))  \n                        errno_exit(\"VIDIOC_G_FMT\");  \n        }  \n  \n        /* Buggy driver paranoia. */  \n        min = fmt.fmt.pix.width * 2;  \n        if (fmt.fmt.pix.bytesperline < min)  \n                fmt.fmt.pix.bytesperline = min;  \n        min = fmt.fmt.pix.bytesperline * fmt.fmt.pix.height;  \n        if (fmt.fmt.pix.sizeimage < min)  \n                fmt.fmt.pix.sizeimage = min;  \n  \n        switch (io) {  \n        case IO_METHOD_READ:  \n                init_read(fmt.fmt.pix.sizeimage);  \n                break;  \n  \n        case IO_METHOD_MMAP:  \n                init_mmap();  \n                break;  \n  \n        case IO_METHOD_USERPTR:  \n                init_userp(fmt.fmt.pix.sizeimage);  \n                break;  \n        }  \n}  \n  \n/* \n * close (fd) \n */  \nstatic void close_device(void)  \n{  \n        if (-1 == close(fd))  \n                errno_exit(\"close\");  \n  \n        fd = -1;  \n}  \n  \n/* three operations \n * step 1 : check dev_name and st_mode \n * step 2 : open(device) \n */  \nstatic void open_device(void)  \n{  \n        struct stat st;  \n  \n        if (-1 == stat(dev_name, &st)) {  \n                fprintf(stderr, \"Cannot identify '%s': %d, %s\\n\",  \n                         dev_name, errno, strerror(errno));  \n                exit(EXIT_FAILURE);  \n        }  \n  \n        if (!S_ISCHR(st.st_mode)) {  \n                fprintf(stderr, \"%s is no device\\n\", dev_name);  \n                exit(EXIT_FAILURE);  \n        }  \n  \n        fd = open(dev_name, O_RDWR /* required */ | O_NONBLOCK, 0);  \n  \n        if (-1 == fd) {  \n                fprintf(stderr, \"Cannot open '%s': %d, %s\\n\",  \n                         dev_name, errno, strerror(errno));  \n                exit(EXIT_FAILURE);  \n        }  \n}  \n  \nstatic void usage(FILE *fp, int argc, char **argv)  \n{  \n        fprintf(fp,  \n                 \"Usage: %s [options]\\n\\n\"  \n                 \"Version 1.3\\n\"  \n                 \"Options:\\n\"  \n                 \"-d | --device name   Video device name [%s]\\n\"  \n                 \"-h | --help          Print this message\\n\"  \n                 \"-m | --mmap          Use memory mapped buffers [default]\\n\"  \n                 \"-r | --read          Use read() calls\\n\"  \n                 \"-u | --userp         Use application allocated buffers\\n\"  \n                 \"-o | --output        Outputs stream to stdout\\n\"  \n                 \"-f | --format        Force format to 640x480 YUYV\\n\"  \n                 \"-c | --count         Number of frames to grab [%i]\\n\"  \n                 \"\",  \n                 argv[0], dev_name, frame_count);  \n}  \n  \nstatic const char short_options[] = \"d:hmruofc:\";  \n  \nstatic const struct option  \nlong_options[] = {  \n        { \"device\", required_argument, NULL, 'd' },  \n        { \"help\",   no_argument,       NULL, 'h' },  \n        { \"mmap\",   no_argument,       NULL, 'm' },  \n        { \"read\",   no_argument,       NULL, 'r' },  \n        { \"userp\",  no_argument,       NULL, 'u' },  \n        { \"output\", no_argument,       NULL, 'o' },  \n        { \"format\", no_argument,       NULL, 'f' },  \n        { \"count\",  required_argument, NULL, 'c' },  \n        { 0, 0, 0, 0 }  \n};  \n  \nint main(int argc, char **argv)  \n{  \n        dev_name = \"/dev/video4\";  \n  \n        for (;;) {  \n                int idx;  \n                int c;  \n  \n                c = getopt_long(argc, argv,  \n                                short_options, long_options, &idx);  \n  \n                if (-1 == c)  \n                        break;  \n  \n                switch (c) {  \n                case 0: /* getopt_long() flag */  \n                        break;  \n  \n                case 'd':  \n                        dev_name = optarg;  \n                        break;  \n  \n                case 'h':  \n                        usage(stdout, argc, argv);  \n                        exit(EXIT_SUCCESS);  \n  \n                case 'm':  \n                        io = IO_METHOD_MMAP;  \n                        break;  \n  \n                case 'r':  \n                        io = IO_METHOD_READ;  \n                        break;  \n  \n                case 'u':  \n                        io = IO_METHOD_USERPTR;  \n                        break;  \n  \n                case 'o':  \n                        out_buf++;  \n                        break;  \n  \n                case 'f':  \n                        force_format++;  \n                        break;  \n  \n                case 'c':  \n                        errno = 0;  \n                        frame_count = strtol(optarg, NULL, 0);  \n                        if (errno)  \n                                errno_exit(optarg);  \n                        break;  \n  \n                default:  \n                        usage(stderr, argc, argv);  \n                        exit(EXIT_FAILURE);  \n                }  \n        }  \n  \n        open_device();  \n        init_device();  \n        start_capturing();  \n        mainloop();  \n        stop_capturing();  \n        uninit_device();  \n        close_device();  \n        fprintf(stderr, \"\\n\");  \n        return 0;  \n}  \n~~~\n\n参考：\nhttps://blog.csdn.net/u010164190/article/details/53189836\n\nhttps://blog.csdn.net/qq_38880380/article/details/78261995","source":"_posts/V4L视频采集.md","raw":"title: V4L视频采集\nauthor: Cyrus\ntags: []\ncategories:\n  - 音视频\ndate: 2019-01-31 21:59:00\n---\nV4L是 Video for Linux的缩写,它是Linux 内核中关于视频设备的子系统，它为linux 下的视频驱动提供了统一的接口，使得应用程序可以使用统一的API 函数操作不同的视频设备，极大地简化了视频系统的开发和维护。\n由于早期的 V4L 有很多缺陷，Bill Dirks 等人对其进行了重新设计，并取名为Video for Linux 2(V4L2使用)，最早出现于Linux2.5.x 版本。V4L2 相比于V4L 有更好的扩展性和灵活性，并且支持的硬件设备更多。\n因此在应用程序V4L编程实际是指v4l2,我们这个系列的以V4L2为主,但由于历史的原因,V4L2一般兼容V4L.所以很多程序可以用V4L接口.\n\n### 工作流程\n打开设备－> 检查和设置设备属性－> 设置帧格式－> 设置一种输入输出方法（缓冲区管理）－> 循环获取数据－> 关闭设备。\n#### 1、打开设备\n一般V4L设备结点名是 /dev/videoN.如第一个V4L设备是/dev/video0.\n~~~\nint fd = open(\"/dev/video0\",O_RDWR |O_NONBLOCK);\n~~~\n\n#### 2、检查和设置设备属性\n主要通过ioctl来操作,格式\n~~~\nint ioctl (int __fd, unsigned long int __request, .../*args*/) ;\n~~~\n其中，__request是V4L2一些ioctl命令,常见如下.\n~~~\nVIDIOC_REQBUFS：分配内存\nVIDIOC_QUERYBUF：把VIDIOC_REQBUFS中分配的数据缓存转换成物理地址\nVIDIOC_QUERYCAP：查询驱动功能\nVIDIOC_ENUM_FMT：获取当前驱动支持的视频格式\nVIDIOC_S_FMT：设置当前驱动的频捕获格式\nVIDIOC_G_FMT：读取当前驱动的频捕获格式\nVIDIOC_TRY_FMT：验证当前驱动的显示格式\nVIDIOC_CROPCAP：查询驱动的修剪能力\nVIDIOC_S_CROP：设置视频信号的边框\nVIDIOC_G_CROP：读取视频信号的边框\nVIDIOC_QBUF：把数据从缓存中读取出来\nVIDIOC_DQBUF：把数据放回缓存队列\nVIDIOC_STREAMON：开始视频显示函数\nVIDIOC_STREAMOFF：结束视频显示函数\nVIDIOC_QUERYSTD：检查当前视频设备支持的标准，例如PAL或NTSC。\n~~~\n\n#### 2.1 查询设备属性： VIDIOC_QUERYCAP\n相关函数：\n~~~\nint ioctl(int fd, int request, struct v4l2_capability *argp); \n~~~\n相关结构体：\n~~~\nstruct v4l2_capability  \n{  \nu8 driver[16]; // 驱动名字  \nu8 card[32]; // 设备名字  \nu8 bus_info[32]; // 设备在系统中的位置  \nu32 version; // 驱动版本号  \nu32 capabilities; // 设备支持的操作  \nu32 reserved[4]; // 保留字段  \n}; \n~~~\n\ncapabilities 常用值:\n\nV4L2_CAP_VIDEO_CAPTURE // 是否支持图像获取\n\n例：显示设备信息\n~~~\n\nstruct v4l2_capability cap;    \nioctl(fd,VIDIOC_QUERYCAP,&cap);  \n \nprintf(“Driver Name:%s\\nCard Name:%s\\nBus info:%s\\nDriver Version:%u.%u.%u\\n”,cap.driver,cap.card,cap.bus_info,(cap.version>>16)&0XFF, (cap.version>>8)&0XFF,cap.version&0XFF);  \n~~~\n\n#### 3、设置视频的制式和帧格式\n制式包括PAL，NTSC，帧的格式个包括宽度和高度等。\n\n相关函数\n~~~\nint ioctl(int fd, int request, struct v4l2_fmtdesc *argp);  \n  \nint ioctl(int fd, int request, struct v4l2_format *argp);  \n~~~\n相关结构体：\n\n<font color=ff0000>v4l2_cropcap</font> 结构体用来设置摄像头的捕捉能力，在捕捉上视频时应先先设置\n\nv4l2_cropcap 的 type 域，再通过 VIDIO_CROPCAP 操作命令获取设备捕捉能力的参数，保存于 v4l2_cropcap 结构体中，包括 bounds（最大捕捉方框的左上角坐标和宽高），defrect（默认捕捉方框的左上角坐标和宽高）等。\n\nv4l2_format 结构体用来设置摄像头的视频制式、帧格式等，在设置这个参数时应先填 好 v4l2_format 的各个域，如 type（传输流类型），fmt.pix.width(宽)，fmt.pix.heigth(高)，fmt.pix.field(采样区域，如隔行采样)，fmt.pix.pixelformat(采样类型，如 YUV4:2:2)，然后通过 VIDIO_S_FMT 操作命令设置视频捕捉格式。\n\n#### 3.1 查询并显示所有支持的格式：VIDIOC_ENUM_FMT\n相关函数：\n~~~\nint ioctl(int fd, int request, struct v4l2_fmtdesc *argp);  \n~~~\n相关结构体：\n~~~\nstruct v4l2_fmtdesc   \n{   \nu32 index; // 要查询的格式序号，应用程序设置  \nenum v4l2_buf_type type; // 帧类型，应用程序设置  \nu32 flags; // 是否为压缩格式  \nu8 description[32]; // 格式名称  \nu32 pixelformat; // 格式  \nu32 reserved[4]; // 保留   \n}; \n~~~\n例：显示所有支持的格式\n~~~\nstruct v4l2_fmtdesc fmtdesc; \nfmtdesc.index=0; \nfmtdesc.type=V4L2_BUF_TYPE_VIDEO_CAPTURE; \nprintf(\"Support format:\\n\");  \nwhile(ioctl(fd, VIDIOC_ENUM_FMT, &fmtdesc) != -1)  \n{  \n\tprintf(\"\\t%d.%s\\n\",fmtdesc.index+1,fmtdesc.description);  \n\tfmtdesc.index++;   \n}  \n~~~\n\n#### 3.2 查看或设置当前格式： VIDIOC_G_FMT, VIDIOC_S_FMT\n检查是否支持某种格式：VIDIOC_TRY_FMT\n\n相关函数：\n~~~\nint ioctl(int fd, int request, struct v4l2_format *argp);  \n~~~\n相关结构体：\n~~~\nstruct v4l2_format  \n{  \n\tenum v4l2_buf_type type; // 帧类型，应用程序设置  \n\tunion fmt  {  \n        struct v4l2_pix_format pix; // 视频设备使用  \n        struct v4l2_window win;  \n        struct v4l2_vbi_format vbi;  \n        struct v4l2_sliced_vbi_format sliced;  \n        u8 raw_data[200];  \n    };  \n};  \n  \nstruct v4l2_pix_format  \n{  \n    u32 width; // 帧宽，单位像素  \n    u32 height; // 帧高，单位像素  \n    u32 pixelformat; // 帧格式  \n    enum v4l2_field field;  \n    u32 bytesperline;  \n    u32 sizeimage;  \n    enum v4l2_colorspace colorspace;  \n    u32 priv;  \n};  \n~~~\n\n例:显示当前帧的相关信息\n~~~\nstruct v4l2_format fmt;  \n  \nfmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;  \n  \nioctl(fd, VIDIOC_G_FMT, &fmt);  \n  \nprintf(“Current data format information:\\n\\twidth:%d\\n\\theight:%d\\n”, fmt.fmt.pix.width,fmt.fmt.pix.height);  \n  \nstruct v4l2_fmtdesc fmtdesc;  \n  \nfmtdesc.index = 0;  \n  \nfmtdesc.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;  \n  \nwhile(ioctl(fd,VIDIOC_ENUM_FMT,&fmtdesc) != -1)  \n{  \n    if(fmtdesc.pixelformat & fmt.fmt.pix.pixelformat)  \n    {  \n        printf(“\\tformat:%s\\n”,fmtdesc.description);  \n        break;  \n    }  \n    fmtdesc.index++;  \n}  \n~~~\n\n例：检查是否支持某种帧格式\n~~~\nstruct v4l2_format fmt;   \n  \nfmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;   \n  \nfmt.fmt.pix.pixelformat = V4L2_PIX_FMT_RGB32;   \n  \nif(ioctl(fd,VIDIOC_TRY_FMT,&fmt) == -1)   \n{  \n    if(errno==EINVAL)  \n    {  \n        printf(“not support format RGB32!\\n”);  \n    }  \n} \n~~~\n\n#### 3.3 图像的缩放 VIDIOC_CROPCAP\n相关函数：\n~~~\nint ioctl(int fd, int request, struct v4l2_cropcap *argp);  \nint ioctl(int fd, int request, struct v4l2_crop *argp);  \nint ioctl(int fd, int request, const struct v4l2_crop *argp);\n~~~\n\n相关结构体：\n\nv4l2_cropcap 结构体用来设置摄像头的捕捉能力，在捕捉上视频时应先先设置v4l2_cropcap 的 type 域，再通过 VIDIO_CROPCAP 操作命令获取设备捕捉能力的参数，保存于 v4l2_cropcap 结构体中，包括 bounds（最大捕捉方框的左上角坐标和宽高），defrect（默认捕捉方框的左上角坐标和宽高）等。\n\nCropping 和 scaling 主要指的是图像的取景范围及图片的比例缩放的支持。Crop 就 是把得到的数据作一定的裁剪和伸缩，裁剪可以只取样我们可以得到的图像大小的一部分， 剪裁的主要参数是位置、长度、宽度。而 scale 的设置是通过 VIDIOC_G_FMT 和 VIDIOC_S_FMT 来获得和设置当前的 image 的长度，宽度来实现的。\n\n我们可以假设 bounds 是 sensor 最大能捕捉到的图像范围，而 defrect 是设备默认 的最大取样范围，这个可以通过 VIDIOC_CROPCAP 的 ioctl 来获得设备的 crap 相关的属 性 v4l2_cropcap，其中的 bounds 就是这个 bounds，其实就是上限。每个设备都有个默 认的取样范围，就是 defrect，就是 default rect 的意思，它比 bounds 要小一些。这 个范围也是通过 VIDIOC_CROPCAP 的 ioctl 来获得的 v4l2_cropcap 结构中的 defrect 来表示的，我们可以通过 VIDIOC_G_CROP 和 VIDIOC_S_CROP 来获取和设置设备当前的 crop 设置。\n\n#### 3.4 设置设备捕捉能力的参数\n相关函数：\n~~~\nint ioctl(int fd, int request, struct v4l2_cropcap *argp); \n~~~\n相关结构体：\n~~~\nstruct v4l2_cropcap  \n{  \n    enum v4l2_buf_type type; // 数据流的类型，应用程序设置  \n    struct v4l2_rect bounds; // 这是 camera 的镜头能捕捉到的窗口大小的局限  \n    struct v4l2_rect defrect; // 定义默认窗口大小，包括起点位置及长,宽的大小，大小以像素为单位  \n    struct v4l2_fract pixelaspect; // 定义了图片的宽高比  \n};  \n~~~\n\n#### 3.5 设置窗口取景参数 VIDIOC_G_CROP 和 VIDIOC_S_CROP\n相关函数：\n~~~\nint ioctl(int fd, int request, struct v4l2_crop *argp);  \nint ioctl(int fd, int request, const struct v4l2_crop *argp);\n~~~\n\n相关结构体：\n~~~\nstruct v4l2_crop  \n{  \n    enum v4l2_buf_type type;// 应用程序设置  \n    struct v4l2_rect c;  \n}\n~~~\n\n#### 3.6 video Inputs and Outputs\nVIDIOC_G_INPUT 和 VIDIOC_S_INPUT 用来查询和选则当前的 input，一个 video 设备 节点可能对应多个视频源，比如 saf7113 可以最多支持四路 cvbs 输入，如果上层想在四 个cvbs视频输入间切换，那么就要调用 ioctl(fd, VIDIOC_S_INPUT, &input) 来切换。VIDIOC_G_INPUT and VIDIOC_G_OUTPUT 返回当前的 video input和output的index.\n\n相关函数：\n~~~\nint ioctl(int fd, int request, struct v4l2_input *argp);\n~~~\n相关结构体：\n~~~\nstruct v4l2_input   \n{  \n    __u32 index;    /* Which input */  \n    __u8 name[32];  /* Label */  \n    __u32 type;     /* Type of input */  \n    __u32 audioset; /* Associated audios (bitfield) */  \n    __u32 tuner;    /* Associated tuner */  \n    v4l2_std_id std;  \n    __u32 status;  \n    __u32 reserved[4];  \n}; \n~~~\n我们可以通过VIDIOC_ENUMINPUT and VIDIOC_ENUMOUTPUT 分别列举一个input或者 output的信息，我们使用一个v4l2_input结构体来存放查询结果，这个结构体中有一个 index域用来指定你索要查询的是第几个input/ouput,如果你所查询的这个input是当前正 在使用的，那么在v4l2_input还会包含一些当前的状态信息，如果所 查询的input/output 不存在，那么回返回EINVAL错误，所以，我们通过循环查找，直到返回错误来遍历所有的 input/output. VIDIOC_G_INPUT and VIDIOC_G_OUTPUT 返回当前的video input和output 的index.\n\n### 4、申请和管理缓冲区\n应用程序和设备有三种交换数据的方法，直接 read/write、内存映射(memory mapping)和用户指针。这里只讨论内存映射(memory mapping)。\n\n#### 4.1 向设备申请缓冲区 VIDIOC_REQBUFS\n相关函数：\n~~~\nint ioctl(int fd, int request, struct v4l2_requestbuffers *argp);  \n~~~\n相关结构体：\n~~~\nstruct v4l2_requestbuffers  \n{  \n    u32 count; // 缓冲区内缓冲帧的数目  \n    enum v4l2_buf_type type; // 缓冲帧数据格式  \n    enum v4l2_memory memory; // 区别是内存映射还是用户指针方式  \n    u32 reserved[2];  \n}; \n\n\n注：\nenum v4l2_memoy\n{\n    V4L2_MEMORY_MMAP, V4L2_MEMORY_USERPTR\n\n};\n//count,type,memory 都要应用程序设置\n~~~\n\n例：申请一个拥有四个缓冲帧的缓冲区\n~~~\nstruct v4l2_requestbuffers req;   \nreq.count = 4;    \nreq.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;   \nreq.memory = V4L2_MEMORY_MMAP;   \nioctl(fd,VIDIOC_REQBUFS,&req);  \n~~~\n\n#### 4.2 获取缓冲帧的地址，长度：VIDIOC_QUERYBUF\n相关函数:\n~~~\nint ioctl(int fd, int request, struct v4l2_buffer *argp);  \n~~~\n相关结构体：\n~~~\nstruct v4l2_buffer  \n{  \n    u32 index; //buffer 序号  \n    enum v4l2_buf_type type; //buffer 类型  \n    u32 byteused; //buffer 中已使用的字节数  \n    u32 flags; // 区分是MMAP 还是USERPTR  \n    enum v4l2_field field;  \n    struct timeval timestamp; // 获取第一个字节时的系统时间  \n    struct v4l2_timecode timecode;  \n    u32 sequence; // 队列中的序号  \n    enum v4l2_memory memory; //IO 方式，被应用程序设置  \n    union m  \n    {  \n        u32 offset; // 缓冲帧地址，只对MMAP 有效  \n        unsigned long userptr;  \n    };  \n    u32 length; // 缓冲帧长度  \n    u32 input;  \n    u32 reserved;  \n};\n~~~\n\n#### 4.3 内存映射MMAP 及定义一个结构体来映射每个缓冲帧\n相关结构体：\n~~~\nstruct buffer  \n{  \n    void* start;  \n    unsigned int length;  \n}*buffers; \n~~~\n\n相关函数：\n~~~\nvoid *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset) \n\n//addr 映射起始地址，一般为NULL ，让内核自动选择\n//length 被映射内存块的长度\n//prot 标志映射后能否被读写，其值为PROT_EXEC,PROT_READ,PROT_WRITE, PROT_NONE\n//flags 确定此内存映射能否被其他进程共享，MAP_SHARED,MAP_PRIVATE\n//fd,offset, 确定被映射的内存地址 返回成功映射后的地址，不成功返回MAP_FAILED ((void*)-1)\n~~~\n\n相关函数：\n~~~\nint munmap(void *addr, size_t length);// 断开映射  \n\n//addr 为映射后的地址，length 为映射后的内存长度\n~~~\n\n### 5、启动 或 停止数据流 VIDIOC_STREAMON， VIDIOC_STREAMOFF\n~~~\nint ioctl(int fd, int request, const int *argp);\n\n//argp 为流类型指针，如V4L2_BUF_TYPE_VIDEO_CAPTURE.\n~~~\n\n#### 5.1 在开始之前，还应当把缓冲帧放入缓冲队列：\n~~~\nVIDIOC_QBUF\t\t//把帧放入队列\nVIDIOC_DQBUF\t//从队列中取出帧\n\nint ioctl(int fd, int request, struct v4l2_buffer *argp);  \n~~~\n例：把四个缓冲帧放入队列，并启动数据流\n~~~\nunsigned int i;   \nenum v4l2_buf_type type;  \nfor (i = 0; i < 4; ++i) // 将缓冲帧放入队列  \n{  \n    struct v4l2_buffer buf;  \n    buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;  \n    buf.memory = V4L2_MEMORY_MMAP;  \n    buf.index = i;  \n    ioctl (fd, VIDIOC_QBUF, &buf);  \n}  \ntype = V4L2_BUF_TYPE_VIDEO_CAPTURE;  \nioctl (fd, VIDIOC_STREAMON, &type); \n~~~\n例：获取一帧并处理\n~~~\nstruct v4l2_buffer buf; \nCLEAR (buf);  \nbuf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;  \nbuf.memory = V4L2_MEMORY_MMAP;  \nioctl (fd, VIDIOC_DQBUF, &buf); // 从缓冲区取出一个缓冲帧  \nprocess_image (buffers[buf.index].start); //  \nioctl (fd，VIDIOC_QBUF，&buf); //  \n~~~\n\n附官方 v4l2 video capture example\n~~~\n/* \n *  V4L2 video capture example \n * \n *  This program can be used and distributed without restrictions. \n * \n *      This program is provided with the V4L2 API \n * see http://linuxtv.org/docs.php for more information \n */  \n  \n#include <stdio.h>  \n#include <stdlib.h>  \n#include <string.h>  \n#include <assert.h>  \n  \n#include <getopt.h>             /* getopt_long() */  \n  \n#include <fcntl.h>              /* low-level i/o */  \n#include <unistd.h>  \n#include <errno.h>  \n#include <sys/stat.h>  \n#include <sys/types.h>  \n#include <sys/time.h>  \n#include <sys/mman.h>  \n#include <sys/ioctl.h>  \n  \n#include <linux/videodev2.h>  \n  \n#define CLEAR(x) memset(&(x), 0, sizeof(x))  \n  \nenum io_method {  \n        IO_METHOD_READ,  \n        IO_METHOD_MMAP,  \n        IO_METHOD_USERPTR,  \n};  \n  \nstruct buffer {  \n        void   *start;  \n        size_t  length;  \n};  \n  \nstatic char            *dev_name;  \nstatic enum io_method   io = IO_METHOD_MMAP;  \nstatic int              fd = -1;  \nstruct buffer          *buffers;  \nstatic unsigned int     n_buffers;  \nstatic int              out_buf;  \nstatic int              force_format;  \nstatic int              frame_count = 70;  \n  \n/* \n * \n * \n * \n * \n */  \nstatic void errno_exit(const char *s)  \n{  \n        fprintf(stderr, \"%s error %d, %s\\n\", s, errno, strerror(errno));  \n        exit(EXIT_FAILURE);  \n}  \n  \n  \nstatic int xioctl(int fh, int request, void *arg)  \n{  \n        int r;  \n  \n        do {  \n                r = ioctl(fh, request, arg);  \n        } while (-1 == r && EINTR == errno);  \n  \n        return r;  \n}  \n  \nstatic void process_image(const void *p, int size)  \n{  \n        if (out_buf)  \n                fwrite(p, size, 1, stdout);  \n  \n        fflush(stderr);  \n        fprintf(stderr, \".\");  \n        fflush(stdout);  \n}  \n  \nstatic int read_frame(void)  \n{  \n        struct v4l2_buffer buf;  \n        unsigned int i;  \n  \n        switch (io) {  \n        case IO_METHOD_READ:  \n                if (-1 == read(fd, buffers[0].start, buffers[0].length)) {  \n                        switch (errno) {  \n                        case EAGAIN:  \n                                return 0;  \n  \n                        case EIO:  \n                                /* Could ignore EIO, see spec. */  \n  \n                                /* fall through */  \n  \n                        default:  \n                                errno_exit(\"read\");  \n                        }  \n                }  \n  \n                process_image(buffers[0].start, buffers[0].length);  \n                break;  \n  \n        case IO_METHOD_MMAP:  \n                CLEAR(buf);  \n  \n                buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;  \n                buf.memory = V4L2_MEMORY_MMAP;  \n  \n                if (-1 == xioctl(fd, VIDIOC_DQBUF, &buf)) {  \n                        switch (errno) {  \n                        case EAGAIN:  \n                                return 0;  \n  \n                        case EIO:  \n                                /* Could ignore EIO, see spec. */  \n  \n                                /* fall through */  \n  \n                        default:  \n                                errno_exit(\"VIDIOC_DQBUF\");  \n                        }  \n                }  \n  \n                assert(buf.index < n_buffers);  \n  \n                process_image(buffers[buf.index].start, buf.bytesused);  \n  \n                if (-1 == xioctl(fd, VIDIOC_QBUF, &buf))  \n                        errno_exit(\"VIDIOC_QBUF\");  \n                break;  \n  \n        case IO_METHOD_USERPTR:  \n                CLEAR(buf);  \n  \n                buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;  \n                buf.memory = V4L2_MEMORY_USERPTR;  \n  \n                if (-1 == xioctl(fd, VIDIOC_DQBUF, &buf)) {  \n                        switch (errno) {  \n                        case EAGAIN:  \n                                return 0;  \n  \n                        case EIO:  \n                                /* Could ignore EIO, see spec. */  \n  \n                                /* fall through */  \n  \n                        default:  \n                                errno_exit(\"VIDIOC_DQBUF\");  \n                        }  \n                }  \n  \n                for (i = 0; i < n_buffers; ++i)  \n                        if (buf.m.userptr == (unsigned long)buffers[i].start  \n                            && buf.length == buffers[i].length)  \n                                break;  \n  \n                assert(i < n_buffers);  \n  \n                process_image((void *)buf.m.userptr, buf.bytesused);  \n  \n                if (-1 == xioctl(fd, VIDIOC_QBUF, &buf))  \n                        errno_exit(\"VIDIOC_QBUF\");  \n                break;  \n        }  \n  \n        return 1;  \n}  \n  \n/* two operations \n * step1 : delay \n * step2 : read frame \n */  \nstatic void mainloop(void)  \n{  \n        unsigned int count;  \n  \n        count = frame_count;  \n  \n        while (count-- > 0) {  \n                for (;;) {  \n                        fd_set fds;  \n                        struct timeval tv;  \n                        int r;  \n  \n                        FD_ZERO(&fds);  \n                        FD_SET(fd, &fds);  \n  \n                        /* Timeout. */  \n                        tv.tv_sec = 2;  \n                        tv.tv_usec = 0;  \n  \n                        r = select(fd + 1, &fds, NULL, NULL, &tv);  \n  \n                        if (-1 == r) {  \n                                if (EINTR == errno)  \n                                        continue;  \n                                errno_exit(\"select\");  \n                        }  \n  \n                        if (0 == r) {  \n                                fprintf(stderr, \"select timeout\\n\");  \n                                exit(EXIT_FAILURE);  \n                        }  \n  \n                        if (read_frame())  \n                                break;  \n                        /* EAGAIN - continue select loop. */  \n                }  \n        }  \n}  \n/* \n * one operation \n * step1 : VIDIOC_STREAMOFF \n */  \nstatic void stop_capturing(void)  \n{  \n        enum v4l2_buf_type type;  \n  \n        switch (io) {  \n        case IO_METHOD_READ:  \n                /* Nothing to do. */  \n                break;  \n  \n        case IO_METHOD_MMAP:  \n        case IO_METHOD_USERPTR:  \n                type = V4L2_BUF_TYPE_VIDEO_CAPTURE;  \n                if (-1 == xioctl(fd, VIDIOC_STREAMOFF, &type))  \n                        errno_exit(\"VIDIOC_STREAMOFF\");  \n                break;  \n        }  \n}  \n  \n/* tow operations \n * step1 : VIDIOC_QBUF(insert buffer to queue) \n * step2 : VIDIOC_STREAMOFF \n */  \nstatic void start_capturing(void)  \n{  \n        unsigned int i;  \n        enum v4l2_buf_type type;  \n  \n        switch (io) {  \n        case IO_METHOD_READ:  \n                /* Nothing to do. */  \n                break;  \n  \n        case IO_METHOD_MMAP:  \n                for (i = 0; i < n_buffers; ++i) {  \n                        struct v4l2_buffer buf;  \n  \n                        CLEAR(buf);  \n                        buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;  \n                        buf.memory = V4L2_MEMORY_MMAP;  \n                        buf.index = i;  \n  \n                        if (-1 == xioctl(fd, VIDIOC_QBUF, &buf))  \n                                errno_exit(\"VIDIOC_QBUF\");  \n                }  \n                type = V4L2_BUF_TYPE_VIDEO_CAPTURE;  \n                if (-1 == xioctl(fd, VIDIOC_STREAMON, &type))  \n                        errno_exit(\"VIDIOC_STREAMON\");  \n                break;  \n  \n        case IO_METHOD_USERPTR:  \n                for (i = 0; i < n_buffers; ++i) {  \n                        struct v4l2_buffer buf;  \n  \n                        CLEAR(buf);  \n                        buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;  \n                        buf.memory = V4L2_MEMORY_USERPTR;  \n                        buf.index = i;  \n                        buf.m.userptr = (unsigned long)buffers[i].start;  \n                        buf.length = buffers[i].length;  \n  \n                        if (-1 == xioctl(fd, VIDIOC_QBUF, &buf))  \n                                errno_exit(\"VIDIOC_QBUF\");  \n                }  \n                type = V4L2_BUF_TYPE_VIDEO_CAPTURE;  \n                if (-1 == xioctl(fd, VIDIOC_STREAMON, &type))  \n                        errno_exit(\"VIDIOC_STREAMON\");  \n                break;  \n        }  \n}  \n  \n/* two operations \n * step1 : munmap buffers \n * steo2 : free buffers \n */  \nstatic void uninit_device(void)  \n{  \n        unsigned int i;  \n  \n        switch (io) {  \n        case IO_METHOD_READ:  \n                free(buffers[0].start);  \n                break;  \n  \n        case IO_METHOD_MMAP:  \n                for (i = 0; i < n_buffers; ++i)  \n                        if (-1 == munmap(buffers[i].start, buffers[i].length))  \n                                errno_exit(\"munmap\");  \n                break;  \n  \n        case IO_METHOD_USERPTR:  \n                for (i = 0; i < n_buffers; ++i)  \n                        free(buffers[i].start);  \n                break;  \n        }  \n  \n        free(buffers);  \n}  \n  \nstatic void init_read(unsigned int buffer_size)  \n{  \n        buffers = calloc(1, sizeof(*buffers));  \n  \n        if (!buffers) {  \n                fprintf(stderr, \"Out of memory\\n\");  \n                exit(EXIT_FAILURE);  \n        }  \n  \n        buffers[0].length = buffer_size;  \n        buffers[0].start = malloc(buffer_size);  \n  \n        if (!buffers[0].start) {  \n                fprintf(stderr, \"Out of memory\\n\");  \n                exit(EXIT_FAILURE);  \n        }  \n}  \n  \nstatic void init_mmap(void)  \n{  \n        struct v4l2_requestbuffers req;  \n  \n        CLEAR(req);  \n  \n        req.count = 4;  \n        req.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;  \n        req.memory = V4L2_MEMORY_MMAP;  \n  \n        if (-1 == xioctl(fd, VIDIOC_REQBUFS, &req)) {  \n                if (EINVAL == errno) {  \n                        fprintf(stderr, \"%s does not support \"  \n                                 \"memory mapping\\n\", dev_name);  \n                        exit(EXIT_FAILURE);  \n                } else {  \n                        errno_exit(\"VIDIOC_REQBUFS\");  \n                }  \n        }  \n  \n        if (req.count < 2) {  \n                fprintf(stderr, \"Insufficient buffer memory on %s\\n\",  \n                         dev_name);  \n                exit(EXIT_FAILURE);  \n        }  \n  \n        buffers = calloc(req.count, sizeof(*buffers));  \n  \n        if (!buffers) {  \n                fprintf(stderr, \"Out of memory\\n\");  \n                exit(EXIT_FAILURE);  \n        }  \n  \n        for (n_buffers = 0; n_buffers < req.count; ++n_buffers) {  \n                struct v4l2_buffer buf;  \n  \n                CLEAR(buf);  \n  \n                buf.type        = V4L2_BUF_TYPE_VIDEO_CAPTURE;  \n                buf.memory      = V4L2_MEMORY_MMAP;  \n                buf.index       = n_buffers;  \n  \n                if (-1 == xioctl(fd, VIDIOC_QUERYBUF, &buf))  \n                        errno_exit(\"VIDIOC_QUERYBUF\");  \n  \n                buffers[n_buffers].length = buf.length;  \n                buffers[n_buffers].start =  \n                        mmap(NULL /* start anywhere */,  \n                              buf.length,  \n                              PROT_READ | PROT_WRITE /* required */,  \n                              MAP_SHARED /* recommended */,  \n                              fd, buf.m.offset);  \n  \n                if (MAP_FAILED == buffers[n_buffers].start)  \n                        errno_exit(\"mmap\");  \n        }  \n}  \n  \nstatic void init_userp(unsigned int buffer_size)  \n{  \n        struct v4l2_requestbuffers req;  \n  \n        CLEAR(req);  \n  \n        req.count  = 4;  \n        req.type   = V4L2_BUF_TYPE_VIDEO_CAPTURE;  \n        req.memory = V4L2_MEMORY_USERPTR;  \n  \n        if (-1 == xioctl(fd, VIDIOC_REQBUFS, &req)) {  \n                if (EINVAL == errno) {  \n                        fprintf(stderr, \"%s does not support \"  \n                                 \"user pointer i/o\\n\", dev_name);  \n                        exit(EXIT_FAILURE);  \n                } else {  \n                        errno_exit(\"VIDIOC_REQBUFS\");  \n                }  \n        }  \n  \n        buffers = calloc(4, sizeof(*buffers));  \n  \n        if (!buffers) {  \n                fprintf(stderr, \"Out of memory\\n\");  \n                exit(EXIT_FAILURE);  \n        }  \n  \n        for (n_buffers = 0; n_buffers < 4; ++n_buffers) {  \n                buffers[n_buffers].length = buffer_size;  \n                buffers[n_buffers].start = malloc(buffer_size);  \n  \n                if (!buffers[n_buffers].start) {  \n                        fprintf(stderr, \"Out of memory\\n\");  \n                        exit(EXIT_FAILURE);  \n                }  \n        }  \n}  \n  \n/* five operations \n * step1 : cap :query camera's capability and check it(is a video device? is it support read? is it support streaming?) \n * step2 : cropcap:set cropcap's type and get cropcap by VIDIOC_CROPCAP \n * step3 : set crop parameter by VIDIOC_S_CROP (such as frame type and angle) \n * step4 : set fmt \n * step5 : mmap \n */  \nstatic void init_device(void)  \n{  \n        struct v4l2_capability cap;  \n        struct v4l2_cropcap cropcap;  \n        struct v4l2_crop crop;  \n        struct v4l2_format fmt;  \n        unsigned int min;  \n  \n        if (-1 == xioctl(fd, VIDIOC_QUERYCAP, &cap)) {  \n                if (EINVAL == errno) {  \n                        fprintf(stderr, \"%s is no V4L2 device\\n\",  \n                                 dev_name);  \n                        exit(EXIT_FAILURE);  \n                } else {  \n                        errno_exit(\"VIDIOC_QUERYCAP\");  \n                }  \n        }  \n  \n        if (!(cap.capabilities & V4L2_CAP_VIDEO_CAPTURE)) {  \n                fprintf(stderr, \"%s is no video capture device\\n\",  \n                         dev_name);  \n                exit(EXIT_FAILURE);  \n        }  \n  \n        switch (io) {  \n        case IO_METHOD_READ:  \n                if (!(cap.capabilities & V4L2_CAP_READWRITE)) {  \n                        fprintf(stderr, \"%s does not support read i/o\\n\",  \n                                 dev_name);  \n                        exit(EXIT_FAILURE);  \n                }  \n                break;  \n  \n        case IO_METHOD_MMAP:  \n        case IO_METHOD_USERPTR:  \n                if (!(cap.capabilities & V4L2_CAP_STREAMING)) {  \n                        fprintf(stderr, \"%s does not support streaming i/o\\n\",  \n                                 dev_name);  \n                        exit(EXIT_FAILURE);  \n                }  \n                break;  \n        }  \n  \n  \n        /* Select video input, video standard and tune here. */  \n  \n  \n        CLEAR(cropcap);  \n  \n        cropcap.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;  \n        /* if device support cropcap's type then set crop */  \n        if (0 == xioctl(fd, VIDIOC_CROPCAP, &cropcap)) {  \n                crop.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;  \n                crop.c = cropcap.defrect; /* reset to default */  \n  \n                if (-1 == xioctl(fd, VIDIOC_S_CROP, &crop)) {  \n                        switch (errno) {  \n                        case EINVAL:  \n                                /* Cropping not supported. */  \n                                break;  \n                        default:  \n                                /* Errors ignored. */  \n                                break;  \n                        }  \n                }  \n        } else {  \n                /* Errors ignored. */  \n        }  \n  \n  \n        CLEAR(fmt);  \n  \n        fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;  \n        if (force_format) {  \n                fmt.fmt.pix.width       = 640;  \n                fmt.fmt.pix.height      = 480;  \n                fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_YUYV;  \n                fmt.fmt.pix.field       = V4L2_FIELD_INTERLACED;  \n  \n                if (-1 == xioctl(fd, VIDIOC_S_FMT, &fmt))  \n                        errno_exit(\"VIDIOC_S_FMT\");  \n  \n                /* Note VIDIOC_S_FMT may change width and height. */  \n        } else {  \n                /* Preserve original settings as set by v4l2-ctl for example */  \n                if (-1 == xioctl(fd, VIDIOC_G_FMT, &fmt))  \n                        errno_exit(\"VIDIOC_G_FMT\");  \n        }  \n  \n        /* Buggy driver paranoia. */  \n        min = fmt.fmt.pix.width * 2;  \n        if (fmt.fmt.pix.bytesperline < min)  \n                fmt.fmt.pix.bytesperline = min;  \n        min = fmt.fmt.pix.bytesperline * fmt.fmt.pix.height;  \n        if (fmt.fmt.pix.sizeimage < min)  \n                fmt.fmt.pix.sizeimage = min;  \n  \n        switch (io) {  \n        case IO_METHOD_READ:  \n                init_read(fmt.fmt.pix.sizeimage);  \n                break;  \n  \n        case IO_METHOD_MMAP:  \n                init_mmap();  \n                break;  \n  \n        case IO_METHOD_USERPTR:  \n                init_userp(fmt.fmt.pix.sizeimage);  \n                break;  \n        }  \n}  \n  \n/* \n * close (fd) \n */  \nstatic void close_device(void)  \n{  \n        if (-1 == close(fd))  \n                errno_exit(\"close\");  \n  \n        fd = -1;  \n}  \n  \n/* three operations \n * step 1 : check dev_name and st_mode \n * step 2 : open(device) \n */  \nstatic void open_device(void)  \n{  \n        struct stat st;  \n  \n        if (-1 == stat(dev_name, &st)) {  \n                fprintf(stderr, \"Cannot identify '%s': %d, %s\\n\",  \n                         dev_name, errno, strerror(errno));  \n                exit(EXIT_FAILURE);  \n        }  \n  \n        if (!S_ISCHR(st.st_mode)) {  \n                fprintf(stderr, \"%s is no device\\n\", dev_name);  \n                exit(EXIT_FAILURE);  \n        }  \n  \n        fd = open(dev_name, O_RDWR /* required */ | O_NONBLOCK, 0);  \n  \n        if (-1 == fd) {  \n                fprintf(stderr, \"Cannot open '%s': %d, %s\\n\",  \n                         dev_name, errno, strerror(errno));  \n                exit(EXIT_FAILURE);  \n        }  \n}  \n  \nstatic void usage(FILE *fp, int argc, char **argv)  \n{  \n        fprintf(fp,  \n                 \"Usage: %s [options]\\n\\n\"  \n                 \"Version 1.3\\n\"  \n                 \"Options:\\n\"  \n                 \"-d | --device name   Video device name [%s]\\n\"  \n                 \"-h | --help          Print this message\\n\"  \n                 \"-m | --mmap          Use memory mapped buffers [default]\\n\"  \n                 \"-r | --read          Use read() calls\\n\"  \n                 \"-u | --userp         Use application allocated buffers\\n\"  \n                 \"-o | --output        Outputs stream to stdout\\n\"  \n                 \"-f | --format        Force format to 640x480 YUYV\\n\"  \n                 \"-c | --count         Number of frames to grab [%i]\\n\"  \n                 \"\",  \n                 argv[0], dev_name, frame_count);  \n}  \n  \nstatic const char short_options[] = \"d:hmruofc:\";  \n  \nstatic const struct option  \nlong_options[] = {  \n        { \"device\", required_argument, NULL, 'd' },  \n        { \"help\",   no_argument,       NULL, 'h' },  \n        { \"mmap\",   no_argument,       NULL, 'm' },  \n        { \"read\",   no_argument,       NULL, 'r' },  \n        { \"userp\",  no_argument,       NULL, 'u' },  \n        { \"output\", no_argument,       NULL, 'o' },  \n        { \"format\", no_argument,       NULL, 'f' },  \n        { \"count\",  required_argument, NULL, 'c' },  \n        { 0, 0, 0, 0 }  \n};  \n  \nint main(int argc, char **argv)  \n{  \n        dev_name = \"/dev/video4\";  \n  \n        for (;;) {  \n                int idx;  \n                int c;  \n  \n                c = getopt_long(argc, argv,  \n                                short_options, long_options, &idx);  \n  \n                if (-1 == c)  \n                        break;  \n  \n                switch (c) {  \n                case 0: /* getopt_long() flag */  \n                        break;  \n  \n                case 'd':  \n                        dev_name = optarg;  \n                        break;  \n  \n                case 'h':  \n                        usage(stdout, argc, argv);  \n                        exit(EXIT_SUCCESS);  \n  \n                case 'm':  \n                        io = IO_METHOD_MMAP;  \n                        break;  \n  \n                case 'r':  \n                        io = IO_METHOD_READ;  \n                        break;  \n  \n                case 'u':  \n                        io = IO_METHOD_USERPTR;  \n                        break;  \n  \n                case 'o':  \n                        out_buf++;  \n                        break;  \n  \n                case 'f':  \n                        force_format++;  \n                        break;  \n  \n                case 'c':  \n                        errno = 0;  \n                        frame_count = strtol(optarg, NULL, 0);  \n                        if (errno)  \n                                errno_exit(optarg);  \n                        break;  \n  \n                default:  \n                        usage(stderr, argc, argv);  \n                        exit(EXIT_FAILURE);  \n                }  \n        }  \n  \n        open_device();  \n        init_device();  \n        start_capturing();  \n        mainloop();  \n        stop_capturing();  \n        uninit_device();  \n        close_device();  \n        fprintf(stderr, \"\\n\");  \n        return 0;  \n}  \n~~~\n\n参考：\nhttps://blog.csdn.net/u010164190/article/details/53189836\n\nhttps://blog.csdn.net/qq_38880380/article/details/78261995","slug":"V4L视频采集","published":1,"updated":"2019-07-09T08:13:34.967Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyzlbtbm002j0j66cpjvd7gx","content":"<p>V4L是 Video for Linux的缩写,它是Linux 内核中关于视频设备的子系统，它为linux 下的视频驱动提供了统一的接口，使得应用程序可以使用统一的API 函数操作不同的视频设备，极大地简化了视频系统的开发和维护。<br>由于早期的 V4L 有很多缺陷，Bill Dirks 等人对其进行了重新设计，并取名为Video for Linux 2(V4L2使用)，最早出现于Linux2.5.x 版本。V4L2 相比于V4L 有更好的扩展性和灵活性，并且支持的硬件设备更多。<br>因此在应用程序V4L编程实际是指v4l2,我们这个系列的以V4L2为主,但由于历史的原因,V4L2一般兼容V4L.所以很多程序可以用V4L接口.</p>\n<h3 id=\"工作流程\"><a href=\"#工作流程\" class=\"headerlink\" title=\"工作流程\"></a>工作流程</h3><p>打开设备－&gt; 检查和设置设备属性－&gt; 设置帧格式－&gt; 设置一种输入输出方法（缓冲区管理）－&gt; 循环获取数据－&gt; 关闭设备。</p>\n<h4 id=\"1、打开设备\"><a href=\"#1、打开设备\" class=\"headerlink\" title=\"1、打开设备\"></a>1、打开设备</h4><p>一般V4L设备结点名是 /dev/videoN.如第一个V4L设备是/dev/video0.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int fd = open(&quot;/dev/video0&quot;,O_RDWR |O_NONBLOCK);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"2、检查和设置设备属性\"><a href=\"#2、检查和设置设备属性\" class=\"headerlink\" title=\"2、检查和设置设备属性\"></a>2、检查和设置设备属性</h4><p>主要通过ioctl来操作,格式<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int ioctl (int __fd, unsigned long int __request, .../*args*/) ;</span><br></pre></td></tr></table></figure></p>\n<p>其中，__request是V4L2一些ioctl命令,常见如下.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">VIDIOC_REQBUFS：分配内存</span><br><span class=\"line\">VIDIOC_QUERYBUF：把VIDIOC_REQBUFS中分配的数据缓存转换成物理地址</span><br><span class=\"line\">VIDIOC_QUERYCAP：查询驱动功能</span><br><span class=\"line\">VIDIOC_ENUM_FMT：获取当前驱动支持的视频格式</span><br><span class=\"line\">VIDIOC_S_FMT：设置当前驱动的频捕获格式</span><br><span class=\"line\">VIDIOC_G_FMT：读取当前驱动的频捕获格式</span><br><span class=\"line\">VIDIOC_TRY_FMT：验证当前驱动的显示格式</span><br><span class=\"line\">VIDIOC_CROPCAP：查询驱动的修剪能力</span><br><span class=\"line\">VIDIOC_S_CROP：设置视频信号的边框</span><br><span class=\"line\">VIDIOC_G_CROP：读取视频信号的边框</span><br><span class=\"line\">VIDIOC_QBUF：把数据从缓存中读取出来</span><br><span class=\"line\">VIDIOC_DQBUF：把数据放回缓存队列</span><br><span class=\"line\">VIDIOC_STREAMON：开始视频显示函数</span><br><span class=\"line\">VIDIOC_STREAMOFF：结束视频显示函数</span><br><span class=\"line\">VIDIOC_QUERYSTD：检查当前视频设备支持的标准，例如PAL或NTSC。</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"2-1-查询设备属性：-VIDIOC-QUERYCAP\"><a href=\"#2-1-查询设备属性：-VIDIOC-QUERYCAP\" class=\"headerlink\" title=\"2.1 查询设备属性： VIDIOC_QUERYCAP\"></a>2.1 查询设备属性： VIDIOC_QUERYCAP</h4><p>相关函数：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int ioctl(int fd, int request, struct v4l2_capability *argp);</span><br></pre></td></tr></table></figure></p>\n<p>相关结构体：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct v4l2_capability  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">u8 driver[16]; // 驱动名字  </span><br><span class=\"line\">u8 card[32]; // 设备名字  </span><br><span class=\"line\">u8 bus_info[32]; // 设备在系统中的位置  </span><br><span class=\"line\">u32 version; // 驱动版本号  </span><br><span class=\"line\">u32 capabilities; // 设备支持的操作  </span><br><span class=\"line\">u32 reserved[4]; // 保留字段  </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>capabilities 常用值:</p>\n<p>V4L2_CAP_VIDEO_CAPTURE // 是否支持图像获取</p>\n<p>例：显示设备信息<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">struct v4l2_capability cap;    </span><br><span class=\"line\">ioctl(fd,VIDIOC_QUERYCAP,&amp;cap);  </span><br><span class=\"line\"> </span><br><span class=\"line\">printf(“Driver Name:%s\\nCard Name:%s\\nBus info:%s\\nDriver Version:%u.%u.%u\\n”,cap.driver,cap.card,cap.bus_info,(cap.version&gt;&gt;16)&amp;0XFF, (cap.version&gt;&gt;8)&amp;0XFF,cap.version&amp;0XFF);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3、设置视频的制式和帧格式\"><a href=\"#3、设置视频的制式和帧格式\" class=\"headerlink\" title=\"3、设置视频的制式和帧格式\"></a>3、设置视频的制式和帧格式</h4><p>制式包括PAL，NTSC，帧的格式个包括宽度和高度等。</p>\n<p>相关函数<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int ioctl(int fd, int request, struct v4l2_fmtdesc *argp);  </span><br><span class=\"line\">  </span><br><span class=\"line\">int ioctl(int fd, int request, struct v4l2_format *argp);</span><br></pre></td></tr></table></figure></p>\n<p>相关结构体：</p>\n<p><font color=\"ff0000\">v4l2_cropcap</font> 结构体用来设置摄像头的捕捉能力，在捕捉上视频时应先先设置</p>\n<p>v4l2_cropcap 的 type 域，再通过 VIDIO_CROPCAP 操作命令获取设备捕捉能力的参数，保存于 v4l2_cropcap 结构体中，包括 bounds（最大捕捉方框的左上角坐标和宽高），defrect（默认捕捉方框的左上角坐标和宽高）等。</p>\n<p>v4l2_format 结构体用来设置摄像头的视频制式、帧格式等，在设置这个参数时应先填 好 v4l2_format 的各个域，如 type（传输流类型），fmt.pix.width(宽)，fmt.pix.heigth(高)，fmt.pix.field(采样区域，如隔行采样)，fmt.pix.pixelformat(采样类型，如 YUV4:2:2)，然后通过 VIDIO_S_FMT 操作命令设置视频捕捉格式。</p>\n<h4 id=\"3-1-查询并显示所有支持的格式：VIDIOC-ENUM-FMT\"><a href=\"#3-1-查询并显示所有支持的格式：VIDIOC-ENUM-FMT\" class=\"headerlink\" title=\"3.1 查询并显示所有支持的格式：VIDIOC_ENUM_FMT\"></a>3.1 查询并显示所有支持的格式：VIDIOC_ENUM_FMT</h4><p>相关函数：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int ioctl(int fd, int request, struct v4l2_fmtdesc *argp);</span><br></pre></td></tr></table></figure></p>\n<p>相关结构体：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct v4l2_fmtdesc   </span><br><span class=\"line\">&#123;   </span><br><span class=\"line\">u32 index; // 要查询的格式序号，应用程序设置  </span><br><span class=\"line\">enum v4l2_buf_type type; // 帧类型，应用程序设置  </span><br><span class=\"line\">u32 flags; // 是否为压缩格式  </span><br><span class=\"line\">u8 description[32]; // 格式名称  </span><br><span class=\"line\">u32 pixelformat; // 格式  </span><br><span class=\"line\">u32 reserved[4]; // 保留   </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>例：显示所有支持的格式<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct v4l2_fmtdesc fmtdesc; </span><br><span class=\"line\">fmtdesc.index=0; </span><br><span class=\"line\">fmtdesc.type=V4L2_BUF_TYPE_VIDEO_CAPTURE; </span><br><span class=\"line\">printf(&quot;Support format:\\n&quot;);  </span><br><span class=\"line\">while(ioctl(fd, VIDIOC_ENUM_FMT, &amp;fmtdesc) != -1)  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">\tprintf(&quot;\\t%d.%s\\n&quot;,fmtdesc.index+1,fmtdesc.description);  </span><br><span class=\"line\">\tfmtdesc.index++;   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3-2-查看或设置当前格式：-VIDIOC-G-FMT-VIDIOC-S-FMT\"><a href=\"#3-2-查看或设置当前格式：-VIDIOC-G-FMT-VIDIOC-S-FMT\" class=\"headerlink\" title=\"3.2 查看或设置当前格式： VIDIOC_G_FMT, VIDIOC_S_FMT\"></a>3.2 查看或设置当前格式： VIDIOC_G_FMT, VIDIOC_S_FMT</h4><p>检查是否支持某种格式：VIDIOC_TRY_FMT</p>\n<p>相关函数：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int ioctl(int fd, int request, struct v4l2_format *argp);</span><br></pre></td></tr></table></figure></p>\n<p>相关结构体：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct v4l2_format  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">\tenum v4l2_buf_type type; // 帧类型，应用程序设置  </span><br><span class=\"line\">\tunion fmt  &#123;  </span><br><span class=\"line\">        struct v4l2_pix_format pix; // 视频设备使用  </span><br><span class=\"line\">        struct v4l2_window win;  </span><br><span class=\"line\">        struct v4l2_vbi_format vbi;  </span><br><span class=\"line\">        struct v4l2_sliced_vbi_format sliced;  </span><br><span class=\"line\">        u8 raw_data[200];  </span><br><span class=\"line\">    &#125;;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\">struct v4l2_pix_format  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    u32 width; // 帧宽，单位像素  </span><br><span class=\"line\">    u32 height; // 帧高，单位像素  </span><br><span class=\"line\">    u32 pixelformat; // 帧格式  </span><br><span class=\"line\">    enum v4l2_field field;  </span><br><span class=\"line\">    u32 bytesperline;  </span><br><span class=\"line\">    u32 sizeimage;  </span><br><span class=\"line\">    enum v4l2_colorspace colorspace;  </span><br><span class=\"line\">    u32 priv;  </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>例:显示当前帧的相关信息<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct v4l2_format fmt;  </span><br><span class=\"line\">  </span><br><span class=\"line\">fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;  </span><br><span class=\"line\">  </span><br><span class=\"line\">ioctl(fd, VIDIOC_G_FMT, &amp;fmt);  </span><br><span class=\"line\">  </span><br><span class=\"line\">printf(“Current data format information:\\n\\twidth:%d\\n\\theight:%d\\n”, fmt.fmt.pix.width,fmt.fmt.pix.height);  </span><br><span class=\"line\">  </span><br><span class=\"line\">struct v4l2_fmtdesc fmtdesc;  </span><br><span class=\"line\">  </span><br><span class=\"line\">fmtdesc.index = 0;  </span><br><span class=\"line\">  </span><br><span class=\"line\">fmtdesc.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;  </span><br><span class=\"line\">  </span><br><span class=\"line\">while(ioctl(fd,VIDIOC_ENUM_FMT,&amp;fmtdesc) != -1)  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    if(fmtdesc.pixelformat &amp; fmt.fmt.pix.pixelformat)  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        printf(“\\tformat:%s\\n”,fmtdesc.description);  </span><br><span class=\"line\">        break;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    fmtdesc.index++;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>例：检查是否支持某种帧格式<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct v4l2_format fmt;   </span><br><span class=\"line\">  </span><br><span class=\"line\">fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;   </span><br><span class=\"line\">  </span><br><span class=\"line\">fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_RGB32;   </span><br><span class=\"line\">  </span><br><span class=\"line\">if(ioctl(fd,VIDIOC_TRY_FMT,&amp;fmt) == -1)   </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    if(errno==EINVAL)  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        printf(“not support format RGB32!\\n”);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3-3-图像的缩放-VIDIOC-CROPCAP\"><a href=\"#3-3-图像的缩放-VIDIOC-CROPCAP\" class=\"headerlink\" title=\"3.3 图像的缩放 VIDIOC_CROPCAP\"></a>3.3 图像的缩放 VIDIOC_CROPCAP</h4><p>相关函数：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int ioctl(int fd, int request, struct v4l2_cropcap *argp);  </span><br><span class=\"line\">int ioctl(int fd, int request, struct v4l2_crop *argp);  </span><br><span class=\"line\">int ioctl(int fd, int request, const struct v4l2_crop *argp);</span><br></pre></td></tr></table></figure></p>\n<p>相关结构体：</p>\n<p>v4l2_cropcap 结构体用来设置摄像头的捕捉能力，在捕捉上视频时应先先设置v4l2_cropcap 的 type 域，再通过 VIDIO_CROPCAP 操作命令获取设备捕捉能力的参数，保存于 v4l2_cropcap 结构体中，包括 bounds（最大捕捉方框的左上角坐标和宽高），defrect（默认捕捉方框的左上角坐标和宽高）等。</p>\n<p>Cropping 和 scaling 主要指的是图像的取景范围及图片的比例缩放的支持。Crop 就 是把得到的数据作一定的裁剪和伸缩，裁剪可以只取样我们可以得到的图像大小的一部分， 剪裁的主要参数是位置、长度、宽度。而 scale 的设置是通过 VIDIOC_G_FMT 和 VIDIOC_S_FMT 来获得和设置当前的 image 的长度，宽度来实现的。</p>\n<p>我们可以假设 bounds 是 sensor 最大能捕捉到的图像范围，而 defrect 是设备默认 的最大取样范围，这个可以通过 VIDIOC_CROPCAP 的 ioctl 来获得设备的 crap 相关的属 性 v4l2_cropcap，其中的 bounds 就是这个 bounds，其实就是上限。每个设备都有个默 认的取样范围，就是 defrect，就是 default rect 的意思，它比 bounds 要小一些。这 个范围也是通过 VIDIOC_CROPCAP 的 ioctl 来获得的 v4l2_cropcap 结构中的 defrect 来表示的，我们可以通过 VIDIOC_G_CROP 和 VIDIOC_S_CROP 来获取和设置设备当前的 crop 设置。</p>\n<h4 id=\"3-4-设置设备捕捉能力的参数\"><a href=\"#3-4-设置设备捕捉能力的参数\" class=\"headerlink\" title=\"3.4 设置设备捕捉能力的参数\"></a>3.4 设置设备捕捉能力的参数</h4><p>相关函数：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int ioctl(int fd, int request, struct v4l2_cropcap *argp);</span><br></pre></td></tr></table></figure></p>\n<p>相关结构体：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct v4l2_cropcap  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    enum v4l2_buf_type type; // 数据流的类型，应用程序设置  </span><br><span class=\"line\">    struct v4l2_rect bounds; // 这是 camera 的镜头能捕捉到的窗口大小的局限  </span><br><span class=\"line\">    struct v4l2_rect defrect; // 定义默认窗口大小，包括起点位置及长,宽的大小，大小以像素为单位  </span><br><span class=\"line\">    struct v4l2_fract pixelaspect; // 定义了图片的宽高比  </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3-5-设置窗口取景参数-VIDIOC-G-CROP-和-VIDIOC-S-CROP\"><a href=\"#3-5-设置窗口取景参数-VIDIOC-G-CROP-和-VIDIOC-S-CROP\" class=\"headerlink\" title=\"3.5 设置窗口取景参数 VIDIOC_G_CROP 和 VIDIOC_S_CROP\"></a>3.5 设置窗口取景参数 VIDIOC_G_CROP 和 VIDIOC_S_CROP</h4><p>相关函数：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int ioctl(int fd, int request, struct v4l2_crop *argp);  </span><br><span class=\"line\">int ioctl(int fd, int request, const struct v4l2_crop *argp);</span><br></pre></td></tr></table></figure></p>\n<p>相关结构体：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct v4l2_crop  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    enum v4l2_buf_type type;// 应用程序设置  </span><br><span class=\"line\">    struct v4l2_rect c;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3-6-video-Inputs-and-Outputs\"><a href=\"#3-6-video-Inputs-and-Outputs\" class=\"headerlink\" title=\"3.6 video Inputs and Outputs\"></a>3.6 video Inputs and Outputs</h4><p>VIDIOC_G_INPUT 和 VIDIOC_S_INPUT 用来查询和选则当前的 input，一个 video 设备 节点可能对应多个视频源，比如 saf7113 可以最多支持四路 cvbs 输入，如果上层想在四 个cvbs视频输入间切换，那么就要调用 ioctl(fd, VIDIOC_S_INPUT, &amp;input) 来切换。VIDIOC_G_INPUT and VIDIOC_G_OUTPUT 返回当前的 video input和output的index.</p>\n<p>相关函数：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int ioctl(int fd, int request, struct v4l2_input *argp);</span><br></pre></td></tr></table></figure></p>\n<p>相关结构体：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct v4l2_input   </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    __u32 index;    /* Which input */  </span><br><span class=\"line\">    __u8 name[32];  /* Label */  </span><br><span class=\"line\">    __u32 type;     /* Type of input */  </span><br><span class=\"line\">    __u32 audioset; /* Associated audios (bitfield) */  </span><br><span class=\"line\">    __u32 tuner;    /* Associated tuner */  </span><br><span class=\"line\">    v4l2_std_id std;  </span><br><span class=\"line\">    __u32 status;  </span><br><span class=\"line\">    __u32 reserved[4];  </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>我们可以通过VIDIOC_ENUMINPUT and VIDIOC_ENUMOUTPUT 分别列举一个input或者 output的信息，我们使用一个v4l2_input结构体来存放查询结果，这个结构体中有一个 index域用来指定你索要查询的是第几个input/ouput,如果你所查询的这个input是当前正 在使用的，那么在v4l2_input还会包含一些当前的状态信息，如果所 查询的input/output 不存在，那么回返回EINVAL错误，所以，我们通过循环查找，直到返回错误来遍历所有的 input/output. VIDIOC_G_INPUT and VIDIOC_G_OUTPUT 返回当前的video input和output 的index.</p>\n<h3 id=\"4、申请和管理缓冲区\"><a href=\"#4、申请和管理缓冲区\" class=\"headerlink\" title=\"4、申请和管理缓冲区\"></a>4、申请和管理缓冲区</h3><p>应用程序和设备有三种交换数据的方法，直接 read/write、内存映射(memory mapping)和用户指针。这里只讨论内存映射(memory mapping)。</p>\n<h4 id=\"4-1-向设备申请缓冲区-VIDIOC-REQBUFS\"><a href=\"#4-1-向设备申请缓冲区-VIDIOC-REQBUFS\" class=\"headerlink\" title=\"4.1 向设备申请缓冲区 VIDIOC_REQBUFS\"></a>4.1 向设备申请缓冲区 VIDIOC_REQBUFS</h4><p>相关函数：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int ioctl(int fd, int request, struct v4l2_requestbuffers *argp);</span><br></pre></td></tr></table></figure></p>\n<p>相关结构体：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct v4l2_requestbuffers  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    u32 count; // 缓冲区内缓冲帧的数目  </span><br><span class=\"line\">    enum v4l2_buf_type type; // 缓冲帧数据格式  </span><br><span class=\"line\">    enum v4l2_memory memory; // 区别是内存映射还是用户指针方式  </span><br><span class=\"line\">    u32 reserved[2];  </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">注：</span><br><span class=\"line\">enum v4l2_memoy</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    V4L2_MEMORY_MMAP, V4L2_MEMORY_USERPTR</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">//count,type,memory 都要应用程序设置</span><br></pre></td></tr></table></figure></p>\n<p>例：申请一个拥有四个缓冲帧的缓冲区<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct v4l2_requestbuffers req;   </span><br><span class=\"line\">req.count = 4;    </span><br><span class=\"line\">req.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;   </span><br><span class=\"line\">req.memory = V4L2_MEMORY_MMAP;   </span><br><span class=\"line\">ioctl(fd,VIDIOC_REQBUFS,&amp;req);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"4-2-获取缓冲帧的地址，长度：VIDIOC-QUERYBUF\"><a href=\"#4-2-获取缓冲帧的地址，长度：VIDIOC-QUERYBUF\" class=\"headerlink\" title=\"4.2 获取缓冲帧的地址，长度：VIDIOC_QUERYBUF\"></a>4.2 获取缓冲帧的地址，长度：VIDIOC_QUERYBUF</h4><p>相关函数:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int ioctl(int fd, int request, struct v4l2_buffer *argp);</span><br></pre></td></tr></table></figure></p>\n<p>相关结构体：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct v4l2_buffer  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    u32 index; //buffer 序号  </span><br><span class=\"line\">    enum v4l2_buf_type type; //buffer 类型  </span><br><span class=\"line\">    u32 byteused; //buffer 中已使用的字节数  </span><br><span class=\"line\">    u32 flags; // 区分是MMAP 还是USERPTR  </span><br><span class=\"line\">    enum v4l2_field field;  </span><br><span class=\"line\">    struct timeval timestamp; // 获取第一个字节时的系统时间  </span><br><span class=\"line\">    struct v4l2_timecode timecode;  </span><br><span class=\"line\">    u32 sequence; // 队列中的序号  </span><br><span class=\"line\">    enum v4l2_memory memory; //IO 方式，被应用程序设置  </span><br><span class=\"line\">    union m  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        u32 offset; // 缓冲帧地址，只对MMAP 有效  </span><br><span class=\"line\">        unsigned long userptr;  </span><br><span class=\"line\">    &#125;;  </span><br><span class=\"line\">    u32 length; // 缓冲帧长度  </span><br><span class=\"line\">    u32 input;  </span><br><span class=\"line\">    u32 reserved;  </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"4-3-内存映射MMAP-及定义一个结构体来映射每个缓冲帧\"><a href=\"#4-3-内存映射MMAP-及定义一个结构体来映射每个缓冲帧\" class=\"headerlink\" title=\"4.3 内存映射MMAP 及定义一个结构体来映射每个缓冲帧\"></a>4.3 内存映射MMAP 及定义一个结构体来映射每个缓冲帧</h4><p>相关结构体：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct buffer  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    void* start;  </span><br><span class=\"line\">    unsigned int length;  </span><br><span class=\"line\">&#125;*buffers;</span><br></pre></td></tr></table></figure></p>\n<p>相关函数：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset) </span><br><span class=\"line\"></span><br><span class=\"line\">//addr 映射起始地址，一般为NULL ，让内核自动选择</span><br><span class=\"line\">//length 被映射内存块的长度</span><br><span class=\"line\">//prot 标志映射后能否被读写，其值为PROT_EXEC,PROT_READ,PROT_WRITE, PROT_NONE</span><br><span class=\"line\">//flags 确定此内存映射能否被其他进程共享，MAP_SHARED,MAP_PRIVATE</span><br><span class=\"line\">//fd,offset, 确定被映射的内存地址 返回成功映射后的地址，不成功返回MAP_FAILED ((void*)-1)</span><br></pre></td></tr></table></figure></p>\n<p>相关函数：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int munmap(void *addr, size_t length);// 断开映射  </span><br><span class=\"line\"></span><br><span class=\"line\">//addr 为映射后的地址，length 为映射后的内存长度</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"5、启动-或-停止数据流-VIDIOC-STREAMON，-VIDIOC-STREAMOFF\"><a href=\"#5、启动-或-停止数据流-VIDIOC-STREAMON，-VIDIOC-STREAMOFF\" class=\"headerlink\" title=\"5、启动 或 停止数据流 VIDIOC_STREAMON， VIDIOC_STREAMOFF\"></a>5、启动 或 停止数据流 VIDIOC_STREAMON， VIDIOC_STREAMOFF</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int ioctl(int fd, int request, const int *argp);</span><br><span class=\"line\"></span><br><span class=\"line\">//argp 为流类型指针，如V4L2_BUF_TYPE_VIDEO_CAPTURE.</span><br></pre></td></tr></table></figure>\n<h4 id=\"5-1-在开始之前，还应当把缓冲帧放入缓冲队列：\"><a href=\"#5-1-在开始之前，还应当把缓冲帧放入缓冲队列：\" class=\"headerlink\" title=\"5.1 在开始之前，还应当把缓冲帧放入缓冲队列：\"></a>5.1 在开始之前，还应当把缓冲帧放入缓冲队列：</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">VIDIOC_QBUF\t\t//把帧放入队列</span><br><span class=\"line\">VIDIOC_DQBUF\t//从队列中取出帧</span><br><span class=\"line\"></span><br><span class=\"line\">int ioctl(int fd, int request, struct v4l2_buffer *argp);</span><br></pre></td></tr></table></figure>\n<p>例：把四个缓冲帧放入队列，并启动数据流<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">unsigned int i;   </span><br><span class=\"line\">enum v4l2_buf_type type;  </span><br><span class=\"line\">for (i = 0; i &lt; 4; ++i) // 将缓冲帧放入队列  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    struct v4l2_buffer buf;  </span><br><span class=\"line\">    buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;  </span><br><span class=\"line\">    buf.memory = V4L2_MEMORY_MMAP;  </span><br><span class=\"line\">    buf.index = i;  </span><br><span class=\"line\">    ioctl (fd, VIDIOC_QBUF, &amp;buf);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">type = V4L2_BUF_TYPE_VIDEO_CAPTURE;  </span><br><span class=\"line\">ioctl (fd, VIDIOC_STREAMON, &amp;type);</span><br></pre></td></tr></table></figure></p>\n<p>例：获取一帧并处理<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct v4l2_buffer buf; </span><br><span class=\"line\">CLEAR (buf);  </span><br><span class=\"line\">buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;  </span><br><span class=\"line\">buf.memory = V4L2_MEMORY_MMAP;  </span><br><span class=\"line\">ioctl (fd, VIDIOC_DQBUF, &amp;buf); // 从缓冲区取出一个缓冲帧  </span><br><span class=\"line\">process_image (buffers[buf.index].start); //  </span><br><span class=\"line\">ioctl (fd，VIDIOC_QBUF，&amp;buf); //</span><br></pre></td></tr></table></figure></p>\n<p>附官方 v4l2 video capture example<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br><span class=\"line\">303</span><br><span class=\"line\">304</span><br><span class=\"line\">305</span><br><span class=\"line\">306</span><br><span class=\"line\">307</span><br><span class=\"line\">308</span><br><span class=\"line\">309</span><br><span class=\"line\">310</span><br><span class=\"line\">311</span><br><span class=\"line\">312</span><br><span class=\"line\">313</span><br><span class=\"line\">314</span><br><span class=\"line\">315</span><br><span class=\"line\">316</span><br><span class=\"line\">317</span><br><span class=\"line\">318</span><br><span class=\"line\">319</span><br><span class=\"line\">320</span><br><span class=\"line\">321</span><br><span class=\"line\">322</span><br><span class=\"line\">323</span><br><span class=\"line\">324</span><br><span class=\"line\">325</span><br><span class=\"line\">326</span><br><span class=\"line\">327</span><br><span class=\"line\">328</span><br><span class=\"line\">329</span><br><span class=\"line\">330</span><br><span class=\"line\">331</span><br><span class=\"line\">332</span><br><span class=\"line\">333</span><br><span class=\"line\">334</span><br><span class=\"line\">335</span><br><span class=\"line\">336</span><br><span class=\"line\">337</span><br><span class=\"line\">338</span><br><span class=\"line\">339</span><br><span class=\"line\">340</span><br><span class=\"line\">341</span><br><span class=\"line\">342</span><br><span class=\"line\">343</span><br><span class=\"line\">344</span><br><span class=\"line\">345</span><br><span class=\"line\">346</span><br><span class=\"line\">347</span><br><span class=\"line\">348</span><br><span class=\"line\">349</span><br><span class=\"line\">350</span><br><span class=\"line\">351</span><br><span class=\"line\">352</span><br><span class=\"line\">353</span><br><span class=\"line\">354</span><br><span class=\"line\">355</span><br><span class=\"line\">356</span><br><span class=\"line\">357</span><br><span class=\"line\">358</span><br><span class=\"line\">359</span><br><span class=\"line\">360</span><br><span class=\"line\">361</span><br><span class=\"line\">362</span><br><span class=\"line\">363</span><br><span class=\"line\">364</span><br><span class=\"line\">365</span><br><span class=\"line\">366</span><br><span class=\"line\">367</span><br><span class=\"line\">368</span><br><span class=\"line\">369</span><br><span class=\"line\">370</span><br><span class=\"line\">371</span><br><span class=\"line\">372</span><br><span class=\"line\">373</span><br><span class=\"line\">374</span><br><span class=\"line\">375</span><br><span class=\"line\">376</span><br><span class=\"line\">377</span><br><span class=\"line\">378</span><br><span class=\"line\">379</span><br><span class=\"line\">380</span><br><span class=\"line\">381</span><br><span class=\"line\">382</span><br><span class=\"line\">383</span><br><span class=\"line\">384</span><br><span class=\"line\">385</span><br><span class=\"line\">386</span><br><span class=\"line\">387</span><br><span class=\"line\">388</span><br><span class=\"line\">389</span><br><span class=\"line\">390</span><br><span class=\"line\">391</span><br><span class=\"line\">392</span><br><span class=\"line\">393</span><br><span class=\"line\">394</span><br><span class=\"line\">395</span><br><span class=\"line\">396</span><br><span class=\"line\">397</span><br><span class=\"line\">398</span><br><span class=\"line\">399</span><br><span class=\"line\">400</span><br><span class=\"line\">401</span><br><span class=\"line\">402</span><br><span class=\"line\">403</span><br><span class=\"line\">404</span><br><span class=\"line\">405</span><br><span class=\"line\">406</span><br><span class=\"line\">407</span><br><span class=\"line\">408</span><br><span class=\"line\">409</span><br><span class=\"line\">410</span><br><span class=\"line\">411</span><br><span class=\"line\">412</span><br><span class=\"line\">413</span><br><span class=\"line\">414</span><br><span class=\"line\">415</span><br><span class=\"line\">416</span><br><span class=\"line\">417</span><br><span class=\"line\">418</span><br><span class=\"line\">419</span><br><span class=\"line\">420</span><br><span class=\"line\">421</span><br><span class=\"line\">422</span><br><span class=\"line\">423</span><br><span class=\"line\">424</span><br><span class=\"line\">425</span><br><span class=\"line\">426</span><br><span class=\"line\">427</span><br><span class=\"line\">428</span><br><span class=\"line\">429</span><br><span class=\"line\">430</span><br><span class=\"line\">431</span><br><span class=\"line\">432</span><br><span class=\"line\">433</span><br><span class=\"line\">434</span><br><span class=\"line\">435</span><br><span class=\"line\">436</span><br><span class=\"line\">437</span><br><span class=\"line\">438</span><br><span class=\"line\">439</span><br><span class=\"line\">440</span><br><span class=\"line\">441</span><br><span class=\"line\">442</span><br><span class=\"line\">443</span><br><span class=\"line\">444</span><br><span class=\"line\">445</span><br><span class=\"line\">446</span><br><span class=\"line\">447</span><br><span class=\"line\">448</span><br><span class=\"line\">449</span><br><span class=\"line\">450</span><br><span class=\"line\">451</span><br><span class=\"line\">452</span><br><span class=\"line\">453</span><br><span class=\"line\">454</span><br><span class=\"line\">455</span><br><span class=\"line\">456</span><br><span class=\"line\">457</span><br><span class=\"line\">458</span><br><span class=\"line\">459</span><br><span class=\"line\">460</span><br><span class=\"line\">461</span><br><span class=\"line\">462</span><br><span class=\"line\">463</span><br><span class=\"line\">464</span><br><span class=\"line\">465</span><br><span class=\"line\">466</span><br><span class=\"line\">467</span><br><span class=\"line\">468</span><br><span class=\"line\">469</span><br><span class=\"line\">470</span><br><span class=\"line\">471</span><br><span class=\"line\">472</span><br><span class=\"line\">473</span><br><span class=\"line\">474</span><br><span class=\"line\">475</span><br><span class=\"line\">476</span><br><span class=\"line\">477</span><br><span class=\"line\">478</span><br><span class=\"line\">479</span><br><span class=\"line\">480</span><br><span class=\"line\">481</span><br><span class=\"line\">482</span><br><span class=\"line\">483</span><br><span class=\"line\">484</span><br><span class=\"line\">485</span><br><span class=\"line\">486</span><br><span class=\"line\">487</span><br><span class=\"line\">488</span><br><span class=\"line\">489</span><br><span class=\"line\">490</span><br><span class=\"line\">491</span><br><span class=\"line\">492</span><br><span class=\"line\">493</span><br><span class=\"line\">494</span><br><span class=\"line\">495</span><br><span class=\"line\">496</span><br><span class=\"line\">497</span><br><span class=\"line\">498</span><br><span class=\"line\">499</span><br><span class=\"line\">500</span><br><span class=\"line\">501</span><br><span class=\"line\">502</span><br><span class=\"line\">503</span><br><span class=\"line\">504</span><br><span class=\"line\">505</span><br><span class=\"line\">506</span><br><span class=\"line\">507</span><br><span class=\"line\">508</span><br><span class=\"line\">509</span><br><span class=\"line\">510</span><br><span class=\"line\">511</span><br><span class=\"line\">512</span><br><span class=\"line\">513</span><br><span class=\"line\">514</span><br><span class=\"line\">515</span><br><span class=\"line\">516</span><br><span class=\"line\">517</span><br><span class=\"line\">518</span><br><span class=\"line\">519</span><br><span class=\"line\">520</span><br><span class=\"line\">521</span><br><span class=\"line\">522</span><br><span class=\"line\">523</span><br><span class=\"line\">524</span><br><span class=\"line\">525</span><br><span class=\"line\">526</span><br><span class=\"line\">527</span><br><span class=\"line\">528</span><br><span class=\"line\">529</span><br><span class=\"line\">530</span><br><span class=\"line\">531</span><br><span class=\"line\">532</span><br><span class=\"line\">533</span><br><span class=\"line\">534</span><br><span class=\"line\">535</span><br><span class=\"line\">536</span><br><span class=\"line\">537</span><br><span class=\"line\">538</span><br><span class=\"line\">539</span><br><span class=\"line\">540</span><br><span class=\"line\">541</span><br><span class=\"line\">542</span><br><span class=\"line\">543</span><br><span class=\"line\">544</span><br><span class=\"line\">545</span><br><span class=\"line\">546</span><br><span class=\"line\">547</span><br><span class=\"line\">548</span><br><span class=\"line\">549</span><br><span class=\"line\">550</span><br><span class=\"line\">551</span><br><span class=\"line\">552</span><br><span class=\"line\">553</span><br><span class=\"line\">554</span><br><span class=\"line\">555</span><br><span class=\"line\">556</span><br><span class=\"line\">557</span><br><span class=\"line\">558</span><br><span class=\"line\">559</span><br><span class=\"line\">560</span><br><span class=\"line\">561</span><br><span class=\"line\">562</span><br><span class=\"line\">563</span><br><span class=\"line\">564</span><br><span class=\"line\">565</span><br><span class=\"line\">566</span><br><span class=\"line\">567</span><br><span class=\"line\">568</span><br><span class=\"line\">569</span><br><span class=\"line\">570</span><br><span class=\"line\">571</span><br><span class=\"line\">572</span><br><span class=\"line\">573</span><br><span class=\"line\">574</span><br><span class=\"line\">575</span><br><span class=\"line\">576</span><br><span class=\"line\">577</span><br><span class=\"line\">578</span><br><span class=\"line\">579</span><br><span class=\"line\">580</span><br><span class=\"line\">581</span><br><span class=\"line\">582</span><br><span class=\"line\">583</span><br><span class=\"line\">584</span><br><span class=\"line\">585</span><br><span class=\"line\">586</span><br><span class=\"line\">587</span><br><span class=\"line\">588</span><br><span class=\"line\">589</span><br><span class=\"line\">590</span><br><span class=\"line\">591</span><br><span class=\"line\">592</span><br><span class=\"line\">593</span><br><span class=\"line\">594</span><br><span class=\"line\">595</span><br><span class=\"line\">596</span><br><span class=\"line\">597</span><br><span class=\"line\">598</span><br><span class=\"line\">599</span><br><span class=\"line\">600</span><br><span class=\"line\">601</span><br><span class=\"line\">602</span><br><span class=\"line\">603</span><br><span class=\"line\">604</span><br><span class=\"line\">605</span><br><span class=\"line\">606</span><br><span class=\"line\">607</span><br><span class=\"line\">608</span><br><span class=\"line\">609</span><br><span class=\"line\">610</span><br><span class=\"line\">611</span><br><span class=\"line\">612</span><br><span class=\"line\">613</span><br><span class=\"line\">614</span><br><span class=\"line\">615</span><br><span class=\"line\">616</span><br><span class=\"line\">617</span><br><span class=\"line\">618</span><br><span class=\"line\">619</span><br><span class=\"line\">620</span><br><span class=\"line\">621</span><br><span class=\"line\">622</span><br><span class=\"line\">623</span><br><span class=\"line\">624</span><br><span class=\"line\">625</span><br><span class=\"line\">626</span><br><span class=\"line\">627</span><br><span class=\"line\">628</span><br><span class=\"line\">629</span><br><span class=\"line\">630</span><br><span class=\"line\">631</span><br><span class=\"line\">632</span><br><span class=\"line\">633</span><br><span class=\"line\">634</span><br><span class=\"line\">635</span><br><span class=\"line\">636</span><br><span class=\"line\">637</span><br><span class=\"line\">638</span><br><span class=\"line\">639</span><br><span class=\"line\">640</span><br><span class=\"line\">641</span><br><span class=\"line\">642</span><br><span class=\"line\">643</span><br><span class=\"line\">644</span><br><span class=\"line\">645</span><br><span class=\"line\">646</span><br><span class=\"line\">647</span><br><span class=\"line\">648</span><br><span class=\"line\">649</span><br><span class=\"line\">650</span><br><span class=\"line\">651</span><br><span class=\"line\">652</span><br><span class=\"line\">653</span><br><span class=\"line\">654</span><br><span class=\"line\">655</span><br><span class=\"line\">656</span><br><span class=\"line\">657</span><br><span class=\"line\">658</span><br><span class=\"line\">659</span><br><span class=\"line\">660</span><br><span class=\"line\">661</span><br><span class=\"line\">662</span><br><span class=\"line\">663</span><br><span class=\"line\">664</span><br><span class=\"line\">665</span><br><span class=\"line\">666</span><br><span class=\"line\">667</span><br><span class=\"line\">668</span><br><span class=\"line\">669</span><br><span class=\"line\">670</span><br><span class=\"line\">671</span><br><span class=\"line\">672</span><br><span class=\"line\">673</span><br><span class=\"line\">674</span><br><span class=\"line\">675</span><br><span class=\"line\">676</span><br><span class=\"line\">677</span><br><span class=\"line\">678</span><br><span class=\"line\">679</span><br><span class=\"line\">680</span><br><span class=\"line\">681</span><br><span class=\"line\">682</span><br><span class=\"line\">683</span><br><span class=\"line\">684</span><br><span class=\"line\">685</span><br><span class=\"line\">686</span><br><span class=\"line\">687</span><br><span class=\"line\">688</span><br><span class=\"line\">689</span><br><span class=\"line\">690</span><br><span class=\"line\">691</span><br><span class=\"line\">692</span><br><span class=\"line\">693</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* </span><br><span class=\"line\"> *  V4L2 video capture example </span><br><span class=\"line\"> * </span><br><span class=\"line\"> *  This program can be used and distributed without restrictions. </span><br><span class=\"line\"> * </span><br><span class=\"line\"> *      This program is provided with the V4L2 API </span><br><span class=\"line\"> * see http://linuxtv.org/docs.php for more information </span><br><span class=\"line\"> */  </span><br><span class=\"line\">  </span><br><span class=\"line\">#include &lt;stdio.h&gt;  </span><br><span class=\"line\">#include &lt;stdlib.h&gt;  </span><br><span class=\"line\">#include &lt;string.h&gt;  </span><br><span class=\"line\">#include &lt;assert.h&gt;  </span><br><span class=\"line\">  </span><br><span class=\"line\">#include &lt;getopt.h&gt;             /* getopt_long() */  </span><br><span class=\"line\">  </span><br><span class=\"line\">#include &lt;fcntl.h&gt;              /* low-level i/o */  </span><br><span class=\"line\">#include &lt;unistd.h&gt;  </span><br><span class=\"line\">#include &lt;errno.h&gt;  </span><br><span class=\"line\">#include &lt;sys/stat.h&gt;  </span><br><span class=\"line\">#include &lt;sys/types.h&gt;  </span><br><span class=\"line\">#include &lt;sys/time.h&gt;  </span><br><span class=\"line\">#include &lt;sys/mman.h&gt;  </span><br><span class=\"line\">#include &lt;sys/ioctl.h&gt;  </span><br><span class=\"line\">  </span><br><span class=\"line\">#include &lt;linux/videodev2.h&gt;  </span><br><span class=\"line\">  </span><br><span class=\"line\">#define CLEAR(x) memset(&amp;(x), 0, sizeof(x))  </span><br><span class=\"line\">  </span><br><span class=\"line\">enum io_method &#123;  </span><br><span class=\"line\">        IO_METHOD_READ,  </span><br><span class=\"line\">        IO_METHOD_MMAP,  </span><br><span class=\"line\">        IO_METHOD_USERPTR,  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\">struct buffer &#123;  </span><br><span class=\"line\">        void   *start;  </span><br><span class=\"line\">        size_t  length;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\">static char            *dev_name;  </span><br><span class=\"line\">static enum io_method   io = IO_METHOD_MMAP;  </span><br><span class=\"line\">static int              fd = -1;  </span><br><span class=\"line\">struct buffer          *buffers;  </span><br><span class=\"line\">static unsigned int     n_buffers;  </span><br><span class=\"line\">static int              out_buf;  </span><br><span class=\"line\">static int              force_format;  </span><br><span class=\"line\">static int              frame_count = 70;  </span><br><span class=\"line\">  </span><br><span class=\"line\">/* </span><br><span class=\"line\"> * </span><br><span class=\"line\"> * </span><br><span class=\"line\"> * </span><br><span class=\"line\"> * </span><br><span class=\"line\"> */  </span><br><span class=\"line\">static void errno_exit(const char *s)  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">        fprintf(stderr, &quot;%s error %d, %s\\n&quot;, s, errno, strerror(errno));  </span><br><span class=\"line\">        exit(EXIT_FAILURE);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">static int xioctl(int fh, int request, void *arg)  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">        int r;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        do &#123;  </span><br><span class=\"line\">                r = ioctl(fh, request, arg);  </span><br><span class=\"line\">        &#125; while (-1 == r &amp;&amp; EINTR == errno);  </span><br><span class=\"line\">  </span><br><span class=\"line\">        return r;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">static void process_image(const void *p, int size)  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">        if (out_buf)  </span><br><span class=\"line\">                fwrite(p, size, 1, stdout);  </span><br><span class=\"line\">  </span><br><span class=\"line\">        fflush(stderr);  </span><br><span class=\"line\">        fprintf(stderr, &quot;.&quot;);  </span><br><span class=\"line\">        fflush(stdout);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">static int read_frame(void)  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">        struct v4l2_buffer buf;  </span><br><span class=\"line\">        unsigned int i;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        switch (io) &#123;  </span><br><span class=\"line\">        case IO_METHOD_READ:  </span><br><span class=\"line\">                if (-1 == read(fd, buffers[0].start, buffers[0].length)) &#123;  </span><br><span class=\"line\">                        switch (errno) &#123;  </span><br><span class=\"line\">                        case EAGAIN:  </span><br><span class=\"line\">                                return 0;  </span><br><span class=\"line\">  </span><br><span class=\"line\">                        case EIO:  </span><br><span class=\"line\">                                /* Could ignore EIO, see spec. */  </span><br><span class=\"line\">  </span><br><span class=\"line\">                                /* fall through */  </span><br><span class=\"line\">  </span><br><span class=\"line\">                        default:  </span><br><span class=\"line\">                                errno_exit(&quot;read&quot;);  </span><br><span class=\"line\">                        &#125;  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">                process_image(buffers[0].start, buffers[0].length);  </span><br><span class=\"line\">                break;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        case IO_METHOD_MMAP:  </span><br><span class=\"line\">                CLEAR(buf);  </span><br><span class=\"line\">  </span><br><span class=\"line\">                buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;  </span><br><span class=\"line\">                buf.memory = V4L2_MEMORY_MMAP;  </span><br><span class=\"line\">  </span><br><span class=\"line\">                if (-1 == xioctl(fd, VIDIOC_DQBUF, &amp;buf)) &#123;  </span><br><span class=\"line\">                        switch (errno) &#123;  </span><br><span class=\"line\">                        case EAGAIN:  </span><br><span class=\"line\">                                return 0;  </span><br><span class=\"line\">  </span><br><span class=\"line\">                        case EIO:  </span><br><span class=\"line\">                                /* Could ignore EIO, see spec. */  </span><br><span class=\"line\">  </span><br><span class=\"line\">                                /* fall through */  </span><br><span class=\"line\">  </span><br><span class=\"line\">                        default:  </span><br><span class=\"line\">                                errno_exit(&quot;VIDIOC_DQBUF&quot;);  </span><br><span class=\"line\">                        &#125;  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">                assert(buf.index &lt; n_buffers);  </span><br><span class=\"line\">  </span><br><span class=\"line\">                process_image(buffers[buf.index].start, buf.bytesused);  </span><br><span class=\"line\">  </span><br><span class=\"line\">                if (-1 == xioctl(fd, VIDIOC_QBUF, &amp;buf))  </span><br><span class=\"line\">                        errno_exit(&quot;VIDIOC_QBUF&quot;);  </span><br><span class=\"line\">                break;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        case IO_METHOD_USERPTR:  </span><br><span class=\"line\">                CLEAR(buf);  </span><br><span class=\"line\">  </span><br><span class=\"line\">                buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;  </span><br><span class=\"line\">                buf.memory = V4L2_MEMORY_USERPTR;  </span><br><span class=\"line\">  </span><br><span class=\"line\">                if (-1 == xioctl(fd, VIDIOC_DQBUF, &amp;buf)) &#123;  </span><br><span class=\"line\">                        switch (errno) &#123;  </span><br><span class=\"line\">                        case EAGAIN:  </span><br><span class=\"line\">                                return 0;  </span><br><span class=\"line\">  </span><br><span class=\"line\">                        case EIO:  </span><br><span class=\"line\">                                /* Could ignore EIO, see spec. */  </span><br><span class=\"line\">  </span><br><span class=\"line\">                                /* fall through */  </span><br><span class=\"line\">  </span><br><span class=\"line\">                        default:  </span><br><span class=\"line\">                                errno_exit(&quot;VIDIOC_DQBUF&quot;);  </span><br><span class=\"line\">                        &#125;  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">                for (i = 0; i &lt; n_buffers; ++i)  </span><br><span class=\"line\">                        if (buf.m.userptr == (unsigned long)buffers[i].start  </span><br><span class=\"line\">                            &amp;&amp; buf.length == buffers[i].length)  </span><br><span class=\"line\">                                break;  </span><br><span class=\"line\">  </span><br><span class=\"line\">                assert(i &lt; n_buffers);  </span><br><span class=\"line\">  </span><br><span class=\"line\">                process_image((void *)buf.m.userptr, buf.bytesused);  </span><br><span class=\"line\">  </span><br><span class=\"line\">                if (-1 == xioctl(fd, VIDIOC_QBUF, &amp;buf))  </span><br><span class=\"line\">                        errno_exit(&quot;VIDIOC_QBUF&quot;);  </span><br><span class=\"line\">                break;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        return 1;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">/* two operations </span><br><span class=\"line\"> * step1 : delay </span><br><span class=\"line\"> * step2 : read frame </span><br><span class=\"line\"> */  </span><br><span class=\"line\">static void mainloop(void)  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">        unsigned int count;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        count = frame_count;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        while (count-- &gt; 0) &#123;  </span><br><span class=\"line\">                for (;;) &#123;  </span><br><span class=\"line\">                        fd_set fds;  </span><br><span class=\"line\">                        struct timeval tv;  </span><br><span class=\"line\">                        int r;  </span><br><span class=\"line\">  </span><br><span class=\"line\">                        FD_ZERO(&amp;fds);  </span><br><span class=\"line\">                        FD_SET(fd, &amp;fds);  </span><br><span class=\"line\">  </span><br><span class=\"line\">                        /* Timeout. */  </span><br><span class=\"line\">                        tv.tv_sec = 2;  </span><br><span class=\"line\">                        tv.tv_usec = 0;  </span><br><span class=\"line\">  </span><br><span class=\"line\">                        r = select(fd + 1, &amp;fds, NULL, NULL, &amp;tv);  </span><br><span class=\"line\">  </span><br><span class=\"line\">                        if (-1 == r) &#123;  </span><br><span class=\"line\">                                if (EINTR == errno)  </span><br><span class=\"line\">                                        continue;  </span><br><span class=\"line\">                                errno_exit(&quot;select&quot;);  </span><br><span class=\"line\">                        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">                        if (0 == r) &#123;  </span><br><span class=\"line\">                                fprintf(stderr, &quot;select timeout\\n&quot;);  </span><br><span class=\"line\">                                exit(EXIT_FAILURE);  </span><br><span class=\"line\">                        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">                        if (read_frame())  </span><br><span class=\"line\">                                break;  </span><br><span class=\"line\">                        /* EAGAIN - continue select loop. */  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">/* </span><br><span class=\"line\"> * one operation </span><br><span class=\"line\"> * step1 : VIDIOC_STREAMOFF </span><br><span class=\"line\"> */  </span><br><span class=\"line\">static void stop_capturing(void)  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">        enum v4l2_buf_type type;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        switch (io) &#123;  </span><br><span class=\"line\">        case IO_METHOD_READ:  </span><br><span class=\"line\">                /* Nothing to do. */  </span><br><span class=\"line\">                break;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        case IO_METHOD_MMAP:  </span><br><span class=\"line\">        case IO_METHOD_USERPTR:  </span><br><span class=\"line\">                type = V4L2_BUF_TYPE_VIDEO_CAPTURE;  </span><br><span class=\"line\">                if (-1 == xioctl(fd, VIDIOC_STREAMOFF, &amp;type))  </span><br><span class=\"line\">                        errno_exit(&quot;VIDIOC_STREAMOFF&quot;);  </span><br><span class=\"line\">                break;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">/* tow operations </span><br><span class=\"line\"> * step1 : VIDIOC_QBUF(insert buffer to queue) </span><br><span class=\"line\"> * step2 : VIDIOC_STREAMOFF </span><br><span class=\"line\"> */  </span><br><span class=\"line\">static void start_capturing(void)  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">        unsigned int i;  </span><br><span class=\"line\">        enum v4l2_buf_type type;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        switch (io) &#123;  </span><br><span class=\"line\">        case IO_METHOD_READ:  </span><br><span class=\"line\">                /* Nothing to do. */  </span><br><span class=\"line\">                break;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        case IO_METHOD_MMAP:  </span><br><span class=\"line\">                for (i = 0; i &lt; n_buffers; ++i) &#123;  </span><br><span class=\"line\">                        struct v4l2_buffer buf;  </span><br><span class=\"line\">  </span><br><span class=\"line\">                        CLEAR(buf);  </span><br><span class=\"line\">                        buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;  </span><br><span class=\"line\">                        buf.memory = V4L2_MEMORY_MMAP;  </span><br><span class=\"line\">                        buf.index = i;  </span><br><span class=\"line\">  </span><br><span class=\"line\">                        if (-1 == xioctl(fd, VIDIOC_QBUF, &amp;buf))  </span><br><span class=\"line\">                                errno_exit(&quot;VIDIOC_QBUF&quot;);  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">                type = V4L2_BUF_TYPE_VIDEO_CAPTURE;  </span><br><span class=\"line\">                if (-1 == xioctl(fd, VIDIOC_STREAMON, &amp;type))  </span><br><span class=\"line\">                        errno_exit(&quot;VIDIOC_STREAMON&quot;);  </span><br><span class=\"line\">                break;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        case IO_METHOD_USERPTR:  </span><br><span class=\"line\">                for (i = 0; i &lt; n_buffers; ++i) &#123;  </span><br><span class=\"line\">                        struct v4l2_buffer buf;  </span><br><span class=\"line\">  </span><br><span class=\"line\">                        CLEAR(buf);  </span><br><span class=\"line\">                        buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;  </span><br><span class=\"line\">                        buf.memory = V4L2_MEMORY_USERPTR;  </span><br><span class=\"line\">                        buf.index = i;  </span><br><span class=\"line\">                        buf.m.userptr = (unsigned long)buffers[i].start;  </span><br><span class=\"line\">                        buf.length = buffers[i].length;  </span><br><span class=\"line\">  </span><br><span class=\"line\">                        if (-1 == xioctl(fd, VIDIOC_QBUF, &amp;buf))  </span><br><span class=\"line\">                                errno_exit(&quot;VIDIOC_QBUF&quot;);  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">                type = V4L2_BUF_TYPE_VIDEO_CAPTURE;  </span><br><span class=\"line\">                if (-1 == xioctl(fd, VIDIOC_STREAMON, &amp;type))  </span><br><span class=\"line\">                        errno_exit(&quot;VIDIOC_STREAMON&quot;);  </span><br><span class=\"line\">                break;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">/* two operations </span><br><span class=\"line\"> * step1 : munmap buffers </span><br><span class=\"line\"> * steo2 : free buffers </span><br><span class=\"line\"> */  </span><br><span class=\"line\">static void uninit_device(void)  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">        unsigned int i;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        switch (io) &#123;  </span><br><span class=\"line\">        case IO_METHOD_READ:  </span><br><span class=\"line\">                free(buffers[0].start);  </span><br><span class=\"line\">                break;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        case IO_METHOD_MMAP:  </span><br><span class=\"line\">                for (i = 0; i &lt; n_buffers; ++i)  </span><br><span class=\"line\">                        if (-1 == munmap(buffers[i].start, buffers[i].length))  </span><br><span class=\"line\">                                errno_exit(&quot;munmap&quot;);  </span><br><span class=\"line\">                break;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        case IO_METHOD_USERPTR:  </span><br><span class=\"line\">                for (i = 0; i &lt; n_buffers; ++i)  </span><br><span class=\"line\">                        free(buffers[i].start);  </span><br><span class=\"line\">                break;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        free(buffers);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">static void init_read(unsigned int buffer_size)  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">        buffers = calloc(1, sizeof(*buffers));  </span><br><span class=\"line\">  </span><br><span class=\"line\">        if (!buffers) &#123;  </span><br><span class=\"line\">                fprintf(stderr, &quot;Out of memory\\n&quot;);  </span><br><span class=\"line\">                exit(EXIT_FAILURE);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        buffers[0].length = buffer_size;  </span><br><span class=\"line\">        buffers[0].start = malloc(buffer_size);  </span><br><span class=\"line\">  </span><br><span class=\"line\">        if (!buffers[0].start) &#123;  </span><br><span class=\"line\">                fprintf(stderr, &quot;Out of memory\\n&quot;);  </span><br><span class=\"line\">                exit(EXIT_FAILURE);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">static void init_mmap(void)  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">        struct v4l2_requestbuffers req;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        CLEAR(req);  </span><br><span class=\"line\">  </span><br><span class=\"line\">        req.count = 4;  </span><br><span class=\"line\">        req.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;  </span><br><span class=\"line\">        req.memory = V4L2_MEMORY_MMAP;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        if (-1 == xioctl(fd, VIDIOC_REQBUFS, &amp;req)) &#123;  </span><br><span class=\"line\">                if (EINVAL == errno) &#123;  </span><br><span class=\"line\">                        fprintf(stderr, &quot;%s does not support &quot;  </span><br><span class=\"line\">                                 &quot;memory mapping\\n&quot;, dev_name);  </span><br><span class=\"line\">                        exit(EXIT_FAILURE);  </span><br><span class=\"line\">                &#125; else &#123;  </span><br><span class=\"line\">                        errno_exit(&quot;VIDIOC_REQBUFS&quot;);  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        if (req.count &lt; 2) &#123;  </span><br><span class=\"line\">                fprintf(stderr, &quot;Insufficient buffer memory on %s\\n&quot;,  </span><br><span class=\"line\">                         dev_name);  </span><br><span class=\"line\">                exit(EXIT_FAILURE);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        buffers = calloc(req.count, sizeof(*buffers));  </span><br><span class=\"line\">  </span><br><span class=\"line\">        if (!buffers) &#123;  </span><br><span class=\"line\">                fprintf(stderr, &quot;Out of memory\\n&quot;);  </span><br><span class=\"line\">                exit(EXIT_FAILURE);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        for (n_buffers = 0; n_buffers &lt; req.count; ++n_buffers) &#123;  </span><br><span class=\"line\">                struct v4l2_buffer buf;  </span><br><span class=\"line\">  </span><br><span class=\"line\">                CLEAR(buf);  </span><br><span class=\"line\">  </span><br><span class=\"line\">                buf.type        = V4L2_BUF_TYPE_VIDEO_CAPTURE;  </span><br><span class=\"line\">                buf.memory      = V4L2_MEMORY_MMAP;  </span><br><span class=\"line\">                buf.index       = n_buffers;  </span><br><span class=\"line\">  </span><br><span class=\"line\">                if (-1 == xioctl(fd, VIDIOC_QUERYBUF, &amp;buf))  </span><br><span class=\"line\">                        errno_exit(&quot;VIDIOC_QUERYBUF&quot;);  </span><br><span class=\"line\">  </span><br><span class=\"line\">                buffers[n_buffers].length = buf.length;  </span><br><span class=\"line\">                buffers[n_buffers].start =  </span><br><span class=\"line\">                        mmap(NULL /* start anywhere */,  </span><br><span class=\"line\">                              buf.length,  </span><br><span class=\"line\">                              PROT_READ | PROT_WRITE /* required */,  </span><br><span class=\"line\">                              MAP_SHARED /* recommended */,  </span><br><span class=\"line\">                              fd, buf.m.offset);  </span><br><span class=\"line\">  </span><br><span class=\"line\">                if (MAP_FAILED == buffers[n_buffers].start)  </span><br><span class=\"line\">                        errno_exit(&quot;mmap&quot;);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">static void init_userp(unsigned int buffer_size)  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">        struct v4l2_requestbuffers req;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        CLEAR(req);  </span><br><span class=\"line\">  </span><br><span class=\"line\">        req.count  = 4;  </span><br><span class=\"line\">        req.type   = V4L2_BUF_TYPE_VIDEO_CAPTURE;  </span><br><span class=\"line\">        req.memory = V4L2_MEMORY_USERPTR;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        if (-1 == xioctl(fd, VIDIOC_REQBUFS, &amp;req)) &#123;  </span><br><span class=\"line\">                if (EINVAL == errno) &#123;  </span><br><span class=\"line\">                        fprintf(stderr, &quot;%s does not support &quot;  </span><br><span class=\"line\">                                 &quot;user pointer i/o\\n&quot;, dev_name);  </span><br><span class=\"line\">                        exit(EXIT_FAILURE);  </span><br><span class=\"line\">                &#125; else &#123;  </span><br><span class=\"line\">                        errno_exit(&quot;VIDIOC_REQBUFS&quot;);  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        buffers = calloc(4, sizeof(*buffers));  </span><br><span class=\"line\">  </span><br><span class=\"line\">        if (!buffers) &#123;  </span><br><span class=\"line\">                fprintf(stderr, &quot;Out of memory\\n&quot;);  </span><br><span class=\"line\">                exit(EXIT_FAILURE);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        for (n_buffers = 0; n_buffers &lt; 4; ++n_buffers) &#123;  </span><br><span class=\"line\">                buffers[n_buffers].length = buffer_size;  </span><br><span class=\"line\">                buffers[n_buffers].start = malloc(buffer_size);  </span><br><span class=\"line\">  </span><br><span class=\"line\">                if (!buffers[n_buffers].start) &#123;  </span><br><span class=\"line\">                        fprintf(stderr, &quot;Out of memory\\n&quot;);  </span><br><span class=\"line\">                        exit(EXIT_FAILURE);  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">/* five operations </span><br><span class=\"line\"> * step1 : cap :query camera&apos;s capability and check it(is a video device? is it support read? is it support streaming?) </span><br><span class=\"line\"> * step2 : cropcap:set cropcap&apos;s type and get cropcap by VIDIOC_CROPCAP </span><br><span class=\"line\"> * step3 : set crop parameter by VIDIOC_S_CROP (such as frame type and angle) </span><br><span class=\"line\"> * step4 : set fmt </span><br><span class=\"line\"> * step5 : mmap </span><br><span class=\"line\"> */  </span><br><span class=\"line\">static void init_device(void)  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">        struct v4l2_capability cap;  </span><br><span class=\"line\">        struct v4l2_cropcap cropcap;  </span><br><span class=\"line\">        struct v4l2_crop crop;  </span><br><span class=\"line\">        struct v4l2_format fmt;  </span><br><span class=\"line\">        unsigned int min;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        if (-1 == xioctl(fd, VIDIOC_QUERYCAP, &amp;cap)) &#123;  </span><br><span class=\"line\">                if (EINVAL == errno) &#123;  </span><br><span class=\"line\">                        fprintf(stderr, &quot;%s is no V4L2 device\\n&quot;,  </span><br><span class=\"line\">                                 dev_name);  </span><br><span class=\"line\">                        exit(EXIT_FAILURE);  </span><br><span class=\"line\">                &#125; else &#123;  </span><br><span class=\"line\">                        errno_exit(&quot;VIDIOC_QUERYCAP&quot;);  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        if (!(cap.capabilities &amp; V4L2_CAP_VIDEO_CAPTURE)) &#123;  </span><br><span class=\"line\">                fprintf(stderr, &quot;%s is no video capture device\\n&quot;,  </span><br><span class=\"line\">                         dev_name);  </span><br><span class=\"line\">                exit(EXIT_FAILURE);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        switch (io) &#123;  </span><br><span class=\"line\">        case IO_METHOD_READ:  </span><br><span class=\"line\">                if (!(cap.capabilities &amp; V4L2_CAP_READWRITE)) &#123;  </span><br><span class=\"line\">                        fprintf(stderr, &quot;%s does not support read i/o\\n&quot;,  </span><br><span class=\"line\">                                 dev_name);  </span><br><span class=\"line\">                        exit(EXIT_FAILURE);  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">                break;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        case IO_METHOD_MMAP:  </span><br><span class=\"line\">        case IO_METHOD_USERPTR:  </span><br><span class=\"line\">                if (!(cap.capabilities &amp; V4L2_CAP_STREAMING)) &#123;  </span><br><span class=\"line\">                        fprintf(stderr, &quot;%s does not support streaming i/o\\n&quot;,  </span><br><span class=\"line\">                                 dev_name);  </span><br><span class=\"line\">                        exit(EXIT_FAILURE);  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">                break;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">        /* Select video input, video standard and tune here. */  </span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">        CLEAR(cropcap);  </span><br><span class=\"line\">  </span><br><span class=\"line\">        cropcap.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;  </span><br><span class=\"line\">        /* if device support cropcap&apos;s type then set crop */  </span><br><span class=\"line\">        if (0 == xioctl(fd, VIDIOC_CROPCAP, &amp;cropcap)) &#123;  </span><br><span class=\"line\">                crop.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;  </span><br><span class=\"line\">                crop.c = cropcap.defrect; /* reset to default */  </span><br><span class=\"line\">  </span><br><span class=\"line\">                if (-1 == xioctl(fd, VIDIOC_S_CROP, &amp;crop)) &#123;  </span><br><span class=\"line\">                        switch (errno) &#123;  </span><br><span class=\"line\">                        case EINVAL:  </span><br><span class=\"line\">                                /* Cropping not supported. */  </span><br><span class=\"line\">                                break;  </span><br><span class=\"line\">                        default:  </span><br><span class=\"line\">                                /* Errors ignored. */  </span><br><span class=\"line\">                                break;  </span><br><span class=\"line\">                        &#125;  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">        &#125; else &#123;  </span><br><span class=\"line\">                /* Errors ignored. */  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">        CLEAR(fmt);  </span><br><span class=\"line\">  </span><br><span class=\"line\">        fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;  </span><br><span class=\"line\">        if (force_format) &#123;  </span><br><span class=\"line\">                fmt.fmt.pix.width       = 640;  </span><br><span class=\"line\">                fmt.fmt.pix.height      = 480;  </span><br><span class=\"line\">                fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_YUYV;  </span><br><span class=\"line\">                fmt.fmt.pix.field       = V4L2_FIELD_INTERLACED;  </span><br><span class=\"line\">  </span><br><span class=\"line\">                if (-1 == xioctl(fd, VIDIOC_S_FMT, &amp;fmt))  </span><br><span class=\"line\">                        errno_exit(&quot;VIDIOC_S_FMT&quot;);  </span><br><span class=\"line\">  </span><br><span class=\"line\">                /* Note VIDIOC_S_FMT may change width and height. */  </span><br><span class=\"line\">        &#125; else &#123;  </span><br><span class=\"line\">                /* Preserve original settings as set by v4l2-ctl for example */  </span><br><span class=\"line\">                if (-1 == xioctl(fd, VIDIOC_G_FMT, &amp;fmt))  </span><br><span class=\"line\">                        errno_exit(&quot;VIDIOC_G_FMT&quot;);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        /* Buggy driver paranoia. */  </span><br><span class=\"line\">        min = fmt.fmt.pix.width * 2;  </span><br><span class=\"line\">        if (fmt.fmt.pix.bytesperline &lt; min)  </span><br><span class=\"line\">                fmt.fmt.pix.bytesperline = min;  </span><br><span class=\"line\">        min = fmt.fmt.pix.bytesperline * fmt.fmt.pix.height;  </span><br><span class=\"line\">        if (fmt.fmt.pix.sizeimage &lt; min)  </span><br><span class=\"line\">                fmt.fmt.pix.sizeimage = min;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        switch (io) &#123;  </span><br><span class=\"line\">        case IO_METHOD_READ:  </span><br><span class=\"line\">                init_read(fmt.fmt.pix.sizeimage);  </span><br><span class=\"line\">                break;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        case IO_METHOD_MMAP:  </span><br><span class=\"line\">                init_mmap();  </span><br><span class=\"line\">                break;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        case IO_METHOD_USERPTR:  </span><br><span class=\"line\">                init_userp(fmt.fmt.pix.sizeimage);  </span><br><span class=\"line\">                break;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">/* </span><br><span class=\"line\"> * close (fd) </span><br><span class=\"line\"> */  </span><br><span class=\"line\">static void close_device(void)  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">        if (-1 == close(fd))  </span><br><span class=\"line\">                errno_exit(&quot;close&quot;);  </span><br><span class=\"line\">  </span><br><span class=\"line\">        fd = -1;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">/* three operations </span><br><span class=\"line\"> * step 1 : check dev_name and st_mode </span><br><span class=\"line\"> * step 2 : open(device) </span><br><span class=\"line\"> */  </span><br><span class=\"line\">static void open_device(void)  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">        struct stat st;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        if (-1 == stat(dev_name, &amp;st)) &#123;  </span><br><span class=\"line\">                fprintf(stderr, &quot;Cannot identify &apos;%s&apos;: %d, %s\\n&quot;,  </span><br><span class=\"line\">                         dev_name, errno, strerror(errno));  </span><br><span class=\"line\">                exit(EXIT_FAILURE);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        if (!S_ISCHR(st.st_mode)) &#123;  </span><br><span class=\"line\">                fprintf(stderr, &quot;%s is no device\\n&quot;, dev_name);  </span><br><span class=\"line\">                exit(EXIT_FAILURE);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        fd = open(dev_name, O_RDWR /* required */ | O_NONBLOCK, 0);  </span><br><span class=\"line\">  </span><br><span class=\"line\">        if (-1 == fd) &#123;  </span><br><span class=\"line\">                fprintf(stderr, &quot;Cannot open &apos;%s&apos;: %d, %s\\n&quot;,  </span><br><span class=\"line\">                         dev_name, errno, strerror(errno));  </span><br><span class=\"line\">                exit(EXIT_FAILURE);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">static void usage(FILE *fp, int argc, char **argv)  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">        fprintf(fp,  </span><br><span class=\"line\">                 &quot;Usage: %s [options]\\n\\n&quot;  </span><br><span class=\"line\">                 &quot;Version 1.3\\n&quot;  </span><br><span class=\"line\">                 &quot;Options:\\n&quot;  </span><br><span class=\"line\">                 &quot;-d | --device name   Video device name [%s]\\n&quot;  </span><br><span class=\"line\">                 &quot;-h | --help          Print this message\\n&quot;  </span><br><span class=\"line\">                 &quot;-m | --mmap          Use memory mapped buffers [default]\\n&quot;  </span><br><span class=\"line\">                 &quot;-r | --read          Use read() calls\\n&quot;  </span><br><span class=\"line\">                 &quot;-u | --userp         Use application allocated buffers\\n&quot;  </span><br><span class=\"line\">                 &quot;-o | --output        Outputs stream to stdout\\n&quot;  </span><br><span class=\"line\">                 &quot;-f | --format        Force format to 640x480 YUYV\\n&quot;  </span><br><span class=\"line\">                 &quot;-c | --count         Number of frames to grab [%i]\\n&quot;  </span><br><span class=\"line\">                 &quot;&quot;,  </span><br><span class=\"line\">                 argv[0], dev_name, frame_count);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">static const char short_options[] = &quot;d:hmruofc:&quot;;  </span><br><span class=\"line\">  </span><br><span class=\"line\">static const struct option  </span><br><span class=\"line\">long_options[] = &#123;  </span><br><span class=\"line\">        &#123; &quot;device&quot;, required_argument, NULL, &apos;d&apos; &#125;,  </span><br><span class=\"line\">        &#123; &quot;help&quot;,   no_argument,       NULL, &apos;h&apos; &#125;,  </span><br><span class=\"line\">        &#123; &quot;mmap&quot;,   no_argument,       NULL, &apos;m&apos; &#125;,  </span><br><span class=\"line\">        &#123; &quot;read&quot;,   no_argument,       NULL, &apos;r&apos; &#125;,  </span><br><span class=\"line\">        &#123; &quot;userp&quot;,  no_argument,       NULL, &apos;u&apos; &#125;,  </span><br><span class=\"line\">        &#123; &quot;output&quot;, no_argument,       NULL, &apos;o&apos; &#125;,  </span><br><span class=\"line\">        &#123; &quot;format&quot;, no_argument,       NULL, &apos;f&apos; &#125;,  </span><br><span class=\"line\">        &#123; &quot;count&quot;,  required_argument, NULL, &apos;c&apos; &#125;,  </span><br><span class=\"line\">        &#123; 0, 0, 0, 0 &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\">int main(int argc, char **argv)  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">        dev_name = &quot;/dev/video4&quot;;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        for (;;) &#123;  </span><br><span class=\"line\">                int idx;  </span><br><span class=\"line\">                int c;  </span><br><span class=\"line\">  </span><br><span class=\"line\">                c = getopt_long(argc, argv,  </span><br><span class=\"line\">                                short_options, long_options, &amp;idx);  </span><br><span class=\"line\">  </span><br><span class=\"line\">                if (-1 == c)  </span><br><span class=\"line\">                        break;  </span><br><span class=\"line\">  </span><br><span class=\"line\">                switch (c) &#123;  </span><br><span class=\"line\">                case 0: /* getopt_long() flag */  </span><br><span class=\"line\">                        break;  </span><br><span class=\"line\">  </span><br><span class=\"line\">                case &apos;d&apos;:  </span><br><span class=\"line\">                        dev_name = optarg;  </span><br><span class=\"line\">                        break;  </span><br><span class=\"line\">  </span><br><span class=\"line\">                case &apos;h&apos;:  </span><br><span class=\"line\">                        usage(stdout, argc, argv);  </span><br><span class=\"line\">                        exit(EXIT_SUCCESS);  </span><br><span class=\"line\">  </span><br><span class=\"line\">                case &apos;m&apos;:  </span><br><span class=\"line\">                        io = IO_METHOD_MMAP;  </span><br><span class=\"line\">                        break;  </span><br><span class=\"line\">  </span><br><span class=\"line\">                case &apos;r&apos;:  </span><br><span class=\"line\">                        io = IO_METHOD_READ;  </span><br><span class=\"line\">                        break;  </span><br><span class=\"line\">  </span><br><span class=\"line\">                case &apos;u&apos;:  </span><br><span class=\"line\">                        io = IO_METHOD_USERPTR;  </span><br><span class=\"line\">                        break;  </span><br><span class=\"line\">  </span><br><span class=\"line\">                case &apos;o&apos;:  </span><br><span class=\"line\">                        out_buf++;  </span><br><span class=\"line\">                        break;  </span><br><span class=\"line\">  </span><br><span class=\"line\">                case &apos;f&apos;:  </span><br><span class=\"line\">                        force_format++;  </span><br><span class=\"line\">                        break;  </span><br><span class=\"line\">  </span><br><span class=\"line\">                case &apos;c&apos;:  </span><br><span class=\"line\">                        errno = 0;  </span><br><span class=\"line\">                        frame_count = strtol(optarg, NULL, 0);  </span><br><span class=\"line\">                        if (errno)  </span><br><span class=\"line\">                                errno_exit(optarg);  </span><br><span class=\"line\">                        break;  </span><br><span class=\"line\">  </span><br><span class=\"line\">                default:  </span><br><span class=\"line\">                        usage(stderr, argc, argv);  </span><br><span class=\"line\">                        exit(EXIT_FAILURE);  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        open_device();  </span><br><span class=\"line\">        init_device();  </span><br><span class=\"line\">        start_capturing();  </span><br><span class=\"line\">        mainloop();  </span><br><span class=\"line\">        stop_capturing();  </span><br><span class=\"line\">        uninit_device();  </span><br><span class=\"line\">        close_device();  </span><br><span class=\"line\">        fprintf(stderr, &quot;\\n&quot;);  </span><br><span class=\"line\">        return 0;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>参考：<br><a href=\"https://blog.csdn.net/u010164190/article/details/53189836\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/u010164190/article/details/53189836</a></p>\n<p><a href=\"https://blog.csdn.net/qq_38880380/article/details/78261995\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/qq_38880380/article/details/78261995</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>V4L是 Video for Linux的缩写,它是Linux 内核中关于视频设备的子系统，它为linux 下的视频驱动提供了统一的接口，使得应用程序可以使用统一的API 函数操作不同的视频设备，极大地简化了视频系统的开发和维护。<br>由于早期的 V4L 有很多缺陷，Bill Dirks 等人对其进行了重新设计，并取名为Video for Linux 2(V4L2使用)，最早出现于Linux2.5.x 版本。V4L2 相比于V4L 有更好的扩展性和灵活性，并且支持的硬件设备更多。<br>因此在应用程序V4L编程实际是指v4l2,我们这个系列的以V4L2为主,但由于历史的原因,V4L2一般兼容V4L.所以很多程序可以用V4L接口.</p>\n<h3 id=\"工作流程\"><a href=\"#工作流程\" class=\"headerlink\" title=\"工作流程\"></a>工作流程</h3><p>打开设备－&gt; 检查和设置设备属性－&gt; 设置帧格式－&gt; 设置一种输入输出方法（缓冲区管理）－&gt; 循环获取数据－&gt; 关闭设备。</p>\n<h4 id=\"1、打开设备\"><a href=\"#1、打开设备\" class=\"headerlink\" title=\"1、打开设备\"></a>1、打开设备</h4><p>一般V4L设备结点名是 /dev/videoN.如第一个V4L设备是/dev/video0.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int fd = open(&quot;/dev/video0&quot;,O_RDWR |O_NONBLOCK);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"2、检查和设置设备属性\"><a href=\"#2、检查和设置设备属性\" class=\"headerlink\" title=\"2、检查和设置设备属性\"></a>2、检查和设置设备属性</h4><p>主要通过ioctl来操作,格式<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int ioctl (int __fd, unsigned long int __request, .../*args*/) ;</span><br></pre></td></tr></table></figure></p>\n<p>其中，__request是V4L2一些ioctl命令,常见如下.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">VIDIOC_REQBUFS：分配内存</span><br><span class=\"line\">VIDIOC_QUERYBUF：把VIDIOC_REQBUFS中分配的数据缓存转换成物理地址</span><br><span class=\"line\">VIDIOC_QUERYCAP：查询驱动功能</span><br><span class=\"line\">VIDIOC_ENUM_FMT：获取当前驱动支持的视频格式</span><br><span class=\"line\">VIDIOC_S_FMT：设置当前驱动的频捕获格式</span><br><span class=\"line\">VIDIOC_G_FMT：读取当前驱动的频捕获格式</span><br><span class=\"line\">VIDIOC_TRY_FMT：验证当前驱动的显示格式</span><br><span class=\"line\">VIDIOC_CROPCAP：查询驱动的修剪能力</span><br><span class=\"line\">VIDIOC_S_CROP：设置视频信号的边框</span><br><span class=\"line\">VIDIOC_G_CROP：读取视频信号的边框</span><br><span class=\"line\">VIDIOC_QBUF：把数据从缓存中读取出来</span><br><span class=\"line\">VIDIOC_DQBUF：把数据放回缓存队列</span><br><span class=\"line\">VIDIOC_STREAMON：开始视频显示函数</span><br><span class=\"line\">VIDIOC_STREAMOFF：结束视频显示函数</span><br><span class=\"line\">VIDIOC_QUERYSTD：检查当前视频设备支持的标准，例如PAL或NTSC。</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"2-1-查询设备属性：-VIDIOC-QUERYCAP\"><a href=\"#2-1-查询设备属性：-VIDIOC-QUERYCAP\" class=\"headerlink\" title=\"2.1 查询设备属性： VIDIOC_QUERYCAP\"></a>2.1 查询设备属性： VIDIOC_QUERYCAP</h4><p>相关函数：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int ioctl(int fd, int request, struct v4l2_capability *argp);</span><br></pre></td></tr></table></figure></p>\n<p>相关结构体：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct v4l2_capability  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">u8 driver[16]; // 驱动名字  </span><br><span class=\"line\">u8 card[32]; // 设备名字  </span><br><span class=\"line\">u8 bus_info[32]; // 设备在系统中的位置  </span><br><span class=\"line\">u32 version; // 驱动版本号  </span><br><span class=\"line\">u32 capabilities; // 设备支持的操作  </span><br><span class=\"line\">u32 reserved[4]; // 保留字段  </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>capabilities 常用值:</p>\n<p>V4L2_CAP_VIDEO_CAPTURE // 是否支持图像获取</p>\n<p>例：显示设备信息<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">struct v4l2_capability cap;    </span><br><span class=\"line\">ioctl(fd,VIDIOC_QUERYCAP,&amp;cap);  </span><br><span class=\"line\"> </span><br><span class=\"line\">printf(“Driver Name:%s\\nCard Name:%s\\nBus info:%s\\nDriver Version:%u.%u.%u\\n”,cap.driver,cap.card,cap.bus_info,(cap.version&gt;&gt;16)&amp;0XFF, (cap.version&gt;&gt;8)&amp;0XFF,cap.version&amp;0XFF);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3、设置视频的制式和帧格式\"><a href=\"#3、设置视频的制式和帧格式\" class=\"headerlink\" title=\"3、设置视频的制式和帧格式\"></a>3、设置视频的制式和帧格式</h4><p>制式包括PAL，NTSC，帧的格式个包括宽度和高度等。</p>\n<p>相关函数<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int ioctl(int fd, int request, struct v4l2_fmtdesc *argp);  </span><br><span class=\"line\">  </span><br><span class=\"line\">int ioctl(int fd, int request, struct v4l2_format *argp);</span><br></pre></td></tr></table></figure></p>\n<p>相关结构体：</p>\n<p><font color=\"ff0000\">v4l2_cropcap</font> 结构体用来设置摄像头的捕捉能力，在捕捉上视频时应先先设置</p>\n<p>v4l2_cropcap 的 type 域，再通过 VIDIO_CROPCAP 操作命令获取设备捕捉能力的参数，保存于 v4l2_cropcap 结构体中，包括 bounds（最大捕捉方框的左上角坐标和宽高），defrect（默认捕捉方框的左上角坐标和宽高）等。</p>\n<p>v4l2_format 结构体用来设置摄像头的视频制式、帧格式等，在设置这个参数时应先填 好 v4l2_format 的各个域，如 type（传输流类型），fmt.pix.width(宽)，fmt.pix.heigth(高)，fmt.pix.field(采样区域，如隔行采样)，fmt.pix.pixelformat(采样类型，如 YUV4:2:2)，然后通过 VIDIO_S_FMT 操作命令设置视频捕捉格式。</p>\n<h4 id=\"3-1-查询并显示所有支持的格式：VIDIOC-ENUM-FMT\"><a href=\"#3-1-查询并显示所有支持的格式：VIDIOC-ENUM-FMT\" class=\"headerlink\" title=\"3.1 查询并显示所有支持的格式：VIDIOC_ENUM_FMT\"></a>3.1 查询并显示所有支持的格式：VIDIOC_ENUM_FMT</h4><p>相关函数：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int ioctl(int fd, int request, struct v4l2_fmtdesc *argp);</span><br></pre></td></tr></table></figure></p>\n<p>相关结构体：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct v4l2_fmtdesc   </span><br><span class=\"line\">&#123;   </span><br><span class=\"line\">u32 index; // 要查询的格式序号，应用程序设置  </span><br><span class=\"line\">enum v4l2_buf_type type; // 帧类型，应用程序设置  </span><br><span class=\"line\">u32 flags; // 是否为压缩格式  </span><br><span class=\"line\">u8 description[32]; // 格式名称  </span><br><span class=\"line\">u32 pixelformat; // 格式  </span><br><span class=\"line\">u32 reserved[4]; // 保留   </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>例：显示所有支持的格式<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct v4l2_fmtdesc fmtdesc; </span><br><span class=\"line\">fmtdesc.index=0; </span><br><span class=\"line\">fmtdesc.type=V4L2_BUF_TYPE_VIDEO_CAPTURE; </span><br><span class=\"line\">printf(&quot;Support format:\\n&quot;);  </span><br><span class=\"line\">while(ioctl(fd, VIDIOC_ENUM_FMT, &amp;fmtdesc) != -1)  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">\tprintf(&quot;\\t%d.%s\\n&quot;,fmtdesc.index+1,fmtdesc.description);  </span><br><span class=\"line\">\tfmtdesc.index++;   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3-2-查看或设置当前格式：-VIDIOC-G-FMT-VIDIOC-S-FMT\"><a href=\"#3-2-查看或设置当前格式：-VIDIOC-G-FMT-VIDIOC-S-FMT\" class=\"headerlink\" title=\"3.2 查看或设置当前格式： VIDIOC_G_FMT, VIDIOC_S_FMT\"></a>3.2 查看或设置当前格式： VIDIOC_G_FMT, VIDIOC_S_FMT</h4><p>检查是否支持某种格式：VIDIOC_TRY_FMT</p>\n<p>相关函数：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int ioctl(int fd, int request, struct v4l2_format *argp);</span><br></pre></td></tr></table></figure></p>\n<p>相关结构体：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct v4l2_format  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">\tenum v4l2_buf_type type; // 帧类型，应用程序设置  </span><br><span class=\"line\">\tunion fmt  &#123;  </span><br><span class=\"line\">        struct v4l2_pix_format pix; // 视频设备使用  </span><br><span class=\"line\">        struct v4l2_window win;  </span><br><span class=\"line\">        struct v4l2_vbi_format vbi;  </span><br><span class=\"line\">        struct v4l2_sliced_vbi_format sliced;  </span><br><span class=\"line\">        u8 raw_data[200];  </span><br><span class=\"line\">    &#125;;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\">struct v4l2_pix_format  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    u32 width; // 帧宽，单位像素  </span><br><span class=\"line\">    u32 height; // 帧高，单位像素  </span><br><span class=\"line\">    u32 pixelformat; // 帧格式  </span><br><span class=\"line\">    enum v4l2_field field;  </span><br><span class=\"line\">    u32 bytesperline;  </span><br><span class=\"line\">    u32 sizeimage;  </span><br><span class=\"line\">    enum v4l2_colorspace colorspace;  </span><br><span class=\"line\">    u32 priv;  </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>例:显示当前帧的相关信息<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct v4l2_format fmt;  </span><br><span class=\"line\">  </span><br><span class=\"line\">fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;  </span><br><span class=\"line\">  </span><br><span class=\"line\">ioctl(fd, VIDIOC_G_FMT, &amp;fmt);  </span><br><span class=\"line\">  </span><br><span class=\"line\">printf(“Current data format information:\\n\\twidth:%d\\n\\theight:%d\\n”, fmt.fmt.pix.width,fmt.fmt.pix.height);  </span><br><span class=\"line\">  </span><br><span class=\"line\">struct v4l2_fmtdesc fmtdesc;  </span><br><span class=\"line\">  </span><br><span class=\"line\">fmtdesc.index = 0;  </span><br><span class=\"line\">  </span><br><span class=\"line\">fmtdesc.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;  </span><br><span class=\"line\">  </span><br><span class=\"line\">while(ioctl(fd,VIDIOC_ENUM_FMT,&amp;fmtdesc) != -1)  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    if(fmtdesc.pixelformat &amp; fmt.fmt.pix.pixelformat)  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        printf(“\\tformat:%s\\n”,fmtdesc.description);  </span><br><span class=\"line\">        break;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    fmtdesc.index++;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>例：检查是否支持某种帧格式<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct v4l2_format fmt;   </span><br><span class=\"line\">  </span><br><span class=\"line\">fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;   </span><br><span class=\"line\">  </span><br><span class=\"line\">fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_RGB32;   </span><br><span class=\"line\">  </span><br><span class=\"line\">if(ioctl(fd,VIDIOC_TRY_FMT,&amp;fmt) == -1)   </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    if(errno==EINVAL)  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        printf(“not support format RGB32!\\n”);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3-3-图像的缩放-VIDIOC-CROPCAP\"><a href=\"#3-3-图像的缩放-VIDIOC-CROPCAP\" class=\"headerlink\" title=\"3.3 图像的缩放 VIDIOC_CROPCAP\"></a>3.3 图像的缩放 VIDIOC_CROPCAP</h4><p>相关函数：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int ioctl(int fd, int request, struct v4l2_cropcap *argp);  </span><br><span class=\"line\">int ioctl(int fd, int request, struct v4l2_crop *argp);  </span><br><span class=\"line\">int ioctl(int fd, int request, const struct v4l2_crop *argp);</span><br></pre></td></tr></table></figure></p>\n<p>相关结构体：</p>\n<p>v4l2_cropcap 结构体用来设置摄像头的捕捉能力，在捕捉上视频时应先先设置v4l2_cropcap 的 type 域，再通过 VIDIO_CROPCAP 操作命令获取设备捕捉能力的参数，保存于 v4l2_cropcap 结构体中，包括 bounds（最大捕捉方框的左上角坐标和宽高），defrect（默认捕捉方框的左上角坐标和宽高）等。</p>\n<p>Cropping 和 scaling 主要指的是图像的取景范围及图片的比例缩放的支持。Crop 就 是把得到的数据作一定的裁剪和伸缩，裁剪可以只取样我们可以得到的图像大小的一部分， 剪裁的主要参数是位置、长度、宽度。而 scale 的设置是通过 VIDIOC_G_FMT 和 VIDIOC_S_FMT 来获得和设置当前的 image 的长度，宽度来实现的。</p>\n<p>我们可以假设 bounds 是 sensor 最大能捕捉到的图像范围，而 defrect 是设备默认 的最大取样范围，这个可以通过 VIDIOC_CROPCAP 的 ioctl 来获得设备的 crap 相关的属 性 v4l2_cropcap，其中的 bounds 就是这个 bounds，其实就是上限。每个设备都有个默 认的取样范围，就是 defrect，就是 default rect 的意思，它比 bounds 要小一些。这 个范围也是通过 VIDIOC_CROPCAP 的 ioctl 来获得的 v4l2_cropcap 结构中的 defrect 来表示的，我们可以通过 VIDIOC_G_CROP 和 VIDIOC_S_CROP 来获取和设置设备当前的 crop 设置。</p>\n<h4 id=\"3-4-设置设备捕捉能力的参数\"><a href=\"#3-4-设置设备捕捉能力的参数\" class=\"headerlink\" title=\"3.4 设置设备捕捉能力的参数\"></a>3.4 设置设备捕捉能力的参数</h4><p>相关函数：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int ioctl(int fd, int request, struct v4l2_cropcap *argp);</span><br></pre></td></tr></table></figure></p>\n<p>相关结构体：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct v4l2_cropcap  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    enum v4l2_buf_type type; // 数据流的类型，应用程序设置  </span><br><span class=\"line\">    struct v4l2_rect bounds; // 这是 camera 的镜头能捕捉到的窗口大小的局限  </span><br><span class=\"line\">    struct v4l2_rect defrect; // 定义默认窗口大小，包括起点位置及长,宽的大小，大小以像素为单位  </span><br><span class=\"line\">    struct v4l2_fract pixelaspect; // 定义了图片的宽高比  </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3-5-设置窗口取景参数-VIDIOC-G-CROP-和-VIDIOC-S-CROP\"><a href=\"#3-5-设置窗口取景参数-VIDIOC-G-CROP-和-VIDIOC-S-CROP\" class=\"headerlink\" title=\"3.5 设置窗口取景参数 VIDIOC_G_CROP 和 VIDIOC_S_CROP\"></a>3.5 设置窗口取景参数 VIDIOC_G_CROP 和 VIDIOC_S_CROP</h4><p>相关函数：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int ioctl(int fd, int request, struct v4l2_crop *argp);  </span><br><span class=\"line\">int ioctl(int fd, int request, const struct v4l2_crop *argp);</span><br></pre></td></tr></table></figure></p>\n<p>相关结构体：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct v4l2_crop  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    enum v4l2_buf_type type;// 应用程序设置  </span><br><span class=\"line\">    struct v4l2_rect c;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3-6-video-Inputs-and-Outputs\"><a href=\"#3-6-video-Inputs-and-Outputs\" class=\"headerlink\" title=\"3.6 video Inputs and Outputs\"></a>3.6 video Inputs and Outputs</h4><p>VIDIOC_G_INPUT 和 VIDIOC_S_INPUT 用来查询和选则当前的 input，一个 video 设备 节点可能对应多个视频源，比如 saf7113 可以最多支持四路 cvbs 输入，如果上层想在四 个cvbs视频输入间切换，那么就要调用 ioctl(fd, VIDIOC_S_INPUT, &amp;input) 来切换。VIDIOC_G_INPUT and VIDIOC_G_OUTPUT 返回当前的 video input和output的index.</p>\n<p>相关函数：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int ioctl(int fd, int request, struct v4l2_input *argp);</span><br></pre></td></tr></table></figure></p>\n<p>相关结构体：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct v4l2_input   </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    __u32 index;    /* Which input */  </span><br><span class=\"line\">    __u8 name[32];  /* Label */  </span><br><span class=\"line\">    __u32 type;     /* Type of input */  </span><br><span class=\"line\">    __u32 audioset; /* Associated audios (bitfield) */  </span><br><span class=\"line\">    __u32 tuner;    /* Associated tuner */  </span><br><span class=\"line\">    v4l2_std_id std;  </span><br><span class=\"line\">    __u32 status;  </span><br><span class=\"line\">    __u32 reserved[4];  </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>我们可以通过VIDIOC_ENUMINPUT and VIDIOC_ENUMOUTPUT 分别列举一个input或者 output的信息，我们使用一个v4l2_input结构体来存放查询结果，这个结构体中有一个 index域用来指定你索要查询的是第几个input/ouput,如果你所查询的这个input是当前正 在使用的，那么在v4l2_input还会包含一些当前的状态信息，如果所 查询的input/output 不存在，那么回返回EINVAL错误，所以，我们通过循环查找，直到返回错误来遍历所有的 input/output. VIDIOC_G_INPUT and VIDIOC_G_OUTPUT 返回当前的video input和output 的index.</p>\n<h3 id=\"4、申请和管理缓冲区\"><a href=\"#4、申请和管理缓冲区\" class=\"headerlink\" title=\"4、申请和管理缓冲区\"></a>4、申请和管理缓冲区</h3><p>应用程序和设备有三种交换数据的方法，直接 read/write、内存映射(memory mapping)和用户指针。这里只讨论内存映射(memory mapping)。</p>\n<h4 id=\"4-1-向设备申请缓冲区-VIDIOC-REQBUFS\"><a href=\"#4-1-向设备申请缓冲区-VIDIOC-REQBUFS\" class=\"headerlink\" title=\"4.1 向设备申请缓冲区 VIDIOC_REQBUFS\"></a>4.1 向设备申请缓冲区 VIDIOC_REQBUFS</h4><p>相关函数：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int ioctl(int fd, int request, struct v4l2_requestbuffers *argp);</span><br></pre></td></tr></table></figure></p>\n<p>相关结构体：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct v4l2_requestbuffers  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    u32 count; // 缓冲区内缓冲帧的数目  </span><br><span class=\"line\">    enum v4l2_buf_type type; // 缓冲帧数据格式  </span><br><span class=\"line\">    enum v4l2_memory memory; // 区别是内存映射还是用户指针方式  </span><br><span class=\"line\">    u32 reserved[2];  </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">注：</span><br><span class=\"line\">enum v4l2_memoy</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    V4L2_MEMORY_MMAP, V4L2_MEMORY_USERPTR</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">//count,type,memory 都要应用程序设置</span><br></pre></td></tr></table></figure></p>\n<p>例：申请一个拥有四个缓冲帧的缓冲区<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct v4l2_requestbuffers req;   </span><br><span class=\"line\">req.count = 4;    </span><br><span class=\"line\">req.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;   </span><br><span class=\"line\">req.memory = V4L2_MEMORY_MMAP;   </span><br><span class=\"line\">ioctl(fd,VIDIOC_REQBUFS,&amp;req);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"4-2-获取缓冲帧的地址，长度：VIDIOC-QUERYBUF\"><a href=\"#4-2-获取缓冲帧的地址，长度：VIDIOC-QUERYBUF\" class=\"headerlink\" title=\"4.2 获取缓冲帧的地址，长度：VIDIOC_QUERYBUF\"></a>4.2 获取缓冲帧的地址，长度：VIDIOC_QUERYBUF</h4><p>相关函数:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int ioctl(int fd, int request, struct v4l2_buffer *argp);</span><br></pre></td></tr></table></figure></p>\n<p>相关结构体：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct v4l2_buffer  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    u32 index; //buffer 序号  </span><br><span class=\"line\">    enum v4l2_buf_type type; //buffer 类型  </span><br><span class=\"line\">    u32 byteused; //buffer 中已使用的字节数  </span><br><span class=\"line\">    u32 flags; // 区分是MMAP 还是USERPTR  </span><br><span class=\"line\">    enum v4l2_field field;  </span><br><span class=\"line\">    struct timeval timestamp; // 获取第一个字节时的系统时间  </span><br><span class=\"line\">    struct v4l2_timecode timecode;  </span><br><span class=\"line\">    u32 sequence; // 队列中的序号  </span><br><span class=\"line\">    enum v4l2_memory memory; //IO 方式，被应用程序设置  </span><br><span class=\"line\">    union m  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        u32 offset; // 缓冲帧地址，只对MMAP 有效  </span><br><span class=\"line\">        unsigned long userptr;  </span><br><span class=\"line\">    &#125;;  </span><br><span class=\"line\">    u32 length; // 缓冲帧长度  </span><br><span class=\"line\">    u32 input;  </span><br><span class=\"line\">    u32 reserved;  </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"4-3-内存映射MMAP-及定义一个结构体来映射每个缓冲帧\"><a href=\"#4-3-内存映射MMAP-及定义一个结构体来映射每个缓冲帧\" class=\"headerlink\" title=\"4.3 内存映射MMAP 及定义一个结构体来映射每个缓冲帧\"></a>4.3 内存映射MMAP 及定义一个结构体来映射每个缓冲帧</h4><p>相关结构体：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct buffer  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    void* start;  </span><br><span class=\"line\">    unsigned int length;  </span><br><span class=\"line\">&#125;*buffers;</span><br></pre></td></tr></table></figure></p>\n<p>相关函数：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset) </span><br><span class=\"line\"></span><br><span class=\"line\">//addr 映射起始地址，一般为NULL ，让内核自动选择</span><br><span class=\"line\">//length 被映射内存块的长度</span><br><span class=\"line\">//prot 标志映射后能否被读写，其值为PROT_EXEC,PROT_READ,PROT_WRITE, PROT_NONE</span><br><span class=\"line\">//flags 确定此内存映射能否被其他进程共享，MAP_SHARED,MAP_PRIVATE</span><br><span class=\"line\">//fd,offset, 确定被映射的内存地址 返回成功映射后的地址，不成功返回MAP_FAILED ((void*)-1)</span><br></pre></td></tr></table></figure></p>\n<p>相关函数：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int munmap(void *addr, size_t length);// 断开映射  </span><br><span class=\"line\"></span><br><span class=\"line\">//addr 为映射后的地址，length 为映射后的内存长度</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"5、启动-或-停止数据流-VIDIOC-STREAMON，-VIDIOC-STREAMOFF\"><a href=\"#5、启动-或-停止数据流-VIDIOC-STREAMON，-VIDIOC-STREAMOFF\" class=\"headerlink\" title=\"5、启动 或 停止数据流 VIDIOC_STREAMON， VIDIOC_STREAMOFF\"></a>5、启动 或 停止数据流 VIDIOC_STREAMON， VIDIOC_STREAMOFF</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int ioctl(int fd, int request, const int *argp);</span><br><span class=\"line\"></span><br><span class=\"line\">//argp 为流类型指针，如V4L2_BUF_TYPE_VIDEO_CAPTURE.</span><br></pre></td></tr></table></figure>\n<h4 id=\"5-1-在开始之前，还应当把缓冲帧放入缓冲队列：\"><a href=\"#5-1-在开始之前，还应当把缓冲帧放入缓冲队列：\" class=\"headerlink\" title=\"5.1 在开始之前，还应当把缓冲帧放入缓冲队列：\"></a>5.1 在开始之前，还应当把缓冲帧放入缓冲队列：</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">VIDIOC_QBUF\t\t//把帧放入队列</span><br><span class=\"line\">VIDIOC_DQBUF\t//从队列中取出帧</span><br><span class=\"line\"></span><br><span class=\"line\">int ioctl(int fd, int request, struct v4l2_buffer *argp);</span><br></pre></td></tr></table></figure>\n<p>例：把四个缓冲帧放入队列，并启动数据流<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">unsigned int i;   </span><br><span class=\"line\">enum v4l2_buf_type type;  </span><br><span class=\"line\">for (i = 0; i &lt; 4; ++i) // 将缓冲帧放入队列  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    struct v4l2_buffer buf;  </span><br><span class=\"line\">    buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;  </span><br><span class=\"line\">    buf.memory = V4L2_MEMORY_MMAP;  </span><br><span class=\"line\">    buf.index = i;  </span><br><span class=\"line\">    ioctl (fd, VIDIOC_QBUF, &amp;buf);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">type = V4L2_BUF_TYPE_VIDEO_CAPTURE;  </span><br><span class=\"line\">ioctl (fd, VIDIOC_STREAMON, &amp;type);</span><br></pre></td></tr></table></figure></p>\n<p>例：获取一帧并处理<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct v4l2_buffer buf; </span><br><span class=\"line\">CLEAR (buf);  </span><br><span class=\"line\">buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;  </span><br><span class=\"line\">buf.memory = V4L2_MEMORY_MMAP;  </span><br><span class=\"line\">ioctl (fd, VIDIOC_DQBUF, &amp;buf); // 从缓冲区取出一个缓冲帧  </span><br><span class=\"line\">process_image (buffers[buf.index].start); //  </span><br><span class=\"line\">ioctl (fd，VIDIOC_QBUF，&amp;buf); //</span><br></pre></td></tr></table></figure></p>\n<p>附官方 v4l2 video capture example<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br><span class=\"line\">303</span><br><span class=\"line\">304</span><br><span class=\"line\">305</span><br><span class=\"line\">306</span><br><span class=\"line\">307</span><br><span class=\"line\">308</span><br><span class=\"line\">309</span><br><span class=\"line\">310</span><br><span class=\"line\">311</span><br><span class=\"line\">312</span><br><span class=\"line\">313</span><br><span class=\"line\">314</span><br><span class=\"line\">315</span><br><span class=\"line\">316</span><br><span class=\"line\">317</span><br><span class=\"line\">318</span><br><span class=\"line\">319</span><br><span class=\"line\">320</span><br><span class=\"line\">321</span><br><span class=\"line\">322</span><br><span class=\"line\">323</span><br><span class=\"line\">324</span><br><span class=\"line\">325</span><br><span class=\"line\">326</span><br><span class=\"line\">327</span><br><span class=\"line\">328</span><br><span class=\"line\">329</span><br><span class=\"line\">330</span><br><span class=\"line\">331</span><br><span class=\"line\">332</span><br><span class=\"line\">333</span><br><span class=\"line\">334</span><br><span class=\"line\">335</span><br><span class=\"line\">336</span><br><span class=\"line\">337</span><br><span class=\"line\">338</span><br><span class=\"line\">339</span><br><span class=\"line\">340</span><br><span class=\"line\">341</span><br><span class=\"line\">342</span><br><span class=\"line\">343</span><br><span class=\"line\">344</span><br><span class=\"line\">345</span><br><span class=\"line\">346</span><br><span class=\"line\">347</span><br><span class=\"line\">348</span><br><span class=\"line\">349</span><br><span class=\"line\">350</span><br><span class=\"line\">351</span><br><span class=\"line\">352</span><br><span class=\"line\">353</span><br><span class=\"line\">354</span><br><span class=\"line\">355</span><br><span class=\"line\">356</span><br><span class=\"line\">357</span><br><span class=\"line\">358</span><br><span class=\"line\">359</span><br><span class=\"line\">360</span><br><span class=\"line\">361</span><br><span class=\"line\">362</span><br><span class=\"line\">363</span><br><span class=\"line\">364</span><br><span class=\"line\">365</span><br><span class=\"line\">366</span><br><span class=\"line\">367</span><br><span class=\"line\">368</span><br><span class=\"line\">369</span><br><span class=\"line\">370</span><br><span class=\"line\">371</span><br><span class=\"line\">372</span><br><span class=\"line\">373</span><br><span class=\"line\">374</span><br><span class=\"line\">375</span><br><span class=\"line\">376</span><br><span class=\"line\">377</span><br><span class=\"line\">378</span><br><span class=\"line\">379</span><br><span class=\"line\">380</span><br><span class=\"line\">381</span><br><span class=\"line\">382</span><br><span class=\"line\">383</span><br><span class=\"line\">384</span><br><span class=\"line\">385</span><br><span class=\"line\">386</span><br><span class=\"line\">387</span><br><span class=\"line\">388</span><br><span class=\"line\">389</span><br><span class=\"line\">390</span><br><span class=\"line\">391</span><br><span class=\"line\">392</span><br><span class=\"line\">393</span><br><span class=\"line\">394</span><br><span class=\"line\">395</span><br><span class=\"line\">396</span><br><span class=\"line\">397</span><br><span class=\"line\">398</span><br><span class=\"line\">399</span><br><span class=\"line\">400</span><br><span class=\"line\">401</span><br><span class=\"line\">402</span><br><span class=\"line\">403</span><br><span class=\"line\">404</span><br><span class=\"line\">405</span><br><span class=\"line\">406</span><br><span class=\"line\">407</span><br><span class=\"line\">408</span><br><span class=\"line\">409</span><br><span class=\"line\">410</span><br><span class=\"line\">411</span><br><span class=\"line\">412</span><br><span class=\"line\">413</span><br><span class=\"line\">414</span><br><span class=\"line\">415</span><br><span class=\"line\">416</span><br><span class=\"line\">417</span><br><span class=\"line\">418</span><br><span class=\"line\">419</span><br><span class=\"line\">420</span><br><span class=\"line\">421</span><br><span class=\"line\">422</span><br><span class=\"line\">423</span><br><span class=\"line\">424</span><br><span class=\"line\">425</span><br><span class=\"line\">426</span><br><span class=\"line\">427</span><br><span class=\"line\">428</span><br><span class=\"line\">429</span><br><span class=\"line\">430</span><br><span class=\"line\">431</span><br><span class=\"line\">432</span><br><span class=\"line\">433</span><br><span class=\"line\">434</span><br><span class=\"line\">435</span><br><span class=\"line\">436</span><br><span class=\"line\">437</span><br><span class=\"line\">438</span><br><span class=\"line\">439</span><br><span class=\"line\">440</span><br><span class=\"line\">441</span><br><span class=\"line\">442</span><br><span class=\"line\">443</span><br><span class=\"line\">444</span><br><span class=\"line\">445</span><br><span class=\"line\">446</span><br><span class=\"line\">447</span><br><span class=\"line\">448</span><br><span class=\"line\">449</span><br><span class=\"line\">450</span><br><span class=\"line\">451</span><br><span class=\"line\">452</span><br><span class=\"line\">453</span><br><span class=\"line\">454</span><br><span class=\"line\">455</span><br><span class=\"line\">456</span><br><span class=\"line\">457</span><br><span class=\"line\">458</span><br><span class=\"line\">459</span><br><span class=\"line\">460</span><br><span class=\"line\">461</span><br><span class=\"line\">462</span><br><span class=\"line\">463</span><br><span class=\"line\">464</span><br><span class=\"line\">465</span><br><span class=\"line\">466</span><br><span class=\"line\">467</span><br><span class=\"line\">468</span><br><span class=\"line\">469</span><br><span class=\"line\">470</span><br><span class=\"line\">471</span><br><span class=\"line\">472</span><br><span class=\"line\">473</span><br><span class=\"line\">474</span><br><span class=\"line\">475</span><br><span class=\"line\">476</span><br><span class=\"line\">477</span><br><span class=\"line\">478</span><br><span class=\"line\">479</span><br><span class=\"line\">480</span><br><span class=\"line\">481</span><br><span class=\"line\">482</span><br><span class=\"line\">483</span><br><span class=\"line\">484</span><br><span class=\"line\">485</span><br><span class=\"line\">486</span><br><span class=\"line\">487</span><br><span class=\"line\">488</span><br><span class=\"line\">489</span><br><span class=\"line\">490</span><br><span class=\"line\">491</span><br><span class=\"line\">492</span><br><span class=\"line\">493</span><br><span class=\"line\">494</span><br><span class=\"line\">495</span><br><span class=\"line\">496</span><br><span class=\"line\">497</span><br><span class=\"line\">498</span><br><span class=\"line\">499</span><br><span class=\"line\">500</span><br><span class=\"line\">501</span><br><span class=\"line\">502</span><br><span class=\"line\">503</span><br><span class=\"line\">504</span><br><span class=\"line\">505</span><br><span class=\"line\">506</span><br><span class=\"line\">507</span><br><span class=\"line\">508</span><br><span class=\"line\">509</span><br><span class=\"line\">510</span><br><span class=\"line\">511</span><br><span class=\"line\">512</span><br><span class=\"line\">513</span><br><span class=\"line\">514</span><br><span class=\"line\">515</span><br><span class=\"line\">516</span><br><span class=\"line\">517</span><br><span class=\"line\">518</span><br><span class=\"line\">519</span><br><span class=\"line\">520</span><br><span class=\"line\">521</span><br><span class=\"line\">522</span><br><span class=\"line\">523</span><br><span class=\"line\">524</span><br><span class=\"line\">525</span><br><span class=\"line\">526</span><br><span class=\"line\">527</span><br><span class=\"line\">528</span><br><span class=\"line\">529</span><br><span class=\"line\">530</span><br><span class=\"line\">531</span><br><span class=\"line\">532</span><br><span class=\"line\">533</span><br><span class=\"line\">534</span><br><span class=\"line\">535</span><br><span class=\"line\">536</span><br><span class=\"line\">537</span><br><span class=\"line\">538</span><br><span class=\"line\">539</span><br><span class=\"line\">540</span><br><span class=\"line\">541</span><br><span class=\"line\">542</span><br><span class=\"line\">543</span><br><span class=\"line\">544</span><br><span class=\"line\">545</span><br><span class=\"line\">546</span><br><span class=\"line\">547</span><br><span class=\"line\">548</span><br><span class=\"line\">549</span><br><span class=\"line\">550</span><br><span class=\"line\">551</span><br><span class=\"line\">552</span><br><span class=\"line\">553</span><br><span class=\"line\">554</span><br><span class=\"line\">555</span><br><span class=\"line\">556</span><br><span class=\"line\">557</span><br><span class=\"line\">558</span><br><span class=\"line\">559</span><br><span class=\"line\">560</span><br><span class=\"line\">561</span><br><span class=\"line\">562</span><br><span class=\"line\">563</span><br><span class=\"line\">564</span><br><span class=\"line\">565</span><br><span class=\"line\">566</span><br><span class=\"line\">567</span><br><span class=\"line\">568</span><br><span class=\"line\">569</span><br><span class=\"line\">570</span><br><span class=\"line\">571</span><br><span class=\"line\">572</span><br><span class=\"line\">573</span><br><span class=\"line\">574</span><br><span class=\"line\">575</span><br><span class=\"line\">576</span><br><span class=\"line\">577</span><br><span class=\"line\">578</span><br><span class=\"line\">579</span><br><span class=\"line\">580</span><br><span class=\"line\">581</span><br><span class=\"line\">582</span><br><span class=\"line\">583</span><br><span class=\"line\">584</span><br><span class=\"line\">585</span><br><span class=\"line\">586</span><br><span class=\"line\">587</span><br><span class=\"line\">588</span><br><span class=\"line\">589</span><br><span class=\"line\">590</span><br><span class=\"line\">591</span><br><span class=\"line\">592</span><br><span class=\"line\">593</span><br><span class=\"line\">594</span><br><span class=\"line\">595</span><br><span class=\"line\">596</span><br><span class=\"line\">597</span><br><span class=\"line\">598</span><br><span class=\"line\">599</span><br><span class=\"line\">600</span><br><span class=\"line\">601</span><br><span class=\"line\">602</span><br><span class=\"line\">603</span><br><span class=\"line\">604</span><br><span class=\"line\">605</span><br><span class=\"line\">606</span><br><span class=\"line\">607</span><br><span class=\"line\">608</span><br><span class=\"line\">609</span><br><span class=\"line\">610</span><br><span class=\"line\">611</span><br><span class=\"line\">612</span><br><span class=\"line\">613</span><br><span class=\"line\">614</span><br><span class=\"line\">615</span><br><span class=\"line\">616</span><br><span class=\"line\">617</span><br><span class=\"line\">618</span><br><span class=\"line\">619</span><br><span class=\"line\">620</span><br><span class=\"line\">621</span><br><span class=\"line\">622</span><br><span class=\"line\">623</span><br><span class=\"line\">624</span><br><span class=\"line\">625</span><br><span class=\"line\">626</span><br><span class=\"line\">627</span><br><span class=\"line\">628</span><br><span class=\"line\">629</span><br><span class=\"line\">630</span><br><span class=\"line\">631</span><br><span class=\"line\">632</span><br><span class=\"line\">633</span><br><span class=\"line\">634</span><br><span class=\"line\">635</span><br><span class=\"line\">636</span><br><span class=\"line\">637</span><br><span class=\"line\">638</span><br><span class=\"line\">639</span><br><span class=\"line\">640</span><br><span class=\"line\">641</span><br><span class=\"line\">642</span><br><span class=\"line\">643</span><br><span class=\"line\">644</span><br><span class=\"line\">645</span><br><span class=\"line\">646</span><br><span class=\"line\">647</span><br><span class=\"line\">648</span><br><span class=\"line\">649</span><br><span class=\"line\">650</span><br><span class=\"line\">651</span><br><span class=\"line\">652</span><br><span class=\"line\">653</span><br><span class=\"line\">654</span><br><span class=\"line\">655</span><br><span class=\"line\">656</span><br><span class=\"line\">657</span><br><span class=\"line\">658</span><br><span class=\"line\">659</span><br><span class=\"line\">660</span><br><span class=\"line\">661</span><br><span class=\"line\">662</span><br><span class=\"line\">663</span><br><span class=\"line\">664</span><br><span class=\"line\">665</span><br><span class=\"line\">666</span><br><span class=\"line\">667</span><br><span class=\"line\">668</span><br><span class=\"line\">669</span><br><span class=\"line\">670</span><br><span class=\"line\">671</span><br><span class=\"line\">672</span><br><span class=\"line\">673</span><br><span class=\"line\">674</span><br><span class=\"line\">675</span><br><span class=\"line\">676</span><br><span class=\"line\">677</span><br><span class=\"line\">678</span><br><span class=\"line\">679</span><br><span class=\"line\">680</span><br><span class=\"line\">681</span><br><span class=\"line\">682</span><br><span class=\"line\">683</span><br><span class=\"line\">684</span><br><span class=\"line\">685</span><br><span class=\"line\">686</span><br><span class=\"line\">687</span><br><span class=\"line\">688</span><br><span class=\"line\">689</span><br><span class=\"line\">690</span><br><span class=\"line\">691</span><br><span class=\"line\">692</span><br><span class=\"line\">693</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* </span><br><span class=\"line\"> *  V4L2 video capture example </span><br><span class=\"line\"> * </span><br><span class=\"line\"> *  This program can be used and distributed without restrictions. </span><br><span class=\"line\"> * </span><br><span class=\"line\"> *      This program is provided with the V4L2 API </span><br><span class=\"line\"> * see http://linuxtv.org/docs.php for more information </span><br><span class=\"line\"> */  </span><br><span class=\"line\">  </span><br><span class=\"line\">#include &lt;stdio.h&gt;  </span><br><span class=\"line\">#include &lt;stdlib.h&gt;  </span><br><span class=\"line\">#include &lt;string.h&gt;  </span><br><span class=\"line\">#include &lt;assert.h&gt;  </span><br><span class=\"line\">  </span><br><span class=\"line\">#include &lt;getopt.h&gt;             /* getopt_long() */  </span><br><span class=\"line\">  </span><br><span class=\"line\">#include &lt;fcntl.h&gt;              /* low-level i/o */  </span><br><span class=\"line\">#include &lt;unistd.h&gt;  </span><br><span class=\"line\">#include &lt;errno.h&gt;  </span><br><span class=\"line\">#include &lt;sys/stat.h&gt;  </span><br><span class=\"line\">#include &lt;sys/types.h&gt;  </span><br><span class=\"line\">#include &lt;sys/time.h&gt;  </span><br><span class=\"line\">#include &lt;sys/mman.h&gt;  </span><br><span class=\"line\">#include &lt;sys/ioctl.h&gt;  </span><br><span class=\"line\">  </span><br><span class=\"line\">#include &lt;linux/videodev2.h&gt;  </span><br><span class=\"line\">  </span><br><span class=\"line\">#define CLEAR(x) memset(&amp;(x), 0, sizeof(x))  </span><br><span class=\"line\">  </span><br><span class=\"line\">enum io_method &#123;  </span><br><span class=\"line\">        IO_METHOD_READ,  </span><br><span class=\"line\">        IO_METHOD_MMAP,  </span><br><span class=\"line\">        IO_METHOD_USERPTR,  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\">struct buffer &#123;  </span><br><span class=\"line\">        void   *start;  </span><br><span class=\"line\">        size_t  length;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\">static char            *dev_name;  </span><br><span class=\"line\">static enum io_method   io = IO_METHOD_MMAP;  </span><br><span class=\"line\">static int              fd = -1;  </span><br><span class=\"line\">struct buffer          *buffers;  </span><br><span class=\"line\">static unsigned int     n_buffers;  </span><br><span class=\"line\">static int              out_buf;  </span><br><span class=\"line\">static int              force_format;  </span><br><span class=\"line\">static int              frame_count = 70;  </span><br><span class=\"line\">  </span><br><span class=\"line\">/* </span><br><span class=\"line\"> * </span><br><span class=\"line\"> * </span><br><span class=\"line\"> * </span><br><span class=\"line\"> * </span><br><span class=\"line\"> */  </span><br><span class=\"line\">static void errno_exit(const char *s)  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">        fprintf(stderr, &quot;%s error %d, %s\\n&quot;, s, errno, strerror(errno));  </span><br><span class=\"line\">        exit(EXIT_FAILURE);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">static int xioctl(int fh, int request, void *arg)  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">        int r;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        do &#123;  </span><br><span class=\"line\">                r = ioctl(fh, request, arg);  </span><br><span class=\"line\">        &#125; while (-1 == r &amp;&amp; EINTR == errno);  </span><br><span class=\"line\">  </span><br><span class=\"line\">        return r;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">static void process_image(const void *p, int size)  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">        if (out_buf)  </span><br><span class=\"line\">                fwrite(p, size, 1, stdout);  </span><br><span class=\"line\">  </span><br><span class=\"line\">        fflush(stderr);  </span><br><span class=\"line\">        fprintf(stderr, &quot;.&quot;);  </span><br><span class=\"line\">        fflush(stdout);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">static int read_frame(void)  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">        struct v4l2_buffer buf;  </span><br><span class=\"line\">        unsigned int i;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        switch (io) &#123;  </span><br><span class=\"line\">        case IO_METHOD_READ:  </span><br><span class=\"line\">                if (-1 == read(fd, buffers[0].start, buffers[0].length)) &#123;  </span><br><span class=\"line\">                        switch (errno) &#123;  </span><br><span class=\"line\">                        case EAGAIN:  </span><br><span class=\"line\">                                return 0;  </span><br><span class=\"line\">  </span><br><span class=\"line\">                        case EIO:  </span><br><span class=\"line\">                                /* Could ignore EIO, see spec. */  </span><br><span class=\"line\">  </span><br><span class=\"line\">                                /* fall through */  </span><br><span class=\"line\">  </span><br><span class=\"line\">                        default:  </span><br><span class=\"line\">                                errno_exit(&quot;read&quot;);  </span><br><span class=\"line\">                        &#125;  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">                process_image(buffers[0].start, buffers[0].length);  </span><br><span class=\"line\">                break;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        case IO_METHOD_MMAP:  </span><br><span class=\"line\">                CLEAR(buf);  </span><br><span class=\"line\">  </span><br><span class=\"line\">                buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;  </span><br><span class=\"line\">                buf.memory = V4L2_MEMORY_MMAP;  </span><br><span class=\"line\">  </span><br><span class=\"line\">                if (-1 == xioctl(fd, VIDIOC_DQBUF, &amp;buf)) &#123;  </span><br><span class=\"line\">                        switch (errno) &#123;  </span><br><span class=\"line\">                        case EAGAIN:  </span><br><span class=\"line\">                                return 0;  </span><br><span class=\"line\">  </span><br><span class=\"line\">                        case EIO:  </span><br><span class=\"line\">                                /* Could ignore EIO, see spec. */  </span><br><span class=\"line\">  </span><br><span class=\"line\">                                /* fall through */  </span><br><span class=\"line\">  </span><br><span class=\"line\">                        default:  </span><br><span class=\"line\">                                errno_exit(&quot;VIDIOC_DQBUF&quot;);  </span><br><span class=\"line\">                        &#125;  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">                assert(buf.index &lt; n_buffers);  </span><br><span class=\"line\">  </span><br><span class=\"line\">                process_image(buffers[buf.index].start, buf.bytesused);  </span><br><span class=\"line\">  </span><br><span class=\"line\">                if (-1 == xioctl(fd, VIDIOC_QBUF, &amp;buf))  </span><br><span class=\"line\">                        errno_exit(&quot;VIDIOC_QBUF&quot;);  </span><br><span class=\"line\">                break;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        case IO_METHOD_USERPTR:  </span><br><span class=\"line\">                CLEAR(buf);  </span><br><span class=\"line\">  </span><br><span class=\"line\">                buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;  </span><br><span class=\"line\">                buf.memory = V4L2_MEMORY_USERPTR;  </span><br><span class=\"line\">  </span><br><span class=\"line\">                if (-1 == xioctl(fd, VIDIOC_DQBUF, &amp;buf)) &#123;  </span><br><span class=\"line\">                        switch (errno) &#123;  </span><br><span class=\"line\">                        case EAGAIN:  </span><br><span class=\"line\">                                return 0;  </span><br><span class=\"line\">  </span><br><span class=\"line\">                        case EIO:  </span><br><span class=\"line\">                                /* Could ignore EIO, see spec. */  </span><br><span class=\"line\">  </span><br><span class=\"line\">                                /* fall through */  </span><br><span class=\"line\">  </span><br><span class=\"line\">                        default:  </span><br><span class=\"line\">                                errno_exit(&quot;VIDIOC_DQBUF&quot;);  </span><br><span class=\"line\">                        &#125;  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">                for (i = 0; i &lt; n_buffers; ++i)  </span><br><span class=\"line\">                        if (buf.m.userptr == (unsigned long)buffers[i].start  </span><br><span class=\"line\">                            &amp;&amp; buf.length == buffers[i].length)  </span><br><span class=\"line\">                                break;  </span><br><span class=\"line\">  </span><br><span class=\"line\">                assert(i &lt; n_buffers);  </span><br><span class=\"line\">  </span><br><span class=\"line\">                process_image((void *)buf.m.userptr, buf.bytesused);  </span><br><span class=\"line\">  </span><br><span class=\"line\">                if (-1 == xioctl(fd, VIDIOC_QBUF, &amp;buf))  </span><br><span class=\"line\">                        errno_exit(&quot;VIDIOC_QBUF&quot;);  </span><br><span class=\"line\">                break;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        return 1;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">/* two operations </span><br><span class=\"line\"> * step1 : delay </span><br><span class=\"line\"> * step2 : read frame </span><br><span class=\"line\"> */  </span><br><span class=\"line\">static void mainloop(void)  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">        unsigned int count;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        count = frame_count;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        while (count-- &gt; 0) &#123;  </span><br><span class=\"line\">                for (;;) &#123;  </span><br><span class=\"line\">                        fd_set fds;  </span><br><span class=\"line\">                        struct timeval tv;  </span><br><span class=\"line\">                        int r;  </span><br><span class=\"line\">  </span><br><span class=\"line\">                        FD_ZERO(&amp;fds);  </span><br><span class=\"line\">                        FD_SET(fd, &amp;fds);  </span><br><span class=\"line\">  </span><br><span class=\"line\">                        /* Timeout. */  </span><br><span class=\"line\">                        tv.tv_sec = 2;  </span><br><span class=\"line\">                        tv.tv_usec = 0;  </span><br><span class=\"line\">  </span><br><span class=\"line\">                        r = select(fd + 1, &amp;fds, NULL, NULL, &amp;tv);  </span><br><span class=\"line\">  </span><br><span class=\"line\">                        if (-1 == r) &#123;  </span><br><span class=\"line\">                                if (EINTR == errno)  </span><br><span class=\"line\">                                        continue;  </span><br><span class=\"line\">                                errno_exit(&quot;select&quot;);  </span><br><span class=\"line\">                        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">                        if (0 == r) &#123;  </span><br><span class=\"line\">                                fprintf(stderr, &quot;select timeout\\n&quot;);  </span><br><span class=\"line\">                                exit(EXIT_FAILURE);  </span><br><span class=\"line\">                        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">                        if (read_frame())  </span><br><span class=\"line\">                                break;  </span><br><span class=\"line\">                        /* EAGAIN - continue select loop. */  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">/* </span><br><span class=\"line\"> * one operation </span><br><span class=\"line\"> * step1 : VIDIOC_STREAMOFF </span><br><span class=\"line\"> */  </span><br><span class=\"line\">static void stop_capturing(void)  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">        enum v4l2_buf_type type;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        switch (io) &#123;  </span><br><span class=\"line\">        case IO_METHOD_READ:  </span><br><span class=\"line\">                /* Nothing to do. */  </span><br><span class=\"line\">                break;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        case IO_METHOD_MMAP:  </span><br><span class=\"line\">        case IO_METHOD_USERPTR:  </span><br><span class=\"line\">                type = V4L2_BUF_TYPE_VIDEO_CAPTURE;  </span><br><span class=\"line\">                if (-1 == xioctl(fd, VIDIOC_STREAMOFF, &amp;type))  </span><br><span class=\"line\">                        errno_exit(&quot;VIDIOC_STREAMOFF&quot;);  </span><br><span class=\"line\">                break;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">/* tow operations </span><br><span class=\"line\"> * step1 : VIDIOC_QBUF(insert buffer to queue) </span><br><span class=\"line\"> * step2 : VIDIOC_STREAMOFF </span><br><span class=\"line\"> */  </span><br><span class=\"line\">static void start_capturing(void)  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">        unsigned int i;  </span><br><span class=\"line\">        enum v4l2_buf_type type;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        switch (io) &#123;  </span><br><span class=\"line\">        case IO_METHOD_READ:  </span><br><span class=\"line\">                /* Nothing to do. */  </span><br><span class=\"line\">                break;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        case IO_METHOD_MMAP:  </span><br><span class=\"line\">                for (i = 0; i &lt; n_buffers; ++i) &#123;  </span><br><span class=\"line\">                        struct v4l2_buffer buf;  </span><br><span class=\"line\">  </span><br><span class=\"line\">                        CLEAR(buf);  </span><br><span class=\"line\">                        buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;  </span><br><span class=\"line\">                        buf.memory = V4L2_MEMORY_MMAP;  </span><br><span class=\"line\">                        buf.index = i;  </span><br><span class=\"line\">  </span><br><span class=\"line\">                        if (-1 == xioctl(fd, VIDIOC_QBUF, &amp;buf))  </span><br><span class=\"line\">                                errno_exit(&quot;VIDIOC_QBUF&quot;);  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">                type = V4L2_BUF_TYPE_VIDEO_CAPTURE;  </span><br><span class=\"line\">                if (-1 == xioctl(fd, VIDIOC_STREAMON, &amp;type))  </span><br><span class=\"line\">                        errno_exit(&quot;VIDIOC_STREAMON&quot;);  </span><br><span class=\"line\">                break;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        case IO_METHOD_USERPTR:  </span><br><span class=\"line\">                for (i = 0; i &lt; n_buffers; ++i) &#123;  </span><br><span class=\"line\">                        struct v4l2_buffer buf;  </span><br><span class=\"line\">  </span><br><span class=\"line\">                        CLEAR(buf);  </span><br><span class=\"line\">                        buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;  </span><br><span class=\"line\">                        buf.memory = V4L2_MEMORY_USERPTR;  </span><br><span class=\"line\">                        buf.index = i;  </span><br><span class=\"line\">                        buf.m.userptr = (unsigned long)buffers[i].start;  </span><br><span class=\"line\">                        buf.length = buffers[i].length;  </span><br><span class=\"line\">  </span><br><span class=\"line\">                        if (-1 == xioctl(fd, VIDIOC_QBUF, &amp;buf))  </span><br><span class=\"line\">                                errno_exit(&quot;VIDIOC_QBUF&quot;);  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">                type = V4L2_BUF_TYPE_VIDEO_CAPTURE;  </span><br><span class=\"line\">                if (-1 == xioctl(fd, VIDIOC_STREAMON, &amp;type))  </span><br><span class=\"line\">                        errno_exit(&quot;VIDIOC_STREAMON&quot;);  </span><br><span class=\"line\">                break;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">/* two operations </span><br><span class=\"line\"> * step1 : munmap buffers </span><br><span class=\"line\"> * steo2 : free buffers </span><br><span class=\"line\"> */  </span><br><span class=\"line\">static void uninit_device(void)  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">        unsigned int i;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        switch (io) &#123;  </span><br><span class=\"line\">        case IO_METHOD_READ:  </span><br><span class=\"line\">                free(buffers[0].start);  </span><br><span class=\"line\">                break;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        case IO_METHOD_MMAP:  </span><br><span class=\"line\">                for (i = 0; i &lt; n_buffers; ++i)  </span><br><span class=\"line\">                        if (-1 == munmap(buffers[i].start, buffers[i].length))  </span><br><span class=\"line\">                                errno_exit(&quot;munmap&quot;);  </span><br><span class=\"line\">                break;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        case IO_METHOD_USERPTR:  </span><br><span class=\"line\">                for (i = 0; i &lt; n_buffers; ++i)  </span><br><span class=\"line\">                        free(buffers[i].start);  </span><br><span class=\"line\">                break;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        free(buffers);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">static void init_read(unsigned int buffer_size)  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">        buffers = calloc(1, sizeof(*buffers));  </span><br><span class=\"line\">  </span><br><span class=\"line\">        if (!buffers) &#123;  </span><br><span class=\"line\">                fprintf(stderr, &quot;Out of memory\\n&quot;);  </span><br><span class=\"line\">                exit(EXIT_FAILURE);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        buffers[0].length = buffer_size;  </span><br><span class=\"line\">        buffers[0].start = malloc(buffer_size);  </span><br><span class=\"line\">  </span><br><span class=\"line\">        if (!buffers[0].start) &#123;  </span><br><span class=\"line\">                fprintf(stderr, &quot;Out of memory\\n&quot;);  </span><br><span class=\"line\">                exit(EXIT_FAILURE);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">static void init_mmap(void)  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">        struct v4l2_requestbuffers req;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        CLEAR(req);  </span><br><span class=\"line\">  </span><br><span class=\"line\">        req.count = 4;  </span><br><span class=\"line\">        req.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;  </span><br><span class=\"line\">        req.memory = V4L2_MEMORY_MMAP;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        if (-1 == xioctl(fd, VIDIOC_REQBUFS, &amp;req)) &#123;  </span><br><span class=\"line\">                if (EINVAL == errno) &#123;  </span><br><span class=\"line\">                        fprintf(stderr, &quot;%s does not support &quot;  </span><br><span class=\"line\">                                 &quot;memory mapping\\n&quot;, dev_name);  </span><br><span class=\"line\">                        exit(EXIT_FAILURE);  </span><br><span class=\"line\">                &#125; else &#123;  </span><br><span class=\"line\">                        errno_exit(&quot;VIDIOC_REQBUFS&quot;);  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        if (req.count &lt; 2) &#123;  </span><br><span class=\"line\">                fprintf(stderr, &quot;Insufficient buffer memory on %s\\n&quot;,  </span><br><span class=\"line\">                         dev_name);  </span><br><span class=\"line\">                exit(EXIT_FAILURE);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        buffers = calloc(req.count, sizeof(*buffers));  </span><br><span class=\"line\">  </span><br><span class=\"line\">        if (!buffers) &#123;  </span><br><span class=\"line\">                fprintf(stderr, &quot;Out of memory\\n&quot;);  </span><br><span class=\"line\">                exit(EXIT_FAILURE);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        for (n_buffers = 0; n_buffers &lt; req.count; ++n_buffers) &#123;  </span><br><span class=\"line\">                struct v4l2_buffer buf;  </span><br><span class=\"line\">  </span><br><span class=\"line\">                CLEAR(buf);  </span><br><span class=\"line\">  </span><br><span class=\"line\">                buf.type        = V4L2_BUF_TYPE_VIDEO_CAPTURE;  </span><br><span class=\"line\">                buf.memory      = V4L2_MEMORY_MMAP;  </span><br><span class=\"line\">                buf.index       = n_buffers;  </span><br><span class=\"line\">  </span><br><span class=\"line\">                if (-1 == xioctl(fd, VIDIOC_QUERYBUF, &amp;buf))  </span><br><span class=\"line\">                        errno_exit(&quot;VIDIOC_QUERYBUF&quot;);  </span><br><span class=\"line\">  </span><br><span class=\"line\">                buffers[n_buffers].length = buf.length;  </span><br><span class=\"line\">                buffers[n_buffers].start =  </span><br><span class=\"line\">                        mmap(NULL /* start anywhere */,  </span><br><span class=\"line\">                              buf.length,  </span><br><span class=\"line\">                              PROT_READ | PROT_WRITE /* required */,  </span><br><span class=\"line\">                              MAP_SHARED /* recommended */,  </span><br><span class=\"line\">                              fd, buf.m.offset);  </span><br><span class=\"line\">  </span><br><span class=\"line\">                if (MAP_FAILED == buffers[n_buffers].start)  </span><br><span class=\"line\">                        errno_exit(&quot;mmap&quot;);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">static void init_userp(unsigned int buffer_size)  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">        struct v4l2_requestbuffers req;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        CLEAR(req);  </span><br><span class=\"line\">  </span><br><span class=\"line\">        req.count  = 4;  </span><br><span class=\"line\">        req.type   = V4L2_BUF_TYPE_VIDEO_CAPTURE;  </span><br><span class=\"line\">        req.memory = V4L2_MEMORY_USERPTR;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        if (-1 == xioctl(fd, VIDIOC_REQBUFS, &amp;req)) &#123;  </span><br><span class=\"line\">                if (EINVAL == errno) &#123;  </span><br><span class=\"line\">                        fprintf(stderr, &quot;%s does not support &quot;  </span><br><span class=\"line\">                                 &quot;user pointer i/o\\n&quot;, dev_name);  </span><br><span class=\"line\">                        exit(EXIT_FAILURE);  </span><br><span class=\"line\">                &#125; else &#123;  </span><br><span class=\"line\">                        errno_exit(&quot;VIDIOC_REQBUFS&quot;);  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        buffers = calloc(4, sizeof(*buffers));  </span><br><span class=\"line\">  </span><br><span class=\"line\">        if (!buffers) &#123;  </span><br><span class=\"line\">                fprintf(stderr, &quot;Out of memory\\n&quot;);  </span><br><span class=\"line\">                exit(EXIT_FAILURE);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        for (n_buffers = 0; n_buffers &lt; 4; ++n_buffers) &#123;  </span><br><span class=\"line\">                buffers[n_buffers].length = buffer_size;  </span><br><span class=\"line\">                buffers[n_buffers].start = malloc(buffer_size);  </span><br><span class=\"line\">  </span><br><span class=\"line\">                if (!buffers[n_buffers].start) &#123;  </span><br><span class=\"line\">                        fprintf(stderr, &quot;Out of memory\\n&quot;);  </span><br><span class=\"line\">                        exit(EXIT_FAILURE);  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">/* five operations </span><br><span class=\"line\"> * step1 : cap :query camera&apos;s capability and check it(is a video device? is it support read? is it support streaming?) </span><br><span class=\"line\"> * step2 : cropcap:set cropcap&apos;s type and get cropcap by VIDIOC_CROPCAP </span><br><span class=\"line\"> * step3 : set crop parameter by VIDIOC_S_CROP (such as frame type and angle) </span><br><span class=\"line\"> * step4 : set fmt </span><br><span class=\"line\"> * step5 : mmap </span><br><span class=\"line\"> */  </span><br><span class=\"line\">static void init_device(void)  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">        struct v4l2_capability cap;  </span><br><span class=\"line\">        struct v4l2_cropcap cropcap;  </span><br><span class=\"line\">        struct v4l2_crop crop;  </span><br><span class=\"line\">        struct v4l2_format fmt;  </span><br><span class=\"line\">        unsigned int min;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        if (-1 == xioctl(fd, VIDIOC_QUERYCAP, &amp;cap)) &#123;  </span><br><span class=\"line\">                if (EINVAL == errno) &#123;  </span><br><span class=\"line\">                        fprintf(stderr, &quot;%s is no V4L2 device\\n&quot;,  </span><br><span class=\"line\">                                 dev_name);  </span><br><span class=\"line\">                        exit(EXIT_FAILURE);  </span><br><span class=\"line\">                &#125; else &#123;  </span><br><span class=\"line\">                        errno_exit(&quot;VIDIOC_QUERYCAP&quot;);  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        if (!(cap.capabilities &amp; V4L2_CAP_VIDEO_CAPTURE)) &#123;  </span><br><span class=\"line\">                fprintf(stderr, &quot;%s is no video capture device\\n&quot;,  </span><br><span class=\"line\">                         dev_name);  </span><br><span class=\"line\">                exit(EXIT_FAILURE);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        switch (io) &#123;  </span><br><span class=\"line\">        case IO_METHOD_READ:  </span><br><span class=\"line\">                if (!(cap.capabilities &amp; V4L2_CAP_READWRITE)) &#123;  </span><br><span class=\"line\">                        fprintf(stderr, &quot;%s does not support read i/o\\n&quot;,  </span><br><span class=\"line\">                                 dev_name);  </span><br><span class=\"line\">                        exit(EXIT_FAILURE);  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">                break;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        case IO_METHOD_MMAP:  </span><br><span class=\"line\">        case IO_METHOD_USERPTR:  </span><br><span class=\"line\">                if (!(cap.capabilities &amp; V4L2_CAP_STREAMING)) &#123;  </span><br><span class=\"line\">                        fprintf(stderr, &quot;%s does not support streaming i/o\\n&quot;,  </span><br><span class=\"line\">                                 dev_name);  </span><br><span class=\"line\">                        exit(EXIT_FAILURE);  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">                break;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">        /* Select video input, video standard and tune here. */  </span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">        CLEAR(cropcap);  </span><br><span class=\"line\">  </span><br><span class=\"line\">        cropcap.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;  </span><br><span class=\"line\">        /* if device support cropcap&apos;s type then set crop */  </span><br><span class=\"line\">        if (0 == xioctl(fd, VIDIOC_CROPCAP, &amp;cropcap)) &#123;  </span><br><span class=\"line\">                crop.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;  </span><br><span class=\"line\">                crop.c = cropcap.defrect; /* reset to default */  </span><br><span class=\"line\">  </span><br><span class=\"line\">                if (-1 == xioctl(fd, VIDIOC_S_CROP, &amp;crop)) &#123;  </span><br><span class=\"line\">                        switch (errno) &#123;  </span><br><span class=\"line\">                        case EINVAL:  </span><br><span class=\"line\">                                /* Cropping not supported. */  </span><br><span class=\"line\">                                break;  </span><br><span class=\"line\">                        default:  </span><br><span class=\"line\">                                /* Errors ignored. */  </span><br><span class=\"line\">                                break;  </span><br><span class=\"line\">                        &#125;  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">        &#125; else &#123;  </span><br><span class=\"line\">                /* Errors ignored. */  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">        CLEAR(fmt);  </span><br><span class=\"line\">  </span><br><span class=\"line\">        fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;  </span><br><span class=\"line\">        if (force_format) &#123;  </span><br><span class=\"line\">                fmt.fmt.pix.width       = 640;  </span><br><span class=\"line\">                fmt.fmt.pix.height      = 480;  </span><br><span class=\"line\">                fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_YUYV;  </span><br><span class=\"line\">                fmt.fmt.pix.field       = V4L2_FIELD_INTERLACED;  </span><br><span class=\"line\">  </span><br><span class=\"line\">                if (-1 == xioctl(fd, VIDIOC_S_FMT, &amp;fmt))  </span><br><span class=\"line\">                        errno_exit(&quot;VIDIOC_S_FMT&quot;);  </span><br><span class=\"line\">  </span><br><span class=\"line\">                /* Note VIDIOC_S_FMT may change width and height. */  </span><br><span class=\"line\">        &#125; else &#123;  </span><br><span class=\"line\">                /* Preserve original settings as set by v4l2-ctl for example */  </span><br><span class=\"line\">                if (-1 == xioctl(fd, VIDIOC_G_FMT, &amp;fmt))  </span><br><span class=\"line\">                        errno_exit(&quot;VIDIOC_G_FMT&quot;);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        /* Buggy driver paranoia. */  </span><br><span class=\"line\">        min = fmt.fmt.pix.width * 2;  </span><br><span class=\"line\">        if (fmt.fmt.pix.bytesperline &lt; min)  </span><br><span class=\"line\">                fmt.fmt.pix.bytesperline = min;  </span><br><span class=\"line\">        min = fmt.fmt.pix.bytesperline * fmt.fmt.pix.height;  </span><br><span class=\"line\">        if (fmt.fmt.pix.sizeimage &lt; min)  </span><br><span class=\"line\">                fmt.fmt.pix.sizeimage = min;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        switch (io) &#123;  </span><br><span class=\"line\">        case IO_METHOD_READ:  </span><br><span class=\"line\">                init_read(fmt.fmt.pix.sizeimage);  </span><br><span class=\"line\">                break;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        case IO_METHOD_MMAP:  </span><br><span class=\"line\">                init_mmap();  </span><br><span class=\"line\">                break;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        case IO_METHOD_USERPTR:  </span><br><span class=\"line\">                init_userp(fmt.fmt.pix.sizeimage);  </span><br><span class=\"line\">                break;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">/* </span><br><span class=\"line\"> * close (fd) </span><br><span class=\"line\"> */  </span><br><span class=\"line\">static void close_device(void)  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">        if (-1 == close(fd))  </span><br><span class=\"line\">                errno_exit(&quot;close&quot;);  </span><br><span class=\"line\">  </span><br><span class=\"line\">        fd = -1;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">/* three operations </span><br><span class=\"line\"> * step 1 : check dev_name and st_mode </span><br><span class=\"line\"> * step 2 : open(device) </span><br><span class=\"line\"> */  </span><br><span class=\"line\">static void open_device(void)  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">        struct stat st;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        if (-1 == stat(dev_name, &amp;st)) &#123;  </span><br><span class=\"line\">                fprintf(stderr, &quot;Cannot identify &apos;%s&apos;: %d, %s\\n&quot;,  </span><br><span class=\"line\">                         dev_name, errno, strerror(errno));  </span><br><span class=\"line\">                exit(EXIT_FAILURE);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        if (!S_ISCHR(st.st_mode)) &#123;  </span><br><span class=\"line\">                fprintf(stderr, &quot;%s is no device\\n&quot;, dev_name);  </span><br><span class=\"line\">                exit(EXIT_FAILURE);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        fd = open(dev_name, O_RDWR /* required */ | O_NONBLOCK, 0);  </span><br><span class=\"line\">  </span><br><span class=\"line\">        if (-1 == fd) &#123;  </span><br><span class=\"line\">                fprintf(stderr, &quot;Cannot open &apos;%s&apos;: %d, %s\\n&quot;,  </span><br><span class=\"line\">                         dev_name, errno, strerror(errno));  </span><br><span class=\"line\">                exit(EXIT_FAILURE);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">static void usage(FILE *fp, int argc, char **argv)  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">        fprintf(fp,  </span><br><span class=\"line\">                 &quot;Usage: %s [options]\\n\\n&quot;  </span><br><span class=\"line\">                 &quot;Version 1.3\\n&quot;  </span><br><span class=\"line\">                 &quot;Options:\\n&quot;  </span><br><span class=\"line\">                 &quot;-d | --device name   Video device name [%s]\\n&quot;  </span><br><span class=\"line\">                 &quot;-h | --help          Print this message\\n&quot;  </span><br><span class=\"line\">                 &quot;-m | --mmap          Use memory mapped buffers [default]\\n&quot;  </span><br><span class=\"line\">                 &quot;-r | --read          Use read() calls\\n&quot;  </span><br><span class=\"line\">                 &quot;-u | --userp         Use application allocated buffers\\n&quot;  </span><br><span class=\"line\">                 &quot;-o | --output        Outputs stream to stdout\\n&quot;  </span><br><span class=\"line\">                 &quot;-f | --format        Force format to 640x480 YUYV\\n&quot;  </span><br><span class=\"line\">                 &quot;-c | --count         Number of frames to grab [%i]\\n&quot;  </span><br><span class=\"line\">                 &quot;&quot;,  </span><br><span class=\"line\">                 argv[0], dev_name, frame_count);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">static const char short_options[] = &quot;d:hmruofc:&quot;;  </span><br><span class=\"line\">  </span><br><span class=\"line\">static const struct option  </span><br><span class=\"line\">long_options[] = &#123;  </span><br><span class=\"line\">        &#123; &quot;device&quot;, required_argument, NULL, &apos;d&apos; &#125;,  </span><br><span class=\"line\">        &#123; &quot;help&quot;,   no_argument,       NULL, &apos;h&apos; &#125;,  </span><br><span class=\"line\">        &#123; &quot;mmap&quot;,   no_argument,       NULL, &apos;m&apos; &#125;,  </span><br><span class=\"line\">        &#123; &quot;read&quot;,   no_argument,       NULL, &apos;r&apos; &#125;,  </span><br><span class=\"line\">        &#123; &quot;userp&quot;,  no_argument,       NULL, &apos;u&apos; &#125;,  </span><br><span class=\"line\">        &#123; &quot;output&quot;, no_argument,       NULL, &apos;o&apos; &#125;,  </span><br><span class=\"line\">        &#123; &quot;format&quot;, no_argument,       NULL, &apos;f&apos; &#125;,  </span><br><span class=\"line\">        &#123; &quot;count&quot;,  required_argument, NULL, &apos;c&apos; &#125;,  </span><br><span class=\"line\">        &#123; 0, 0, 0, 0 &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\">int main(int argc, char **argv)  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">        dev_name = &quot;/dev/video4&quot;;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        for (;;) &#123;  </span><br><span class=\"line\">                int idx;  </span><br><span class=\"line\">                int c;  </span><br><span class=\"line\">  </span><br><span class=\"line\">                c = getopt_long(argc, argv,  </span><br><span class=\"line\">                                short_options, long_options, &amp;idx);  </span><br><span class=\"line\">  </span><br><span class=\"line\">                if (-1 == c)  </span><br><span class=\"line\">                        break;  </span><br><span class=\"line\">  </span><br><span class=\"line\">                switch (c) &#123;  </span><br><span class=\"line\">                case 0: /* getopt_long() flag */  </span><br><span class=\"line\">                        break;  </span><br><span class=\"line\">  </span><br><span class=\"line\">                case &apos;d&apos;:  </span><br><span class=\"line\">                        dev_name = optarg;  </span><br><span class=\"line\">                        break;  </span><br><span class=\"line\">  </span><br><span class=\"line\">                case &apos;h&apos;:  </span><br><span class=\"line\">                        usage(stdout, argc, argv);  </span><br><span class=\"line\">                        exit(EXIT_SUCCESS);  </span><br><span class=\"line\">  </span><br><span class=\"line\">                case &apos;m&apos;:  </span><br><span class=\"line\">                        io = IO_METHOD_MMAP;  </span><br><span class=\"line\">                        break;  </span><br><span class=\"line\">  </span><br><span class=\"line\">                case &apos;r&apos;:  </span><br><span class=\"line\">                        io = IO_METHOD_READ;  </span><br><span class=\"line\">                        break;  </span><br><span class=\"line\">  </span><br><span class=\"line\">                case &apos;u&apos;:  </span><br><span class=\"line\">                        io = IO_METHOD_USERPTR;  </span><br><span class=\"line\">                        break;  </span><br><span class=\"line\">  </span><br><span class=\"line\">                case &apos;o&apos;:  </span><br><span class=\"line\">                        out_buf++;  </span><br><span class=\"line\">                        break;  </span><br><span class=\"line\">  </span><br><span class=\"line\">                case &apos;f&apos;:  </span><br><span class=\"line\">                        force_format++;  </span><br><span class=\"line\">                        break;  </span><br><span class=\"line\">  </span><br><span class=\"line\">                case &apos;c&apos;:  </span><br><span class=\"line\">                        errno = 0;  </span><br><span class=\"line\">                        frame_count = strtol(optarg, NULL, 0);  </span><br><span class=\"line\">                        if (errno)  </span><br><span class=\"line\">                                errno_exit(optarg);  </span><br><span class=\"line\">                        break;  </span><br><span class=\"line\">  </span><br><span class=\"line\">                default:  </span><br><span class=\"line\">                        usage(stderr, argc, argv);  </span><br><span class=\"line\">                        exit(EXIT_FAILURE);  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        open_device();  </span><br><span class=\"line\">        init_device();  </span><br><span class=\"line\">        start_capturing();  </span><br><span class=\"line\">        mainloop();  </span><br><span class=\"line\">        stop_capturing();  </span><br><span class=\"line\">        uninit_device();  </span><br><span class=\"line\">        close_device();  </span><br><span class=\"line\">        fprintf(stderr, &quot;\\n&quot;);  </span><br><span class=\"line\">        return 0;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>参考：<br><a href=\"https://blog.csdn.net/u010164190/article/details/53189836\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/u010164190/article/details/53189836</a></p>\n<p><a href=\"https://blog.csdn.net/qq_38880380/article/details/78261995\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/qq_38880380/article/details/78261995</a></p>\n"}],"PostAsset":[{"_id":"source/_posts/AVFoundation学习笔记一-iOS多媒体环境/ios_media.png","slug":"ios_media.png","post":"cjyzlbt7h00030j66nd4uagbr","modified":0,"renderable":0},{"_id":"source/_posts/AVFoundation学习笔记二-AVAudioSession/session_category.png","slug":"session_category.png","post":"cjyzlbt9d002e0j668mct0214","modified":0,"renderable":0},{"_id":"source/_posts/H264-profile类型及特点/profile_decode.png","slug":"profile_decode.png","post":"cjyzlbt8c000o0j66vnitzvxu","modified":0,"renderable":0},{"_id":"source/_posts/QT基础1/help_add_frame.png","slug":"help_add_frame.png","post":"cjyzlbt8b000l0j66nb7jm83i","modified":0,"renderable":0},{"_id":"source/_posts/QT基础4——可视化编程/design_all.png","slug":"design_all.png","post":"cjyzlbt8h000x0j66w16723ma","modified":0,"renderable":0},{"_id":"source/_posts/AVFoundation学习笔记一-AVSpeechSynthesizer/SpeechSynthesizer.png","slug":"SpeechSynthesizer.png","post":"cjyzlbt7900010j66uz1rigmb","modified":0,"renderable":0},{"_id":"source/_posts/AVFoundation学习笔记二-AVAudioPlayer/audioplayer.png","slug":"audioplayer.png","post":"cjyzlbt7x00080j66q3dd230k","modified":0,"renderable":0},{"_id":"source/_posts/AVFoundation学习笔记十二-AVAssetReader-AVAssetWriter/read_write.png","slug":"read_write.png","post":"cjyzlbt88000h0j66pkspezn2","modified":0,"renderable":0},{"_id":"source/_posts/Xcode编译错误-This-application-does-not-support-this-device-s-CPU-type/buildSetting.png","slug":"buildSetting.png","post":"cjyzlbt8y001j0j665gs0ucd1","modified":0,"renderable":0},{"_id":"source/_posts/主机-三系统/主机.png","slug":"主机.png","post":"cjyzlbt92001s0j66rnm3o7od","modified":0,"renderable":0},{"_id":"source/_posts/冒泡排序/冒泡.png","slug":"冒泡.png","post":"cjyzlbt94001x0j66qfwjxm16","modified":0,"renderable":0},{"_id":"source/_posts/AVFoundation学习笔记七-读取相册内容ALAsset和PHAsset/ALAsset.png","slug":"ALAsset.png","post":"cjyzlbt7n00060j66l35sc07l","modified":0,"renderable":0},{"_id":"source/_posts/AVFoundation学习笔记七-读取相册内容ALAsset和PHAsset/PHAsset.png","slug":"PHAsset.png","post":"cjyzlbt7n00060j66l35sc07l","modified":0,"renderable":0},{"_id":"source/_posts/AVFoundation学习笔记五-AVAudioRecorder/audio_format.png","slug":"audio_format.png","post":"cjyzlbt83000b0j665s4m0o77","modified":0,"renderable":0},{"_id":"source/_posts/AVFoundation学习笔记五-AVAudioRecorder/recorder.png","slug":"recorder.png","post":"cjyzlbt83000b0j665s4m0o77","modified":0,"renderable":0},{"_id":"source/_posts/QT基础1/qt_files.png","slug":"qt_files.png","post":"cjyzlbt8b000l0j66nb7jm83i","modified":0,"renderable":0},{"_id":"source/_posts/H264-profile类型及特点/profile_feather.png","slug":"profile_feather.png","post":"cjyzlbt8c000o0j66vnitzvxu","modified":0,"renderable":0},{"_id":"source/_posts/H264-nalu类型及解析/h264_data.png","slug":"h264_data.png","post":"cjyzlbt89000j0j66l5g5ycy9","modified":0,"renderable":0},{"_id":"source/_posts/H264-nalu类型及解析/nalu_type_define.png","slug":"nalu_type_define.png","post":"cjyzlbt89000j0j66l5g5ycy9","modified":0,"renderable":0},{"_id":"source/_posts/H264-nalu类型及解析/nalu_zc.jpg","slug":"nalu_zc.jpg","post":"cjyzlbt89000j0j66l5g5ycy9","modified":0,"renderable":0},{"_id":"source/_posts/QT基础4——可视化编程/design_add.png","slug":"design_add.png","post":"cjyzlbt8h000x0j66w16723ma","modified":0,"renderable":0},{"_id":"source/_posts/QT基础4——可视化编程/design_result.png","slug":"design_result.png","post":"cjyzlbt8h000x0j66w16723ma","modified":0,"renderable":0},{"_id":"source/_posts/QT基础4——可视化编程/design_slot.png","slug":"design_slot.png","post":"cjyzlbt8h000x0j66w16723ma","modified":0,"renderable":0},{"_id":"source/_posts/SRS服务器搭建/obs.png","slug":"obs.png","post":"cjyzlbt8v001d0j6641zxftfh","modified":0,"renderable":0},{"_id":"source/_posts/SRS服务器搭建/result_rtmp.png","slug":"result_rtmp.png","post":"cjyzlbt8v001d0j6641zxftfh","modified":0,"renderable":0},{"_id":"source/_posts/SRS服务器搭建/rtmp映射.png","slug":"rtmp映射.png","post":"cjyzlbt8v001d0j6641zxftfh","modified":0,"renderable":0},{"_id":"source/_posts/SRS服务器搭建/vlc.png","slug":"vlc.png","post":"cjyzlbt8v001d0j6641zxftfh","modified":0,"renderable":0},{"_id":"source/_posts/SRS服务器-二-保存及拉取数据/obs_set.png","slug":"obs_set.png","post":"cjyzlbt8t001b0j66eof4p3uc","modified":0,"renderable":0},{"_id":"source/_posts/SRS服务器-二-保存及拉取数据/play_file.png","slug":"play_file.png","post":"cjyzlbt8t001b0j66eof4p3uc","modified":0,"renderable":0},{"_id":"source/_posts/SRS服务器-二-保存及拉取数据/pushed.png","slug":"pushed.png","post":"cjyzlbt8t001b0j66eof4p3uc","modified":0,"renderable":0},{"_id":"source/_posts/SRS服务器-二-保存及拉取数据/pushing.png","slug":"pushing.png","post":"cjyzlbt8t001b0j66eof4p3uc","modified":0,"renderable":0},{"_id":"source/_posts/SRS服务器-二-保存及拉取数据/vlc_play.png","slug":"vlc_play.png","post":"cjyzlbt8t001b0j66eof4p3uc","modified":0,"renderable":0},{"_id":"source/_posts/ssh反向代理操作内网设备/connect.png","slug":"connect.png","post":"cjyzlbt91001q0j668xnqy6jh","modified":0,"renderable":0},{"_id":"source/_posts/ssh反向代理操作内网设备/gotohttp.png","slug":"gotohttp.png","post":"cjyzlbt91001q0j668xnqy6jh","modified":0,"renderable":0},{"_id":"source/_posts/ssh反向代理操作内网设备/ssh_l.png","slug":"ssh_l.png","post":"cjyzlbt91001q0j668xnqy6jh","modified":0,"renderable":0},{"_id":"source/_posts/ssh反向代理操作内网设备/ssh_r.png","slug":"ssh_r.png","post":"cjyzlbt91001q0j668xnqy6jh","modified":0,"renderable":0},{"_id":"source/_posts/ssh反向代理操作内网设备/免密.png","slug":"免密.png","post":"cjyzlbt91001q0j668xnqy6jh","modified":0,"renderable":0},{"_id":"source/_posts/ssh反向代理操作内网设备/检验免密.png","slug":"检验免密.png","post":"cjyzlbt91001q0j668xnqy6jh","modified":0,"renderable":0},{"_id":"source/_posts/AVFoundation学习笔记八-AVPlayer及缩略图等相关功能/player_classes.png","slug":"player_classes.png","post":"cjyzlbt9e002f0j66qdgzhulr","modified":0,"renderable":0},{"_id":"source/_posts/AVFoundation学习笔记九/capture_session1.png","slug":"capture_session1.png","post":"cjyzlbt9c002d0j66bd4s1rqa","modified":0,"renderable":0},{"_id":"source/_posts/AVFoundation学习笔记八-AVPlayer及缩略图等相关功能/option_result.png","slug":"option_result.png","post":"cjyzlbt9e002f0j66qdgzhulr","modified":0,"renderable":0}],"PostCategory":[{"post_id":"cjyzlbt7q00070j665tcrhmfd","category_id":"cjyzlbt7k00040j66f1k7zu8t","_id":"cjyzlbt86000d0j666t8ifhqf"},{"post_id":"cjyzlbt7900010j66uz1rigmb","category_id":"cjyzlbt7k00040j66f1k7zu8t","_id":"cjyzlbt88000g0j66brlr1o12"},{"post_id":"cjyzlbt7x00080j66q3dd230k","category_id":"cjyzlbt7k00040j66f1k7zu8t","_id":"cjyzlbt89000i0j66px5v8ct8"},{"post_id":"cjyzlbt83000b0j665s4m0o77","category_id":"cjyzlbt7k00040j66f1k7zu8t","_id":"cjyzlbt8a000k0j6640hswla6"},{"post_id":"cjyzlbt7h00030j66nd4uagbr","category_id":"cjyzlbt7k00040j66f1k7zu8t","_id":"cjyzlbt8b000m0j66gwzf7vjc"},{"post_id":"cjyzlbt85000c0j66hifeftyx","category_id":"cjyzlbt7k00040j66f1k7zu8t","_id":"cjyzlbt8d000p0j66ojcd5rxn"},{"post_id":"cjyzlbt87000f0j66gmccd8kb","category_id":"cjyzlbt7k00040j66f1k7zu8t","_id":"cjyzlbt8e000r0j6690jyp4xh"},{"post_id":"cjyzlbt7n00060j66l35sc07l","category_id":"cjyzlbt7k00040j66f1k7zu8t","_id":"cjyzlbt8f000u0j66og1tohjz"},{"post_id":"cjyzlbt88000h0j66pkspezn2","category_id":"cjyzlbt7k00040j66f1k7zu8t","_id":"cjyzlbt8h000w0j66t7l4f69u"},{"post_id":"cjyzlbt89000j0j66l5g5ycy9","category_id":"cjyzlbt8c000n0j66i075ukim","_id":"cjyzlbt8i000y0j66qoc13fba"},{"post_id":"cjyzlbt8g000v0j66h4kk80xf","category_id":"cjyzlbt8f000t0j66lxt60rd5","_id":"cjyzlbt8m00120j66guo4g6gf"},{"post_id":"cjyzlbt8b000l0j66nb7jm83i","category_id":"cjyzlbt8f000t0j66lxt60rd5","_id":"cjyzlbt8o00150j66ef9vgjg1"},{"post_id":"cjyzlbt8h000x0j66w16723ma","category_id":"cjyzlbt8f000t0j66lxt60rd5","_id":"cjyzlbt8p00170j66wzna8zhl"},{"post_id":"cjyzlbt8j00100j66ju4c3ezn","category_id":"cjyzlbt8f000t0j66lxt60rd5","_id":"cjyzlbt8r001a0j669cghm5y4"},{"post_id":"cjyzlbt8c000o0j66vnitzvxu","category_id":"cjyzlbt8c000n0j66i075ukim","_id":"cjyzlbt8v001c0j66z6jq1es7"},{"post_id":"cjyzlbt8k00110j666pwr5l9a","category_id":"cjyzlbt8f000t0j66lxt60rd5","_id":"cjyzlbt8w001e0j66pwgp3d12"},{"post_id":"cjyzlbt8n00140j66pgr6guiu","category_id":"cjyzlbt8f000t0j66lxt60rd5","_id":"cjyzlbt8y001i0j66li9aas6h"},{"post_id":"cjyzlbt8d000q0j66o4axsm00","category_id":"cjyzlbt8f000t0j66lxt60rd5","_id":"cjyzlbt8z001k0j66xid5iq9y"},{"post_id":"cjyzlbt8o00160j66oye6ja14","category_id":"cjyzlbt8f000t0j66lxt60rd5","_id":"cjyzlbt90001o0j6608d0un4f"},{"post_id":"cjyzlbt8q00190j66pwo536aa","category_id":"cjyzlbt8f000t0j66lxt60rd5","_id":"cjyzlbt92001r0j66slfw6c3a"},{"post_id":"cjyzlbt8e000s0j66k0d6jxf6","category_id":"cjyzlbt8f000t0j66lxt60rd5","_id":"cjyzlbt93001v0j66j0ynq9a1"},{"post_id":"cjyzlbt8t001b0j66eof4p3uc","category_id":"cjyzlbt8w001f0j661qpsotv8","_id":"cjyzlbt94001y0j666head7q7"},{"post_id":"cjyzlbt8z001l0j6660kmmj3y","category_id":"cjyzlbt8c000n0j66i075ukim","_id":"cjyzlbt95001z0j66002bqmxa"},{"post_id":"cjyzlbt8v001d0j6641zxftfh","category_id":"cjyzlbt8w001f0j661qpsotv8","_id":"cjyzlbt9500230j66n1ozwpej"},{"post_id":"cjyzlbt8x001h0j66bo2hto2b","category_id":"cjyzlbt93001t0j66mxktuhri","_id":"cjyzlbt9600240j66b73y9kbm"},{"post_id":"cjyzlbt8y001j0j665gs0ucd1","category_id":"cjyzlbt9500200j66ivo7791s","_id":"cjyzlbt9600280j665haoinxk"},{"post_id":"cjyzlbt92001s0j66rnm3o7od","category_id":"cjyzlbt9600250j66g1rb4rgu","_id":"cjyzlbt97002b0j66l6fhaqc6"},{"post_id":"cjyzlbt94001x0j66qfwjxm16","category_id":"cjyzlbt9600290j662755w1g4","_id":"cjyzlbt97002c0j66oxk9myg6"},{"post_id":"cjyzlbt9c002d0j66bd4s1rqa","category_id":"cjyzlbt7k00040j66f1k7zu8t","_id":"cjyzlbt9m002g0j66vcduu2t2"},{"post_id":"cjyzlbt9d002e0j668mct0214","category_id":"cjyzlbt7k00040j66f1k7zu8t","_id":"cjyzlbt9n002h0j6622bjwjc8"},{"post_id":"cjyzlbt9e002f0j66qdgzhulr","category_id":"cjyzlbt7k00040j66f1k7zu8t","_id":"cjyzlbt9n002i0j666a53mvty"},{"post_id":"cjyzlbtbm002j0j66cpjvd7gx","category_id":"cjyzlbt8c000n0j66i075ukim","_id":"cjyzlbtbo002k0j66ps6ynp5d"}],"PostTag":[{"post_id":"cjyzlbt7900010j66uz1rigmb","tag_id":"cjyzlbt7m00050j66v6maf9c1","_id":"cjyzlbt82000a0j66itpbdzlk"},{"post_id":"cjyzlbt8t001b0j66eof4p3uc","tag_id":"cjyzlbt8w001g0j66kb50213v","_id":"cjyzlbt91001p0j66x753whu4"},{"post_id":"cjyzlbt8v001d0j6641zxftfh","tag_id":"cjyzlbt8w001g0j66kb50213v","_id":"cjyzlbt93001w0j66sluuu1n6"},{"post_id":"cjyzlbt8x001h0j66bo2hto2b","tag_id":"cjyzlbt93001u0j66pkgp78wz","_id":"cjyzlbt9500220j663edrcijj"},{"post_id":"cjyzlbt8y001j0j665gs0ucd1","tag_id":"cjyzlbt9500210j66cec5qdv4","_id":"cjyzlbt9600270j66q28uy8vg"},{"post_id":"cjyzlbt94001x0j66qfwjxm16","tag_id":"cjyzlbt9600260j66a6zdcndi","_id":"cjyzlbt96002a0j6685tpp29y"}],"Tag":[{"name":"文本语音播报","_id":"cjyzlbt7m00050j66v6maf9c1"},{"name":"SRS","_id":"cjyzlbt8w001g0j66kb50213v"},{"name":"TCP/IP","_id":"cjyzlbt93001u0j66pkgp78wz"},{"name":"Xcode问题","_id":"cjyzlbt9500210j66cec5qdv4"},{"name":"八大排序","_id":"cjyzlbt9600260j66a6zdcndi"}]}}